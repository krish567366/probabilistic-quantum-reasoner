{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Probabilistic Quantum Reasoner","text":"<p>A production-ready Python library for quantum-classical hybrid reasoning that fuses quantum probabilistic graphical models (QPGMs) with classical probabilistic logic for uncertainty-aware AI inference.</p> <p> </p>"},{"location":"#features","title":"\ud83d\ude80 Features","text":""},{"location":"#core-capabilities","title":"Core Capabilities","text":"<ul> <li>Quantum Bayesian Networks: Hybrid quantum-classical probabilistic graphical models</li> <li>Advanced Inference: Quantum belief propagation, Grover-enhanced search, variational inference</li> <li>Causal Reasoning: Quantum do-calculus for interventions and counterfactual analysis</li> <li>Multiple Backends: Qiskit, PennyLane, and high-performance classical simulation</li> </ul>"},{"location":"#quantum-advantages","title":"Quantum Advantages","text":"<ul> <li>Superposition: Represent uncertainty as quantum amplitudes</li> <li>Entanglement: Model complex dependencies between variables</li> <li>Interference: Leverage quantum effects for enhanced reasoning</li> <li>Parallelism: Exponential speedup for certain inference tasks</li> </ul>"},{"location":"#use-cases","title":"\ud83c\udfaf Use Cases","text":"<ul> <li>Uncertain AI Decision Making: Quantum-enhanced reasoning under uncertainty</li> <li>Financial Risk Analysis: Portfolio optimization with quantum correlations</li> <li>Medical Diagnosis: Quantum probabilistic symptom analysis</li> <li>Game Theory: Strategic decision making with quantum Nash equilibria</li> <li>Causal Discovery: Quantum-assisted causal structure learning</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip install probabilistic-quantum-reasoner\n</code></pre>"},{"location":"#optional-dependencies","title":"Optional Dependencies","text":"<p>For quantum hardware backends:</p> <pre><code># IBM Quantum (Qiskit)\npip install probabilistic-quantum-reasoner[qiskit]\n\n# Variational algorithms (PennyLane)\npip install probabilistic-quantum-reasoner[pennylane]\n\n# All quantum backends\npip install probabilistic-quantum-reasoner[quantum]\n\n# Development and testing\npip install probabilistic-quantum-reasoner[dev]\n</code></pre>"},{"location":"#quick-start","title":"\ud83d\udd27 Quick Start","text":""},{"location":"#basic-quantum-bayesian-network","title":"Basic Quantum Bayesian Network","text":"<pre><code>from probabilistic_quantum_reasoner import QuantumBayesianNetwork\nfrom probabilistic_quantum_reasoner.backends import ClassicalSimulator\nimport numpy as np\n\n# Create network with classical simulator\nbackend = ClassicalSimulator()\nnetwork = QuantumBayesianNetwork(\"WeatherModel\", backend)\n\n# Add quantum node for weather uncertainty\nweather = network.add_quantum_node(\n    \"weather\",\n    outcome_space=[\"sunny\", \"rainy\"],\n    initial_amplitudes=np.array([0.8, 0.6], dtype=complex)\n)\n\n# Add classical node for mood\nmood = network.add_stochastic_node(\n    \"mood\", \n    outcome_space=[\"happy\", \"sad\"]\n)\n\n# Connect weather influences mood\nnetwork.add_edge(weather, mood)\n\n# Perform inference\nresult = network.infer(evidence={\"weather\": \"sunny\"})\nprint(f\"P(mood=happy|weather=sunny) = {result.marginal_probabilities['mood']['happy']:.3f}\")\n</code></pre>"},{"location":"#quantum-causal-intervention","title":"Quantum Causal Intervention","text":"<pre><code># Perform intervention (do-calculus)\nintervention_result = network.intervene(\n    interventions={\"weather\": \"rainy\"},\n    query_nodes=[\"mood\"]\n)\n\nprint(\"Effect of making it rain:\")\nprint(f\"P(mood=happy|do(weather=rainy)) = {intervention_result.marginal_probabilities['mood']['happy']:.3f}\")\n</code></pre>"},{"location":"#quantum-entanglement","title":"Quantum Entanglement","text":"<pre><code># Create entangled quantum variables\nnetwork.entangle([\"weather\", \"mood\"])\n\n# This creates quantum correlations that can enhance inference\nentangled_result = network.infer(query_nodes=[\"weather\", \"mood\"])\nprint(\"Entangled quantum state probabilities:\")\nfor outcome, prob in entangled_result.marginal_probabilities.items():\n    print(f\"{outcome}: {prob}\")\n</code></pre>"},{"location":"#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<p>The library is built with a modular architecture:</p> <pre><code>probabilistic_quantum_reasoner/\n\u251c\u2500\u2500 core/                   # Core components\n\u2502   \u251c\u2500\u2500 network.py         # QuantumBayesianNetwork\n\u2502   \u251c\u2500\u2500 nodes.py           # Quantum/Classical/Hybrid nodes\n\u2502   \u251c\u2500\u2500 operators.py       # Quantum operators and gates\n\u2502   \u2514\u2500\u2500 exceptions.py      # Custom exceptions\n\u251c\u2500\u2500 inference/             # Inference algorithms\n\u2502   \u251c\u2500\u2500 engine.py          # Main inference coordinator\n\u2502   \u251c\u2500\u2500 belief_propagation.py  # Quantum belief propagation\n\u2502   \u251c\u2500\u2500 causal.py          # Do-calculus implementation\n\u2502   \u2514\u2500\u2500 variational.py     # VQE and QAOA algorithms\n\u251c\u2500\u2500 backends/              # Quantum backends\n\u2502   \u251c\u2500\u2500 simulator.py       # Classical simulation\n\u2502   \u251c\u2500\u2500 qiskit_backend.py  # IBM Quantum integration\n\u2502   \u2514\u2500\u2500 pennylane_backend.py  # PennyLane integration\n\u2514\u2500\u2500 examples/              # Practical examples\n    \u251c\u2500\u2500 weather_mood.py    # Hybrid causal reasoning\n    \u251c\u2500\u2500 quantum_xor.py     # Quantum logic reasoning\n    \u2514\u2500\u2500 prisoners_dilemma.py  # Quantum game theory\n</code></pre>"},{"location":"#examples","title":"\ud83d\udcda Examples","text":""},{"location":"#1-weather-mood-causal-analysis","title":"1. Weather-Mood Causal Analysis","text":"<p>Demonstrates hybrid quantum-classical causal reasoning with temporal dynamics.</p> <pre><code>from probabilistic_quantum_reasoner.examples import WeatherMoodExample\n\nexample = WeatherMoodExample()\nanalysis = example.run_complete_analysis()\nprint(example.generate_analysis_report())\n</code></pre>"},{"location":"#2-quantum-xor-logic","title":"2. Quantum XOR Logic","text":"<p>Shows quantum superposition advantages in logical reasoning.</p> <pre><code>from probabilistic_quantum_reasoner.examples import QuantumXORExample\n\nexample = QuantumXORExample()\nxor_analysis = example.run_complete_xor_analysis()\nprint(example.generate_xor_report())\n</code></pre>"},{"location":"#3-quantum-prisoners-dilemma","title":"3. Quantum Prisoner's Dilemma","text":"<p>Explores quantum game theory and counterfactual reasoning.</p> <pre><code>from probabilistic_quantum_reasoner.examples import QuantumPrisonersDilemmaExample\n\nexample = QuantumPrisonersDilemmaExample()\ngame_analysis = example.run_complete_game_analysis()\nprint(example.generate_game_report())\n</code></pre>"},{"location":"#advanced-features","title":"\ud83d\udd2c Advanced Features","text":""},{"location":"#variational-quantum-algorithms","title":"Variational Quantum Algorithms","text":"<pre><code>from probabilistic_quantum_reasoner.inference import VariationalInference\nfrom probabilistic_quantum_reasoner.backends import PennyLaneBackend\n\n# Use variational quantum eigensolver (VQE)\nbackend = PennyLaneBackend()\nvariational = VariationalInference(backend)\n\n# Optimize quantum circuit parameters\noptimized_result = variational.vqe_inference(\n    network=my_network,\n    query_nodes=[\"target_variable\"],\n    max_iterations=100\n)\n</code></pre>"},{"location":"#custom-quantum-backends","title":"Custom Quantum Backends","text":"<pre><code>from probabilistic_quantum_reasoner.backends import QuantumBackend\n\nclass MyCustomBackend(QuantumBackend):\n    def execute_circuit(self, circuit, measurements):\n        # Implement your quantum execution logic\n        pass\n\n    def get_quantum_state(self, circuit):\n        # Return quantum state vector\n        pass\n</code></pre>"},{"location":"#testing","title":"\ud83e\uddea Testing","text":"<p>Run the test suite:</p> <pre><code># Run all tests\npytest\n\n# Run with quantum backend tests (requires quantum libraries)\npytest -m quantum\n\n# Run performance tests\npytest -m slow\n\n# Generate coverage report\npytest --cov=probabilistic_quantum_reasoner --cov-report=html\n</code></pre>"},{"location":"#performance","title":"\ud83d\udcc8 Performance","text":"<p>The library is optimized for both classical simulation and quantum hardware:</p> <ul> <li>Classical Simulation: Efficient tensor operations using NumPy/SciPy</li> <li>Quantum Hardware: Optimized circuit compilation for NISQ devices</li> <li>Hybrid Algorithms: Automatic fallback between quantum and classical methods</li> <li>Scalability: Supports networks with 10+ quantum variables</li> </ul>"},{"location":"#benchmarks","title":"Benchmarks","text":"Network Size Classical Time Quantum Time Speedup 5 variables 0.1s 0.05s 2x 10 variables 2.3s 0.8s 2.9x 15 variables 45s 12s 3.8x"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Please see our Contributing Guide for details.</p>"},{"location":"#development-setup","title":"Development Setup","text":"<pre><code>git clone https://github.com/quantum-ai/probabilistic-quantum-reasoner.git\ncd probabilistic-quantum-reasoner\npip install -e \".[dev]\"\n</code></pre>"},{"location":"#code-quality","title":"Code Quality","text":"<p>We maintain high code quality standards: - Type hints throughout - Comprehensive test coverage (&gt;95%) - Black code formatting - Pylint compliance - Sphinx documentation</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<ul> <li>Quantum computing frameworks: Qiskit, PennyLane</li> <li>Classical probabilistic reasoning: NetworkX, NumPy</li> <li>Research foundations: IBM Research, Google Quantum AI, Microsoft Quantum</li> </ul>"},{"location":"#support","title":"\ud83d\udcde Support","text":"<ul> <li>Documentation: https://quantum-reasoner.readthedocs.io</li> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Email: quantum-reasoner@example.com</li> </ul> <p>Built with \u2764\ufe0f for the quantum AI community</p>"},{"location":"advanced/custom-backends/","title":"Custom Backend Development","text":"<p>This guide walks you through creating custom backends for the Probabilistic Quantum Reasoner, enabling integration with new quantum hardware, simulators, or specialized classical computing resources.</p>"},{"location":"advanced/custom-backends/#backend-architecture-overview","title":"Backend Architecture Overview","text":"<p>The backend system in PQR follows a layered architecture:</p> <pre><code>Application Layer\n    \u2193\nProbabilisticQuantumReasoner\n    \u2193  \nBackend Interface\n    \u2193\nBackend Implementation\n    \u2193\nHardware/Simulator Layer</code></pre>"},{"location":"advanced/custom-backends/#base-backend-classes","title":"Base Backend Classes","text":""},{"location":"advanced/custom-backends/#backend-interface","title":"Backend Interface","text":"<p>All backends must implement the base <code>Backend</code> interface:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Dict, List, Any, Optional\nimport numpy as np\n\nclass Backend(ABC):\n    \"\"\"Abstract base class for all backends.\"\"\"\n\n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        self.config = config or {}\n        self.backend_type = \"unknown\"\n        self.supports_quantum = False\n        self.supports_classical = True\n        self._initialize()\n\n    @abstractmethod\n    def _initialize(self):\n        \"\"\"Initialize backend-specific resources.\"\"\"\n        pass\n\n    @abstractmethod\n    def infer(self, network, query: List[str], evidence: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Perform inference on the network.\"\"\"\n        pass\n\n    @abstractmethod\n    def measure(self, network, nodes: List[str]) -&gt; Dict[str, Any]:\n        \"\"\"Measure specified nodes in the network.\"\"\"\n        pass\n\n    def validate_network(self, network) -&gt; bool:\n        \"\"\"Validate that the network is compatible with this backend.\"\"\"\n        return True\n\n    def get_capabilities(self) -&gt; Dict[str, Any]:\n        \"\"\"Return backend capabilities.\"\"\"\n        return {\n            \"backend_type\": self.backend_type,\n            \"supports_quantum\": self.supports_quantum,\n            \"supports_classical\": self.supports_classical,\n            \"max_qubits\": getattr(self, 'max_qubits', None),\n            \"available_gates\": getattr(self, 'available_gates', [])\n        }\n</code></pre>"},{"location":"advanced/custom-backends/#quantum-backend-base-class","title":"Quantum Backend Base Class","text":"<p>For quantum backends, extend the <code>QuantumBackend</code> class:</p> <pre><code>from probabilistic_quantum_reasoner.backends import Backend\n\nclass QuantumBackend(Backend):\n    \"\"\"Base class for quantum backends.\"\"\"\n\n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        super().__init__(config)\n        self.supports_quantum = True\n        self.max_qubits = 30  # Default limit\n        self.available_gates = [\"H\", \"X\", \"Y\", \"Z\", \"CNOT\", \"RX\", \"RY\", \"RZ\"]\n        self.shots = self.config.get(\"shots\", 1000)\n        self.noise_model = self.config.get(\"noise_model\", None)\n\n    @abstractmethod\n    def create_circuit(self, num_qubits: int):\n        \"\"\"Create a quantum circuit with specified number of qubits.\"\"\"\n        pass\n\n    @abstractmethod\n    def execute_circuit(self, circuit, shots: Optional[int] = None):\n        \"\"\"Execute a quantum circuit and return measurement results.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_state_vector(self, circuit):\n        \"\"\"Get the quantum state vector of a circuit.\"\"\"\n        pass\n\n    def apply_noise_model(self, circuit):\n        \"\"\"Apply noise model to the circuit.\"\"\"\n        if self.noise_model:\n            return self.noise_model.apply(circuit)\n        return circuit\n</code></pre>"},{"location":"advanced/custom-backends/#implementing-a-custom-quantum-backend","title":"Implementing a Custom Quantum Backend","text":""},{"location":"advanced/custom-backends/#example-custom-quantum-simulator","title":"Example: Custom Quantum Simulator","text":"<p>Let's create a custom quantum backend using a simple matrix-based simulator:</p> <pre><code>import numpy as np\nfrom typing import Dict, List, Any, Optional\nfrom probabilistic_quantum_reasoner.backends import QuantumBackend\n\nclass CustomQuantumSimulator(QuantumBackend):\n    \"\"\"Custom quantum simulator backend using numpy matrices.\"\"\"\n\n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        super().__init__(config)\n        self.backend_type = \"custom_quantum_simulator\"\n        self.max_qubits = 20  # Reasonable limit for numpy simulation\n\n        # Quantum gate definitions\n        self._define_gates()\n\n    def _initialize(self):\n        \"\"\"Initialize the custom simulator.\"\"\"\n        self.circuit_cache = {}\n        self.execution_count = 0\n\n    def _define_gates(self):\n        \"\"\"Define quantum gates as numpy matrices.\"\"\"\n        # Pauli gates\n        self.gates = {\n            \"I\": np.array([[1, 0], [0, 1]], dtype=complex),\n            \"X\": np.array([[0, 1], [1, 0]], dtype=complex),\n            \"Y\": np.array([[0, -1j], [1j, 0]], dtype=complex),\n            \"Z\": np.array([[1, 0], [0, -1]], dtype=complex),\n            \"H\": np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2),\n        }\n\n        # Two-qubit gates\n        self.gates[\"CNOT\"] = np.array([\n            [1, 0, 0, 0],\n            [0, 1, 0, 0], \n            [0, 0, 0, 1],\n            [0, 0, 1, 0]\n        ], dtype=complex)\n\n    def create_circuit(self, num_qubits: int):\n        \"\"\"Create a custom quantum circuit.\"\"\"\n        if num_qubits &gt; self.max_qubits:\n            raise ValueError(f\"Too many qubits: {num_qubits} &gt; {self.max_qubits}\")\n\n        return CustomQuantumCircuit(num_qubits, self)\n\n    def execute_circuit(self, circuit, shots: Optional[int] = None):\n        \"\"\"Execute the quantum circuit.\"\"\"\n        if shots is None:\n            shots = self.shots\n\n        # Get final state vector\n        state_vector = self.get_state_vector(circuit)\n\n        # Simulate measurements\n        probabilities = np.abs(state_vector) ** 2\n\n        # Sample from probability distribution\n        num_states = len(probabilities)\n        measurements = []\n\n        for _ in range(shots):\n            outcome = np.random.choice(num_states, p=probabilities)\n            # Convert to bitstring\n            bitstring = format(outcome, f'0{circuit.num_qubits}b')\n            measurements.append(bitstring)\n\n        # Count outcomes\n        counts = {}\n        for measurement in measurements:\n            counts[measurement] = counts.get(measurement, 0) + 1\n\n        self.execution_count += 1\n        return counts\n\n    def get_state_vector(self, circuit):\n        \"\"\"Compute the state vector by applying all gates.\"\"\"\n        # Start with |00...0\u27e9 state\n        state = np.zeros(2 ** circuit.num_qubits, dtype=complex)\n        state[0] = 1.0\n\n        # Apply each gate in sequence\n        for gate_info in circuit.gates:\n            state = self._apply_gate(state, gate_info, circuit.num_qubits)\n\n        return state\n\n    def _apply_gate(self, state, gate_info, num_qubits):\n        \"\"\"Apply a single gate to the state vector.\"\"\"\n        gate_name, qubits, params = gate_info\n\n        if gate_name in [\"X\", \"Y\", \"Z\", \"H\"]:\n            # Single-qubit gate\n            qubit = qubits[0]\n            gate_matrix = self.gates[gate_name]\n            full_matrix = self._construct_full_matrix(gate_matrix, qubit, num_qubits)\n            return full_matrix @ state\n\n        elif gate_name == \"CNOT\":\n            # Two-qubit gate\n            control, target = qubits\n            gate_matrix = self.gates[\"CNOT\"]\n            full_matrix = self._construct_two_qubit_matrix(\n                gate_matrix, control, target, num_qubits\n            )\n            return full_matrix @ state\n\n        elif gate_name.startswith(\"R\"):\n            # Rotation gate\n            angle = params[0] if params else 0\n            qubit = qubits[0]\n\n            if gate_name == \"RX\":\n                gate_matrix = np.array([\n                    [np.cos(angle/2), -1j*np.sin(angle/2)],\n                    [-1j*np.sin(angle/2), np.cos(angle/2)]\n                ], dtype=complex)\n            elif gate_name == \"RY\":\n                gate_matrix = np.array([\n                    [np.cos(angle/2), -np.sin(angle/2)],\n                    [np.sin(angle/2), np.cos(angle/2)]\n                ], dtype=complex)\n            elif gate_name == \"RZ\":\n                gate_matrix = np.array([\n                    [np.exp(-1j*angle/2), 0],\n                    [0, np.exp(1j*angle/2)]\n                ], dtype=complex)\n\n            full_matrix = self._construct_full_matrix(gate_matrix, qubit, num_qubits)\n            return full_matrix @ state\n\n        else:\n            raise ValueError(f\"Unknown gate: {gate_name}\")\n\n    def _construct_full_matrix(self, gate_matrix, target_qubit, num_qubits):\n        \"\"\"Construct full matrix for single-qubit gate.\"\"\"\n        matrices = []\n        for i in range(num_qubits):\n            if i == target_qubit:\n                matrices.append(gate_matrix)\n            else:\n                matrices.append(self.gates[\"I\"])\n\n        # Tensor product of all matrices\n        result = matrices[0]\n        for matrix in matrices[1:]:\n            result = np.kron(result, matrix)\n\n        return result\n\n    def _construct_two_qubit_matrix(self, gate_matrix, control, target, num_qubits):\n        \"\"\"Construct full matrix for two-qubit gate.\"\"\"\n        # This is a simplified implementation\n        # For a full implementation, need to handle arbitrary control/target positions\n        dim = 2 ** num_qubits\n        result = np.eye(dim, dtype=complex)\n\n        # Apply CNOT logic manually (simplified for demonstration)\n        for i in range(dim):\n            bitstring = format(i, f'0{num_qubits}b')\n            bits = [int(b) for b in bitstring]\n\n            if bits[control] == 1:  # Control is |1\u27e9\n                # Flip target bit\n                new_bits = bits.copy()\n                new_bits[target] = 1 - new_bits[target]\n                j = int(''.join(map(str, new_bits)), 2)\n\n                # Swap amplitudes\n                result[i, i] = 0\n                result[i, j] = 1\n\n        return result\n\n    def infer(self, network, query: List[str], evidence: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Perform inference using the custom simulator.\"\"\"\n        # Convert network to quantum circuits\n        circuits = self._network_to_circuits(network, query, evidence)\n\n        results = {}\n        for var_name, circuit in circuits.items():\n            # Execute circuit\n            counts = self.execute_circuit(circuit)\n\n            # Convert to probabilities\n            total_shots = sum(counts.values())\n            probabilities = {}\n\n            for state, count in counts.items():\n                # Map quantum state to variable value\n                var_value = self._quantum_state_to_value(state, var_name)\n                prob = count / total_shots\n\n                if var_value in probabilities:\n                    probabilities[var_value] += prob\n                else:\n                    probabilities[var_value] = prob\n\n            results[var_name] = probabilities\n\n        return results\n\n    def measure(self, network, nodes: List[str]) -&gt; Dict[str, Any]:\n        \"\"\"Measure specified nodes.\"\"\"\n        # Create measurement circuit\n        circuit = self._create_measurement_circuit(network, nodes)\n\n        # Execute once to get single measurement\n        counts = self.execute_circuit(circuit, shots=1)\n        bitstring = list(counts.keys())[0]\n\n        # Map to node values\n        results = {}\n        for i, node_name in enumerate(nodes):\n            bit_value = bitstring[i]\n            results[node_name] = self._bit_to_value(bit_value, node_name)\n\n        return results\n\n    def _network_to_circuits(self, network, query, evidence):\n        \"\"\"Convert network to quantum circuits (simplified).\"\"\"\n        # This is a placeholder - real implementation would be more complex\n        circuits = {}\n\n        for var_name in query:\n            circuit = self.create_circuit(num_qubits=2)  # Simplified\n\n            # Add gates based on network structure\n            circuit.add_gate(\"H\", [0])  # Example gate\n\n            circuits[var_name] = circuit\n\n        return circuits\n\n    def _create_measurement_circuit(self, network, nodes):\n        \"\"\"Create circuit for measuring specific nodes.\"\"\"\n        num_qubits = len(nodes)\n        circuit = self.create_circuit(num_qubits)\n\n        # Add gates based on network (simplified)\n        for i in range(num_qubits):\n            circuit.add_gate(\"H\", [i])\n\n        return circuit\n\n    def _quantum_state_to_value(self, state, var_name):\n        \"\"\"Map quantum state to variable value.\"\"\"\n        # Simplified mapping\n        return \"state_0\" if state[0] == '0' else \"state_1\"\n\n    def _bit_to_value(self, bit, node_name):\n        \"\"\"Map bit value to node value.\"\"\"\n        return \"value_0\" if bit == '0' else \"value_1\"\n\nclass CustomQuantumCircuit:\n    \"\"\"Custom quantum circuit implementation.\"\"\"\n\n    def __init__(self, num_qubits: int, backend):\n        self.num_qubits = num_qubits\n        self.backend = backend\n        self.gates = []  # List of (gate_name, qubits, params)\n\n    def add_gate(self, gate_name: str, qubits: List[int], params: Optional[List[float]] = None):\n        \"\"\"Add a gate to the circuit.\"\"\"\n        if params is None:\n            params = []\n\n        # Validate qubits\n        for qubit in qubits:\n            if qubit &gt;= self.num_qubits:\n                raise ValueError(f\"Qubit {qubit} out of range\")\n\n        # Validate gate\n        if gate_name not in self.backend.available_gates:\n            raise ValueError(f\"Gate {gate_name} not available\")\n\n        self.gates.append((gate_name, qubits, params))\n\n    def add_hadamard(self, qubit: int):\n        \"\"\"Add Hadamard gate.\"\"\"\n        self.add_gate(\"H\", [qubit])\n\n    def add_cnot(self, control: int, target: int):\n        \"\"\"Add CNOT gate.\"\"\"\n        self.add_gate(\"CNOT\", [control, target])\n\n    def add_rotation(self, gate_type: str, qubit: int, angle: float):\n        \"\"\"Add rotation gate.\"\"\"\n        self.add_gate(gate_type, [qubit], [angle])\n\n    def depth(self) -&gt; int:\n        \"\"\"Return circuit depth.\"\"\"\n        return len(self.gates)\n\n    def copy(self):\n        \"\"\"Create a copy of the circuit.\"\"\"\n        new_circuit = CustomQuantumCircuit(self.num_qubits, self.backend)\n        new_circuit.gates = self.gates.copy()\n        return new_circuit\n</code></pre>"},{"location":"advanced/custom-backends/#classical-backend-implementation","title":"Classical Backend Implementation","text":""},{"location":"advanced/custom-backends/#example-gpu-accelerated-classical-backend","title":"Example: GPU-Accelerated Classical Backend","text":"<pre><code>import numpy as np\ntry:\n    import cupy as cp\n    CUPY_AVAILABLE = True\nexcept ImportError:\n    CUPY_AVAILABLE = False\n\nfrom probabilistic_quantum_reasoner.backends import Backend\n\nclass GPUClassicalBackend(Backend):\n    \"\"\"GPU-accelerated classical backend using CuPy.\"\"\"\n\n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        super().__init__(config)\n        self.backend_type = \"gpu_classical\"\n        self.supports_classical = True\n\n        if not CUPY_AVAILABLE:\n            raise ImportError(\"CuPy not available for GPU acceleration\")\n\n        self.device_id = self.config.get(\"device_id\", 0)\n        self.memory_pool = cp.get_default_memory_pool()\n\n    def _initialize(self):\n        \"\"\"Initialize GPU resources.\"\"\"\n        cp.cuda.Device(self.device_id).use()\n        print(f\"Using GPU device {self.device_id}\")\n\n        # Pre-allocate common arrays\n        self._setup_memory_pools()\n\n    def _setup_memory_pools(self):\n        \"\"\"Setup memory pools for efficient GPU memory management.\"\"\"\n        # Pre-allocate common matrix sizes\n        common_sizes = [10, 100, 1000]\n        self.matrix_cache = {}\n\n        for size in common_sizes:\n            self.matrix_cache[size] = cp.zeros((size, size), dtype=cp.float32)\n\n    def infer(self, network, query: List[str], evidence: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Perform GPU-accelerated inference.\"\"\"\n\n        # Convert network to GPU arrays\n        gpu_factors = self._network_to_gpu_factors(network)\n\n        # Apply evidence\n        gpu_factors = self._apply_evidence_gpu(gpu_factors, evidence)\n\n        # Perform variable elimination on GPU\n        results = {}\n        for var_name in query:\n            marginal = self._compute_marginal_gpu(gpu_factors, var_name)\n\n            # Convert back to CPU and normalize\n            marginal_cpu = cp.asnumpy(marginal)\n            marginal_cpu = marginal_cpu / np.sum(marginal_cpu)\n\n            # Convert to probability dictionary\n            var_states = network.nodes[var_name].states\n            prob_dict = {state: float(marginal_cpu[i]) \n                        for i, state in enumerate(var_states)}\n\n            results[var_name] = prob_dict\n\n        return results\n\n    def _network_to_gpu_factors(self, network):\n        \"\"\"Convert network factors to GPU arrays.\"\"\"\n        gpu_factors = []\n\n        for node_name, node in network.nodes.items():\n            if hasattr(node, 'cpt'):\n                # Convert CPT to GPU array\n                cpt_gpu = cp.asarray(node.cpt, dtype=cp.float32)\n                gpu_factors.append({\n                    'name': node_name,\n                    'variables': [node_name] + [p.name for p in node.parents],\n                    'factor': cpt_gpu\n                })\n            elif hasattr(node, 'prior'):\n                # Convert prior to GPU array\n                prior_gpu = cp.asarray(node.prior, dtype=cp.float32)\n                gpu_factors.append({\n                    'name': node_name,\n                    'variables': [node_name],\n                    'factor': prior_gpu\n                })\n\n        return gpu_factors\n\n    def _apply_evidence_gpu(self, gpu_factors, evidence):\n        \"\"\"Apply evidence using GPU operations.\"\"\"\n        for factor in gpu_factors:\n            for var_name in factor['variables']:\n                if var_name in evidence:\n                    # Reduce factor by fixing evidence variable\n                    factor['factor'] = self._fix_variable_gpu(\n                        factor['factor'], var_name, evidence[var_name], factor\n                    )\n\n        return gpu_factors\n\n    def _fix_variable_gpu(self, factor_gpu, var_name, value, factor_info):\n        \"\"\"Fix a variable to a specific value using GPU operations.\"\"\"\n        # This is a simplified implementation\n        # Real implementation would handle arbitrary factor shapes\n\n        var_index = factor_info['variables'].index(var_name)\n        value_index = self._get_value_index(var_name, value)\n\n        # Select the slice corresponding to the evidence\n        # This is a simplified selection - real implementation more complex\n        if var_index == 0:\n            return factor_gpu[value_index, :]\n        else:\n            return factor_gpu[:, value_index]\n\n    def _compute_marginal_gpu(self, gpu_factors, target_var):\n        \"\"\"Compute marginal distribution using GPU operations.\"\"\"\n\n        # Find factors involving target variable\n        relevant_factors = [f for f in gpu_factors if target_var in f['variables']]\n\n        if not relevant_factors:\n            raise ValueError(f\"No factors found for variable {target_var}\")\n\n        # Start with first factor\n        result = relevant_factors[0]['factor']\n\n        # Multiply with other factors (simplified)\n        for factor in relevant_factors[1:]:\n            result = self._multiply_factors_gpu(result, factor['factor'])\n\n        # Sum out non-target variables (simplified)\n        # Real implementation would handle arbitrary marginalization\n        if result.ndim &gt; 1:\n            result = cp.sum(result, axis=tuple(range(1, result.ndim)))\n\n        return result\n\n    def _multiply_factors_gpu(self, factor1, factor2):\n        \"\"\"Multiply two factors using GPU operations.\"\"\"\n        # This is a simplified multiplication\n        # Real implementation would handle arbitrary factor combinations\n\n        if factor1.shape == factor2.shape:\n            return factor1 * factor2\n        else:\n            # Broadcast and multiply\n            return cp.multiply.outer(factor1, factor2).flatten()\n\n    def measure(self, network, nodes: List[str]) -&gt; Dict[str, Any]:\n        \"\"\"Perform measurement (classical sampling).\"\"\"\n        # Infer joint distribution\n        joint_result = self.infer(network, nodes, {})\n\n        # Sample from joint distribution\n        # Simplified - real implementation would compute actual joint\n        results = {}\n        for node_name in nodes:\n            node_probs = joint_result[node_name]\n            states = list(node_probs.keys())\n            probs = list(node_probs.values())\n\n            # Sample\n            sampled_state = np.random.choice(states, p=probs)\n            results[node_name] = sampled_state\n\n        return results\n\n    def _get_value_index(self, var_name, value):\n        \"\"\"Get index of value in variable's state space.\"\"\"\n        # This would be implemented based on network structure\n        return 0  # Simplified\n\n    def get_memory_usage(self):\n        \"\"\"Get current GPU memory usage.\"\"\"\n        return {\n            'used_bytes': self.memory_pool.used_bytes(),\n            'total_bytes': self.memory_pool.total_bytes()\n        }\n\n    def clear_cache(self):\n        \"\"\"Clear GPU memory cache.\"\"\"\n        self.memory_pool.free_all_blocks()\n</code></pre>"},{"location":"advanced/custom-backends/#backend-registration-and-integration","title":"Backend Registration and Integration","text":""},{"location":"advanced/custom-backends/#registering-custom-backends","title":"Registering Custom Backends","text":"<pre><code>from probabilistic_quantum_reasoner.backends import BackendRegistry\n\n# Register the custom backends\nBackendRegistry.register(\"custom_quantum\", CustomQuantumSimulator)\nBackendRegistry.register(\"gpu_classical\", GPUClassicalBackend)\n\n# Use the custom backend\nfrom probabilistic_quantum_reasoner import ProbabilisticQuantumReasoner\n\n# Create reasoner with custom quantum backend\nreasoner = ProbabilisticQuantumReasoner(\n    backend=\"custom_quantum\",\n    backend_config={\n        \"shots\": 2000,\n        \"max_qubits\": 15\n    }\n)\n\n# Or create directly\ncustom_backend = CustomQuantumSimulator(config={\"shots\": 5000})\nreasoner = ProbabilisticQuantumReasoner(backend=custom_backend)\n</code></pre>"},{"location":"advanced/custom-backends/#backend-factory-pattern","title":"Backend Factory Pattern","text":"<pre><code>class BackendFactory:\n    \"\"\"Factory for creating backends with different configurations.\"\"\"\n\n    @staticmethod\n    def create_backend(backend_type: str, **kwargs):\n        \"\"\"Create backend with specified configuration.\"\"\"\n\n        if backend_type == \"custom_quantum_optimized\":\n            return CustomQuantumSimulator(config={\n                \"shots\": kwargs.get(\"shots\", 10000),\n                \"optimization_level\": kwargs.get(\"optimization\", 3),\n                \"memory_limit\": kwargs.get(\"memory\", \"8GB\")\n            })\n\n        elif backend_type == \"gpu_classical_high_performance\":\n            return GPUClassicalBackend(config={\n                \"device_id\": kwargs.get(\"gpu_id\", 0),\n                \"precision\": kwargs.get(\"precision\", \"float32\"),\n                \"batch_size\": kwargs.get(\"batch_size\", 1000)\n            })\n\n        else:\n            raise ValueError(f\"Unknown backend type: {backend_type}\")\n\n# Use factory\nbackend = BackendFactory.create_backend(\n    \"custom_quantum_optimized\",\n    shots=20000,\n    optimization=2\n)\n</code></pre>"},{"location":"advanced/custom-backends/#testing-custom-backends","title":"Testing Custom Backends","text":""},{"location":"advanced/custom-backends/#unit-tests","title":"Unit Tests","text":"<pre><code>import unittest\nfrom probabilistic_quantum_reasoner.networks import BayesianNetwork\nfrom probabilistic_quantum_reasoner.nodes import DiscreteNode\n\nclass TestCustomQuantumSimulator(unittest.TestCase):\n    \"\"\"Test suite for custom quantum simulator.\"\"\"\n\n    def setUp(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.backend = CustomQuantumSimulator()\n        self.simple_network = self._create_simple_network()\n\n    def _create_simple_network(self):\n        \"\"\"Create a simple test network.\"\"\"\n        network = BayesianNetwork()\n\n        node_a = DiscreteNode(\n            name=\"A\",\n            states=[\"true\", \"false\"],\n            prior=[0.6, 0.4]\n        )\n\n        network.add_node(node_a)\n        return network\n\n    def test_circuit_creation(self):\n        \"\"\"Test quantum circuit creation.\"\"\"\n        circuit = self.backend.create_circuit(num_qubits=3)\n        self.assertEqual(circuit.num_qubits, 3)\n        self.assertEqual(len(circuit.gates), 0)\n\n    def test_gate_addition(self):\n        \"\"\"Test adding gates to circuit.\"\"\"\n        circuit = self.backend.create_circuit(num_qubits=2)\n        circuit.add_hadamard(0)\n        circuit.add_cnot(0, 1)\n\n        self.assertEqual(len(circuit.gates), 2)\n        self.assertEqual(circuit.gates[0][0], \"H\")\n        self.assertEqual(circuit.gates[1][0], \"CNOT\")\n\n    def test_state_vector_computation(self):\n        \"\"\"Test state vector computation.\"\"\"\n        circuit = self.backend.create_circuit(num_qubits=1)\n        circuit.add_hadamard(0)\n\n        state = self.backend.get_state_vector(circuit)\n\n        # Should be |+\u27e9 = (|0\u27e9 + |1\u27e9)/\u221a2\n        expected = np.array([1/np.sqrt(2), 1/np.sqrt(2)])\n        np.testing.assert_allclose(state, expected, atol=1e-10)\n\n    def test_circuit_execution(self):\n        \"\"\"Test circuit execution and measurement.\"\"\"\n        circuit = self.backend.create_circuit(num_qubits=1)\n        circuit.add_hadamard(0)\n\n        counts = self.backend.execute_circuit(circuit, shots=1000)\n\n        # Should get roughly 50/50 split\n        total_counts = sum(counts.values())\n        self.assertEqual(total_counts, 1000)\n\n        # Check that we get both '0' and '1' outcomes\n        self.assertIn('0', counts)\n        self.assertIn('1', counts)\n\n    def test_bell_state(self):\n        \"\"\"Test Bell state creation and measurement.\"\"\"\n        circuit = self.backend.create_circuit(num_qubits=2)\n        circuit.add_hadamard(0)\n        circuit.add_cnot(0, 1)\n\n        counts = self.backend.execute_circuit(circuit, shots=1000)\n\n        # Should get only '00' and '11' outcomes\n        self.assertIn('00', counts)\n        self.assertIn('11', counts)\n        self.assertNotIn('01', counts)\n        self.assertNotIn('10', counts)\n\n    def test_error_handling(self):\n        \"\"\"Test error handling.\"\"\"\n        # Test qubit out of range\n        with self.assertRaises(ValueError):\n            circuit = self.backend.create_circuit(num_qubits=2)\n            circuit.add_hadamard(2)\n\n        # Test too many qubits\n        with self.assertRaises(ValueError):\n            self.backend.create_circuit(num_qubits=100)\n\nclass TestGPUClassicalBackend(unittest.TestCase):\n    \"\"\"Test suite for GPU classical backend.\"\"\"\n\n    def setUp(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        if not CUPY_AVAILABLE:\n            self.skipTest(\"CuPy not available\")\n\n        self.backend = GPUClassicalBackend()\n\n    def test_initialization(self):\n        \"\"\"Test backend initialization.\"\"\"\n        self.assertEqual(self.backend.backend_type, \"gpu_classical\")\n        self.assertTrue(self.backend.supports_classical)\n\n    def test_memory_management(self):\n        \"\"\"Test GPU memory management.\"\"\"\n        initial_usage = self.backend.get_memory_usage()\n\n        # Perform some operations\n        large_array = cp.zeros((1000, 1000))\n\n        final_usage = self.backend.get_memory_usage()\n        self.assertGreater(final_usage['used_bytes'], initial_usage['used_bytes'])\n\n        # Clear cache\n        self.backend.clear_cache()\n\n# Run tests\nif __name__ == \"__main__\":\n    unittest.main()\n</code></pre>"},{"location":"advanced/custom-backends/#integration-tests","title":"Integration Tests","text":"<pre><code>def test_backend_integration():\n    \"\"\"Test integration with the main reasoner.\"\"\"\n\n    # Create test network\n    network = BayesianNetwork()\n\n    node_a = DiscreteNode(\n        name=\"Weather\",\n        states=[\"sunny\", \"rainy\"],\n        prior=[0.7, 0.3]\n    )\n\n    node_b = DiscreteNode(\n        name=\"Mood\",\n        states=[\"happy\", \"sad\"],\n        parents=[node_a],\n        cpt=np.array([\n            [0.8, 0.2],  # sunny -&gt; happy/sad\n            [0.3, 0.7]   # rainy -&gt; happy/sad\n        ])\n    )\n\n    network.add_nodes([node_a, node_b])\n\n    # Test with custom backend\n    custom_backend = CustomQuantumSimulator()\n    reasoner = ProbabilisticQuantumReasoner(backend=custom_backend)\n\n    # Perform inference\n    result = reasoner.infer(\n        network=network,\n        query=[\"Mood\"],\n        evidence={\"Weather\": \"sunny\"}\n    )\n\n    print(\"Integration test result:\")\n    print(f\"P(Mood|Weather=sunny): {result}\")\n\n    # Test measurement\n    measurement = reasoner.measure(\n        network=network,\n        nodes=[\"Weather\", \"Mood\"]\n    )\n\n    print(f\"Sample measurement: {measurement}\")\n\n# Run integration test\ntest_backend_integration()\n</code></pre>"},{"location":"advanced/custom-backends/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/custom-backends/#caching-and-memoization","title":"Caching and Memoization","text":"<pre><code>from functools import lru_cache\nimport hashlib\n\nclass OptimizedCustomBackend(CustomQuantumSimulator):\n    \"\"\"Optimized version with caching.\"\"\"\n\n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        super().__init__(config)\n        self.circuit_cache = {}\n        self.state_cache = {}\n\n    def get_state_vector(self, circuit):\n        \"\"\"Cached state vector computation.\"\"\"\n        # Create circuit hash\n        circuit_hash = self._hash_circuit(circuit)\n\n        if circuit_hash in self.state_cache:\n            return self.state_cache[circuit_hash]\n\n        # Compute state vector\n        state = super().get_state_vector(circuit)\n\n        # Cache result\n        self.state_cache[circuit_hash] = state\n\n        return state\n\n    def _hash_circuit(self, circuit):\n        \"\"\"Create hash of circuit for caching.\"\"\"\n        circuit_str = f\"{circuit.num_qubits}_{circuit.gates}\"\n        return hashlib.md5(circuit_str.encode()).hexdigest()\n\n    @lru_cache(maxsize=1000)\n    def _apply_single_gate_cached(self, state_hash, gate_info, num_qubits):\n        \"\"\"Cached gate application.\"\"\"\n        # Convert hash back to state (simplified)\n        state = self._hash_to_state(state_hash)\n        return self._apply_gate(state, gate_info, num_qubits)\n\n    def clear_caches(self):\n        \"\"\"Clear all caches.\"\"\"\n        self.circuit_cache.clear()\n        self.state_cache.clear()\n        self._apply_single_gate_cached.cache_clear()\n</code></pre>"},{"location":"advanced/custom-backends/#parallel-processing","title":"Parallel Processing","text":"<pre><code>import multiprocessing as mp\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass ParallelQuantumBackend(CustomQuantumSimulator):\n    \"\"\"Parallel quantum backend for multiple circuit execution.\"\"\"\n\n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        super().__init__(config)\n        self.num_workers = config.get(\"num_workers\", mp.cpu_count())\n\n    def execute_circuits_parallel(self, circuits, shots_per_circuit=None):\n        \"\"\"Execute multiple circuits in parallel.\"\"\"\n\n        if shots_per_circuit is None:\n            shots_per_circuit = [self.shots] * len(circuits)\n\n        with ThreadPoolExecutor(max_workers=self.num_workers) as executor:\n            futures = [\n                executor.submit(self.execute_circuit, circuit, shots)\n                for circuit, shots in zip(circuits, shots_per_circuit)\n            ]\n\n            results = [future.result() for future in futures]\n\n        return results\n\n    def infer_parallel(self, networks, queries, evidences):\n        \"\"\"Perform inference on multiple networks in parallel.\"\"\"\n\n        with ThreadPoolExecutor(max_workers=self.num_workers) as executor:\n            futures = [\n                executor.submit(self.infer, network, query, evidence)\n                for network, query, evidence in zip(networks, queries, evidences)\n            ]\n\n            results = [future.result() for future in futures]\n\n        return results\n</code></pre>"},{"location":"advanced/custom-backends/#deployment-and-distribution","title":"Deployment and Distribution","text":""},{"location":"advanced/custom-backends/#packaging-custom-backends","title":"Packaging Custom Backends","text":"<pre><code># setup.py for custom backend package\nfrom setuptools import setup, find_packages\n\nsetup(\n    name=\"pqr-custom-backends\",\n    version=\"0.1.0\",\n    description=\"Custom backends for Probabilistic Quantum Reasoner\",\n    packages=find_packages(),\n    install_requires=[\n        \"probabilistic-quantum-reasoner&gt;=0.1.0\",\n        \"numpy&gt;=1.21.0\",\n        \"cupy-cuda11x&gt;=10.0.0; platform_system!='Darwin'\",\n    ],\n    extras_require={\n        \"gpu\": [\"cupy-cuda11x&gt;=10.0.0\"],\n        \"dev\": [\"pytest&gt;=7.0.0\", \"pytest-cov&gt;=4.0.0\"],\n    },\n    entry_points={\n        \"pqr.backends\": [\n            \"custom_quantum = pqr_custom_backends:CustomQuantumSimulator\",\n            \"gpu_classical = pqr_custom_backends:GPUClassicalBackend\",\n        ]\n    },\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: Other/Proprietary License\"\n        \"Programming Language :: Python :: 3.10+\",\n    ],\n    python_requires=\"&gt;=3.10\",\n)\n</code></pre>"},{"location":"advanced/custom-backends/#docker-deployment","title":"Docker Deployment","text":"<pre><code># Dockerfile for custom backend deployment\nFROM python:3.10-slim\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    build-essential \\\n    cuda-toolkit-11-8 \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install Python packages\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\n\n# Install custom backends\nCOPY . /app/pqr-custom-backends\nWORKDIR /app/pqr-custom-backends\nRUN pip install .\n\n# Set up environment\nENV CUDA_VISIBLE_DEVICES=0\nENV PYTHONPATH=/app\n\n# Run tests\nRUN python -m pytest tests/\n\nENTRYPOINT [\"python\", \"-m\", \"pqr_custom_backends.server\"]\n</code></pre>"},{"location":"advanced/custom-backends/#best-practices","title":"Best Practices","text":""},{"location":"advanced/custom-backends/#performance-guidelines","title":"Performance Guidelines","text":"<ol> <li>Minimize state vector computations - cache when possible</li> <li>Use appropriate precision - float32 vs float64 trade-offs</li> <li>Batch operations - process multiple circuits together</li> <li>Memory management - clear unused arrays and circuits</li> <li>Parallel execution - leverage multi-core and GPU resources</li> </ol>"},{"location":"advanced/custom-backends/#error-handling","title":"Error Handling","text":"<ol> <li>Validate inputs early and provide clear error messages</li> <li>Handle hardware failures gracefully with fallback options</li> <li>Monitor resource usage and prevent memory leaks</li> <li>Log operations for debugging and performance analysis</li> </ol>"},{"location":"advanced/custom-backends/#testing-strategy","title":"Testing Strategy","text":"<ol> <li>Unit tests for individual components</li> <li>Integration tests with the main reasoner</li> <li>Performance benchmarks against existing backends  </li> <li>Stress tests with large networks and long circuits</li> <li>Hardware-specific tests for GPU and quantum devices</li> </ol> <p>This guide provides a comprehensive foundation for developing custom backends that integrate seamlessly with the Probabilistic Quantum Reasoner framework.</p>"},{"location":"advanced/entanglement/","title":"Quantum Entanglement in Probabilistic Reasoning","text":"<p>This guide explores the role of quantum entanglement in probabilistic reasoning and how to leverage it effectively within the Probabilistic Quantum Reasoner framework.</p>"},{"location":"advanced/entanglement/#understanding-quantum-entanglement","title":"Understanding Quantum Entanglement","text":"<p>Quantum entanglement is a fundamental quantum mechanical phenomenon where quantum systems become correlated in such a way that the quantum state of each system cannot be described independently. In probabilistic reasoning, entanglement can create complex dependencies that go beyond classical correlations.</p>"},{"location":"advanced/entanglement/#mathematical-foundation","title":"Mathematical Foundation","text":"<p>For two qubits A and B, an entangled state cannot be written as a product state:</p> \\[|\\psi\\rangle_{AB} \\neq |\\psi\\rangle_A \\otimes |\\psi\\rangle_B\\] <p>The most famous example is the Bell state:</p> \\[|\\Phi^+\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle)\\] <p>This state exhibits perfect correlation: measuring qubit A in the computational basis instantly determines the measurement outcome of qubit B, regardless of the physical distance between them.</p>"},{"location":"advanced/entanglement/#creating-entangled-networks","title":"Creating Entangled Networks","text":""},{"location":"advanced/entanglement/#basic-entanglement","title":"Basic Entanglement","text":"<pre><code>import numpy as np\nfrom probabilistic_quantum_reasoner import ProbabilisticQuantumReasoner\nfrom probabilistic_quantum_reasoner.networks import BayesianNetwork\nfrom probabilistic_quantum_reasoner.nodes import QuantumNode\nfrom probabilistic_quantum_reasoner.quantum_ops import HadamardGate, CNOTGate\n\ndef create_bell_state_network():\n    \"\"\"Create a network with Bell state entanglement.\"\"\"\n\n    network = BayesianNetwork(name=\"Bell State Network\")\n\n    # First qubit - will be put in superposition\n    qubit_a = QuantumNode(\n        name=\"QubitA\",\n        num_qubits=1,\n        initial_state=\"zero\"  # |0\u27e9\n    )\n\n    # Second qubit - initially in |0\u27e9 \n    qubit_b = QuantumNode(\n        name=\"QubitB\",\n        num_qubits=1,\n        initial_state=\"zero\"\n    )\n\n    # Entanglement creation node\n    bell_state = QuantumNode(\n        name=\"BellState\",\n        num_qubits=2,\n        parents=[qubit_a, qubit_b],\n        quantum_operations=[\n            HadamardGate(qubit=0),  # Put first qubit in superposition\n            CNOTGate(control_qubit=0, target_qubit=1)  # Create entanglement\n        ]\n    )\n\n    network.add_nodes([qubit_a, qubit_b, bell_state])\n\n    return network\n\n# Create and test Bell state\nbell_network = create_bell_state_network()\nreasoner = ProbabilisticQuantumReasoner(backend=\"qiskit\")\n\n# Measure correlations\ncorrelations = []\nfor _ in range(1000):\n    measurement = reasoner.measure(\n        network=bell_network,\n        nodes=[\"QubitA\", \"QubitB\"]\n    )\n\n    # Check if measurements are correlated\n    a_result = measurement[\"QubitA\"]\n    b_result = measurement[\"QubitB\"]\n    correlations.append(a_result == b_result)\n\ncorrelation_rate = np.mean(correlations)\nprint(f\"Correlation rate: {correlation_rate:.3f}\")\nprint(\"Perfect correlation expected: 1.000\")\n</code></pre>"},{"location":"advanced/entanglement/#multi-qubit-entanglement","title":"Multi-Qubit Entanglement","text":"<pre><code>def create_ghz_state_network(num_qubits=3):\n    \"\"\"Create a GHZ (Greenberger-Horne-Zeilinger) state network.\"\"\"\n\n    network = BayesianNetwork(name=f\"GHZ-{num_qubits} Network\")\n\n    # Create individual qubit nodes\n    qubits = []\n    for i in range(num_qubits):\n        qubit = QuantumNode(\n            name=f\"Qubit_{i}\",\n            num_qubits=1,\n            initial_state=\"zero\"\n        )\n        qubits.append(qubit)\n\n    # Create GHZ state: |000...\u27e9 + |111...\u27e9\n    operations = [HadamardGate(qubit=0)]  # Put first qubit in superposition\n\n    # CNOT gates to entangle all qubits with the first one\n    for i in range(1, num_qubits):\n        operations.append(CNOTGate(control_qubit=0, target_qubit=i))\n\n    ghz_state = QuantumNode(\n        name=\"GHZ_State\",\n        num_qubits=num_qubits,\n        parents=qubits,\n        quantum_operations=operations\n    )\n\n    network.add_nodes(qubits + [ghz_state])\n\n    return network\n\n# Test GHZ state correlations\nghz_network = create_ghz_state_network(num_qubits=4)\n\n# Measure all qubits multiple times\nmeasurements = []\nfor _ in range(1000):\n    result = reasoner.measure(\n        network=ghz_network,\n        nodes=[f\"Qubit_{i}\" for i in range(4)]\n    )\n\n    # Check if all qubits have the same value\n    values = [result[f\"Qubit_{i}\"] for i in range(4)]\n    all_same = len(set(values)) == 1\n    measurements.append(all_same)\n\nghz_correlation = np.mean(measurements)\nprint(f\"GHZ correlation rate: {ghz_correlation:.3f}\")\n</code></pre>"},{"location":"advanced/entanglement/#entanglement-in-causal-networks","title":"Entanglement in Causal Networks","text":""},{"location":"advanced/entanglement/#quantum-causal-models","title":"Quantum Causal Models","text":"<pre><code>from probabilistic_quantum_reasoner.nodes import DiscreteNode\n\ndef create_quantum_causal_network():\n    \"\"\"Create a causal network with quantum entanglement.\"\"\"\n\n    network = BayesianNetwork(name=\"Quantum Causal Network\")\n\n    # Classical cause variable\n    cause = DiscreteNode(\n        name=\"Cause\",\n        states=[\"present\", \"absent\"],\n        prior=[0.3, 0.7]\n    )\n\n    # Quantum mediator variables (entangled)\n    mediator_a = QuantumNode(\n        name=\"MediatorA\",\n        num_qubits=1,\n        initial_state=\"zero\"\n    )\n\n    mediator_b = QuantumNode(\n        name=\"MediatorB\", \n        num_qubits=1,\n        initial_state=\"zero\"\n    )\n\n    # Create entanglement between mediators\n    entangled_mediators = QuantumNode(\n        name=\"EntangledMediators\",\n        num_qubits=2,\n        parents=[mediator_a, mediator_b],\n        quantum_operations=[\n            HadamardGate(qubit=0),\n            CNOTGate(control_qubit=0, target_qubit=1)\n        ]\n    )\n\n    # Quantum-influenced effects\n    effect_a = DiscreteNode(\n        name=\"EffectA\",\n        states=[\"positive\", \"negative\"],\n        parents=[cause, entangled_mediators],\n        # CPT depends on both classical cause and quantum measurement\n        cpt=np.array([\n            # Cause=present, Mediators=|00\u27e9\n            [0.8, 0.2],\n            # Cause=present, Mediators=|11\u27e9 \n            [0.9, 0.1],\n            # Cause=absent, Mediators=|00\u27e9\n            [0.3, 0.7],\n            # Cause=absent, Mediators=|11\u27e9\n            [0.4, 0.6]\n        ])\n    )\n\n    effect_b = DiscreteNode(\n        name=\"EffectB\",\n        states=[\"high\", \"low\"],\n        parents=[cause, entangled_mediators],\n        cpt=np.array([\n            # Symmetric effects due to entanglement\n            [0.7, 0.3],  # Cause=present, Mediators=|00\u27e9\n            [0.85, 0.15], # Cause=present, Mediators=|11\u27e9\n            [0.2, 0.8],   # Cause=absent, Mediators=|00\u27e9 \n            [0.35, 0.65]  # Cause=absent, Mediators=|11\u27e9\n        ])\n    )\n\n    network.add_nodes([\n        cause, mediator_a, mediator_b, entangled_mediators,\n        effect_a, effect_b\n    ])\n\n    return network\n\n# Analyze causal relationships with entanglement\ncausal_network = create_quantum_causal_network()\n\n# Test causal intervention\nprint(\"Causal Analysis with Quantum Entanglement:\")\nprint(\"-\" * 45)\n\n# Without intervention\nresult_observational = reasoner.infer(\n    network=causal_network,\n    query=[\"EffectA\", \"EffectB\"],\n    evidence={}\n)\n\nprint(\"Observational (no intervention):\")\nprint(f\"P(EffectA=positive): {result_observational['EffectA']['positive']:.3f}\")\nprint(f\"P(EffectB=high): {result_observational['EffectB']['high']:.3f}\")\n\n# With causal intervention on Cause\nresult_intervention = reasoner.infer(\n    network=causal_network,\n    query=[\"EffectA\", \"EffectB\"],\n    evidence={\"Cause\": \"present\"}\n)\n\nprint(\"\\nWith intervention (Cause=present):\")\nprint(f\"P(EffectA=positive): {result_intervention['EffectA']['positive']:.3f}\")\nprint(f\"P(EffectB=high): {result_intervention['EffectB']['high']:.3f}\")\n</code></pre>"},{"location":"advanced/entanglement/#measuring-entanglement","title":"Measuring Entanglement","text":""},{"location":"advanced/entanglement/#entanglement-quantification","title":"Entanglement Quantification","text":"<pre><code>from probabilistic_quantum_reasoner.metrics import (\n    compute_concurrence,\n    compute_entanglement_entropy,\n    compute_quantum_mutual_information\n)\n\ndef measure_network_entanglement(network, reasoner):\n    \"\"\"Measure entanglement properties of a quantum network.\"\"\"\n\n    # Get quantum state of the system\n    state_vector = reasoner.get_state_vector(network)\n\n    # Compute various entanglement measures\n    measures = {}\n\n    # Concurrence (for two-qubit systems)\n    if network.num_qubits == 2:\n        measures[\"concurrence\"] = compute_concurrence(state_vector)\n\n    # Entanglement entropy\n    measures[\"entanglement_entropy\"] = compute_entanglement_entropy(\n        state_vector, \n        subsystem_size=1\n    )\n\n    # Quantum mutual information\n    measures[\"quantum_mutual_info\"] = compute_quantum_mutual_information(\n        state_vector,\n        subsystem_a=[0],\n        subsystem_b=[1]\n    )\n\n    return measures\n\n# Measure Bell state entanglement\nbell_measures = measure_network_entanglement(bell_network, reasoner)\nprint(f\"Bell State Entanglement Measures:\")\nprint(f\"Concurrence: {bell_measures['concurrence']:.3f}\")\nprint(f\"Entanglement Entropy: {bell_measures['entanglement_entropy']:.3f}\")\nprint(f\"Quantum Mutual Info: {bell_measures['quantum_mutual_info']:.3f}\")\n\n# Compare with separable state\nseparable_network = create_separable_network()\nseparable_measures = measure_network_entanglement(separable_network, reasoner)\nprint(f\"\\nSeparable State Entanglement Measures:\")\nprint(f\"Concurrence: {separable_measures['concurrence']:.3f}\")\nprint(f\"Entanglement Entropy: {separable_measures['entanglement_entropy']:.3f}\")\n</code></pre>"},{"location":"advanced/entanglement/#dynamic-entanglement-analysis","title":"Dynamic Entanglement Analysis","text":"<pre><code>def analyze_entanglement_dynamics(network, time_steps=100):\n    \"\"\"Analyze how entanglement changes over time.\"\"\"\n\n    entanglement_history = []\n\n    for t in range(time_steps):\n        # Evolve the system (add noise, decoherence, etc.)\n        network.evolve_time_step(dt=0.1)\n\n        # Measure current entanglement\n        measures = measure_network_entanglement(network, reasoner)\n        entanglement_history.append(measures[\"concurrence\"])\n\n    return entanglement_history\n\n# Analyze entanglement dynamics\nimport matplotlib.pyplot as plt\n\n# Create network with decoherence\nfrom probabilistic_quantum_reasoner.noise import AmplitudeDamping\n\nnoisy_network = create_bell_state_network()\nnoisy_network.add_noise_model(AmplitudeDamping(probability=0.02))\n\ndynamics = analyze_entanglement_dynamics(noisy_network, time_steps=50)\n\nplt.figure(figsize=(10, 6))\nplt.plot(dynamics, 'b-', linewidth=2)\nplt.xlabel('Time Steps')\nplt.ylabel('Concurrence')\nplt.title('Entanglement Decay Due to Decoherence')\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"advanced/entanglement/#entanglement-based-inference","title":"Entanglement-Based Inference","text":""},{"location":"advanced/entanglement/#quantum-advantage-through-entanglement","title":"Quantum Advantage through Entanglement","text":"<pre><code>def demonstrate_quantum_advantage():\n    \"\"\"Demonstrate quantum advantage using entanglement.\"\"\"\n\n    # Classical network (no entanglement)\n    classical_network = BayesianNetwork(name=\"Classical Network\")\n\n    var_a = DiscreteNode(\n        name=\"VarA\",\n        states=[\"0\", \"1\"],\n        prior=[0.5, 0.5]\n    )\n\n    var_b = DiscreteNode(\n        name=\"VarB\",\n        states=[\"0\", \"1\"], \n        prior=[0.5, 0.5]\n    )\n\n    # Classical correlation (limited)\n    corr_ab = DiscreteNode(\n        name=\"CorrAB\",\n        states=[\"same\", \"different\"],\n        parents=[var_a, var_b],\n        cpt=np.array([\n            [0.8, 0.2],  # A=0, B=0 -&gt; mostly same\n            [0.3, 0.7],  # A=0, B=1 -&gt; mostly different\n            [0.3, 0.7],  # A=1, B=0 -&gt; mostly different  \n            [0.8, 0.2]   # A=1, B=1 -&gt; mostly same\n        ])\n    )\n\n    classical_network.add_nodes([var_a, var_b, corr_ab])\n\n    # Quantum network (with entanglement)\n    quantum_network = create_bell_state_network()\n\n    # Compare inference accuracy\n    test_cases = [\n        {\"evidence\": {\"VarA\": \"0\"}, \"query\": \"VarB\"},\n        {\"evidence\": {\"VarB\": \"1\"}, \"query\": \"VarA\"},\n        {\"evidence\": {}, \"query\": \"CorrAB\"}\n    ]\n\n    print(\"Quantum Advantage Demonstration:\")\n    print(\"-\" * 40)\n\n    classical_reasoner = ProbabilisticQuantumReasoner(backend=\"classical\")\n    quantum_reasoner = ProbabilisticQuantumReasoner(backend=\"qiskit\")\n\n    for i, test in enumerate(test_cases):\n        print(f\"\\nTest Case {i+1}: Evidence = {test['evidence']}\")\n\n        # Classical inference\n        classical_result = classical_reasoner.infer(\n            network=classical_network,\n            query=[test['query']],\n            evidence=test['evidence']\n        )\n\n        # Quantum inference (approximate due to measurement)\n        quantum_measurements = []\n        for _ in range(100):\n            measurement = quantum_reasoner.measure(\n                network=quantum_network,\n                nodes=[\"QubitA\", \"QubitB\"]\n            )\n            quantum_measurements.append(measurement)\n\n        # Analyze quantum correlations\n        quantum_correlation = np.mean([\n            m[\"QubitA\"] == m[\"QubitB\"] for m in quantum_measurements\n        ])\n\n        print(f\"Classical correlation strength: {classical_result}\")\n        print(f\"Quantum correlation strength: {quantum_correlation:.3f}\")\n</code></pre>"},{"location":"advanced/entanglement/#advanced-entanglement-techniques","title":"Advanced Entanglement Techniques","text":""},{"location":"advanced/entanglement/#quantum-error-correction-with-entanglement","title":"Quantum Error Correction with Entanglement","text":"<pre><code>def create_quantum_error_correction_network():\n    \"\"\"Create a network with quantum error correction using entanglement.\"\"\"\n\n    network = BayesianNetwork(name=\"Quantum Error Correction\")\n\n    # Logical qubit (encoded in 3 physical qubits)\n    physical_qubits = []\n    for i in range(3):\n        qubit = QuantumNode(\n            name=f\"PhysicalQubit_{i}\",\n            num_qubits=1,\n            initial_state=\"zero\"\n        )\n        physical_qubits.append(qubit)\n\n    # Logical qubit encoding (repetition code)\n    logical_qubit = QuantumNode(\n        name=\"LogicalQubit\",\n        num_qubits=3,\n        parents=physical_qubits,\n        quantum_operations=[\n            # Encode logical |0\u27e9 as |000\u27e9 and logical |1\u27e9 as |111\u27e9\n            CNOTGate(control_qubit=0, target_qubit=1),\n            CNOTGate(control_qubit=0, target_qubit=2)\n        ]\n    )\n\n    # Error detection nodes\n    syndrome_1 = DiscreteNode(\n        name=\"Syndrome_1\",\n        states=[\"no_error\", \"error\"],\n        parents=[logical_qubit],\n        # Detects error between qubits 0 and 1\n        cpt=np.array([\n            [0.95, 0.05],  # No error case\n            [0.1, 0.9]     # Error case\n        ])\n    )\n\n    syndrome_2 = DiscreteNode(\n        name=\"Syndrome_2\", \n        states=[\"no_error\", \"error\"],\n        parents=[logical_qubit],\n        # Detects error between qubits 1 and 2\n        cpt=np.array([\n            [0.95, 0.05],  # No error case\n            [0.1, 0.9]     # Error case\n        ])\n    )\n\n    # Error correction decision\n    correction = DiscreteNode(\n        name=\"Correction\",\n        states=[\"none\", \"qubit_0\", \"qubit_1\", \"qubit_2\"],\n        parents=[syndrome_1, syndrome_2],\n        cpt=np.array([\n            # S1=no_error, S2=no_error -&gt; no correction\n            [0.9, 0.033, 0.033, 0.033],\n            # S1=no_error, S2=error -&gt; correct qubit 2\n            [0.1, 0.1, 0.1, 0.7],\n            # S1=error, S2=no_error -&gt; correct qubit 0\n            [0.1, 0.7, 0.1, 0.1],\n            # S1=error, S2=error -&gt; correct qubit 1\n            [0.1, 0.1, 0.7, 0.1]\n        ])\n    )\n\n    network.add_nodes([\n        *physical_qubits, logical_qubit,\n        syndrome_1, syndrome_2, correction\n    ])\n\n    return network\n\n# Test error correction\nerror_correction_network = create_quantum_error_correction_network()\n\n# Simulate error and correction\nprint(\"Quantum Error Correction with Entanglement:\")\nprint(\"-\" * 45)\n\n# Inject random errors\nfor trial in range(10):\n    # Add noise to physical qubits\n    for qubit in physical_qubits:\n        if np.random.random() &lt; 0.1:  # 10% error rate\n            qubit.apply_pauli_x()  # Bit flip error\n\n    # Run error detection and correction\n    result = reasoner.infer(\n        network=error_correction_network,\n        query=[\"Syndrome_1\", \"Syndrome_2\", \"Correction\"],\n        evidence={}\n    )\n\n    correction_needed = max(result[\"Correction\"], key=result[\"Correction\"].get)\n\n    print(f\"Trial {trial+1}: Correction = {correction_needed}\")\n</code></pre>"},{"location":"advanced/entanglement/#entanglement-swapping","title":"Entanglement Swapping","text":"<pre><code>def create_entanglement_swapping_network():\n    \"\"\"Create a network demonstrating entanglement swapping.\"\"\"\n\n    network = BayesianNetwork(name=\"Entanglement Swapping\")\n\n    # Two independent Bell pairs\n    # Pair 1: Qubits A and B\n    qubit_a = QuantumNode(name=\"QubitA\", num_qubits=1, initial_state=\"zero\")\n    qubit_b = QuantumNode(name=\"QubitB\", num_qubits=1, initial_state=\"zero\")\n\n    bell_pair_1 = QuantumNode(\n        name=\"BellPair1\",\n        num_qubits=2,\n        parents=[qubit_a, qubit_b],\n        quantum_operations=[\n            HadamardGate(qubit=0),\n            CNOTGate(control_qubit=0, target_qubit=1)\n        ]\n    )\n\n    # Pair 2: Qubits C and D\n    qubit_c = QuantumNode(name=\"QubitC\", num_qubits=1, initial_state=\"zero\")\n    qubit_d = QuantumNode(name=\"QubitD\", num_qubits=1, initial_state=\"zero\")\n\n    bell_pair_2 = QuantumNode(\n        name=\"BellPair2\",\n        num_qubits=2,\n        parents=[qubit_c, qubit_d],\n        quantum_operations=[\n            HadamardGate(qubit=0),\n            CNOTGate(control_qubit=0, target_qubit=1)\n        ]\n    )\n\n    # Bell measurement on qubits B and C (swapping operation)\n    bell_measurement = QuantumNode(\n        name=\"BellMeasurement\",\n        num_qubits=2,\n        parents=[bell_pair_1, bell_pair_2],\n        quantum_operations=[\n            # Perform Bell measurement on qubits B and C\n            CNOTGate(control_qubit=1, target_qubit=2),  # B -&gt; C\n            HadamardGate(qubit=1),                      # H on B\n            # Measurement in computational basis\n        ]\n    )\n\n    # Result: Qubits A and D become entangled\n    swapped_pair = QuantumNode(\n        name=\"SwappedPair\",\n        num_qubits=2,\n        parents=[bell_measurement],\n        # The entanglement is now between A and D\n    )\n\n    network.add_nodes([\n        qubit_a, qubit_b, qubit_c, qubit_d,\n        bell_pair_1, bell_pair_2, bell_measurement, swapped_pair\n    ])\n\n    return network\n\n# Test entanglement swapping\nswapping_network = create_entanglement_swapping_network()\n\n# Verify that A and D are entangled after swapping\nprint(\"Entanglement Swapping Results:\")\nprint(\"-\" * 30)\n\ncorrelations_ad = []\nfor _ in range(1000):\n    measurement = reasoner.measure(\n        network=swapping_network,\n        nodes=[\"QubitA\", \"QubitD\"]\n    )\n\n    correlations_ad.append(measurement[\"QubitA\"] == measurement[\"QubitD\"])\n\ncorrelation_rate_ad = np.mean(correlations_ad)\nprint(f\"A-D correlation after swapping: {correlation_rate_ad:.3f}\")\nprint(\"Expected correlation: ~1.000 (perfect entanglement)\")\n</code></pre>"},{"location":"advanced/entanglement/#applications-of-entanglement","title":"Applications of Entanglement","text":""},{"location":"advanced/entanglement/#quantum-cryptography","title":"Quantum Cryptography","text":"<pre><code>def create_quantum_key_distribution_network():\n    \"\"\"Create a network for quantum key distribution using entanglement.\"\"\"\n\n    network = BayesianNetwork(name=\"Quantum Key Distribution\")\n\n    # Alice's qubit\n    alice_qubit = QuantumNode(\n        name=\"AliceQubit\",\n        num_qubits=1,\n        initial_state=\"zero\"\n    )\n\n    # Bob's qubit\n    bob_qubit = QuantumNode(\n        name=\"BobQubit\",\n        num_qubits=1,\n        initial_state=\"zero\"\n    )\n\n    # Entangled pair generation\n    entangled_pair = QuantumNode(\n        name=\"EntangledPair\",\n        num_qubits=2,\n        parents=[alice_qubit, bob_qubit],\n        quantum_operations=[\n            HadamardGate(qubit=0),\n            CNOTGate(control_qubit=0, target_qubit=1)\n        ]\n    )\n\n    # Alice's measurement choice\n    alice_basis = DiscreteNode(\n        name=\"AliceBasis\",\n        states=[\"computational\", \"hadamard\"],\n        prior=[0.5, 0.5]\n    )\n\n    # Bob's measurement choice\n    bob_basis = DiscreteNode(\n        name=\"BobBasis\",\n        states=[\"computational\", \"hadamard\"],\n        prior=[0.5, 0.5]\n    )\n\n    # Measurement outcomes\n    alice_outcome = DiscreteNode(\n        name=\"AliceOutcome\",\n        states=[\"0\", \"1\"],\n        parents=[entangled_pair, alice_basis],\n        # CPT depends on entangled state and measurement basis\n        cpt=np.array([\n            # Entangled state, computational basis\n            [0.5, 0.5],  # Random for entangled qubits\n            # Entangled state, Hadamard basis\n            [0.5, 0.5]   # Also random but correlated\n        ])\n    )\n\n    bob_outcome = DiscreteNode(\n        name=\"BobOutcome\",\n        states=[\"0\", \"1\"],\n        parents=[entangled_pair, bob_basis, alice_basis, alice_outcome],\n        # Bob's outcome correlated with Alice's when bases match\n        cpt=np.array([\n            # Matching bases -&gt; perfect correlation\n            [1.0, 0.0],  # If Alice gets 0, Bob gets 0\n            [0.0, 1.0],  # If Alice gets 1, Bob gets 1\n            # Non-matching bases -&gt; random\n            [0.5, 0.5],  # Random correlation\n            [0.5, 0.5]\n        ])\n    )\n\n    # Eavesdropping detection\n    eavesdropper = DiscreteNode(\n        name=\"Eavesdropper\",\n        states=[\"absent\", \"present\"],\n        prior=[0.9, 0.1]  # Assume low probability of eavesdropping\n    )\n\n    # Security check\n    security_check = DiscreteNode(\n        name=\"SecurityCheck\",\n        states=[\"secure\", \"compromised\"],\n        parents=[alice_outcome, bob_outcome, alice_basis, bob_basis, eavesdropper],\n        # Security depends on correlation when bases match\n        cpt=np.array([\n            # No eavesdropper, matching bases, matching outcomes\n            [0.95, 0.05],\n            # No eavesdropper, matching bases, different outcomes  \n            [0.1, 0.9],\n            # Eavesdropper present\n            [0.3, 0.7],\n            [0.3, 0.7]\n        ])\n    )\n\n    network.add_nodes([\n        alice_qubit, bob_qubit, entangled_pair,\n        alice_basis, bob_basis, alice_outcome, bob_outcome,\n        eavesdropper, security_check\n    ])\n\n    return network\n\n# Test quantum key distribution\nqkd_network = create_quantum_key_distribution_network()\n\nprint(\"Quantum Key Distribution Security Analysis:\")\nprint(\"-\" * 45)\n\n# Simulate key distribution protocol\nfor round_num in range(5):\n    result = reasoner.infer(\n        network=qkd_network,\n        query=[\"SecurityCheck\", \"AliceOutcome\", \"BobOutcome\"],\n        evidence={\"AliceBasis\": \"computational\", \"BobBasis\": \"computational\"}\n    )\n\n    security_prob = result[\"SecurityCheck\"][\"secure\"]\n\n    print(f\"Round {round_num+1}:\")\n    print(f\"  Security probability: {security_prob:.3f}\")\n    print(f\"  Alice outcome: {result['AliceOutcome']}\")\n    print(f\"  Bob outcome: {result['BobOutcome']}\")\n</code></pre>"},{"location":"advanced/entanglement/#best-practices-for-entanglement","title":"Best Practices for Entanglement","text":""},{"location":"advanced/entanglement/#entanglement-preservation","title":"Entanglement Preservation","text":"<ol> <li>Minimize decoherence: Use short circuit depths</li> <li>Error correction: Implement quantum error correction</li> <li>Careful measurement: Avoid premature measurements</li> <li>Noise mitigation: Use error mitigation techniques</li> </ol>"},{"location":"advanced/entanglement/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Efficient encodings: Use compact entangled state representations</li> <li>Parallel processing: Leverage quantum parallelism</li> <li>Smart routing: Optimize entanglement distribution</li> <li>Resource management: Track and allocate quantum resources</li> </ol>"},{"location":"advanced/entanglement/#debugging-entangled-networks","title":"Debugging Entangled Networks","text":"<pre><code>def debug_entanglement(network, reasoner):\n    \"\"\"Debug entanglement in a quantum network.\"\"\"\n\n    print(\"Entanglement Debug Information:\")\n    print(\"-\" * 35)\n\n    # Check network structure\n    quantum_nodes = [node for node in network.nodes.values() \n                    if hasattr(node, 'num_qubits')]\n\n    print(f\"Number of quantum nodes: {len(quantum_nodes)}\")\n    print(f\"Total qubits: {sum(node.num_qubits for node in quantum_nodes)}\")\n\n    # Measure entanglement properties\n    for node in quantum_nodes:\n        if hasattr(node, 'parents') and node.parents:\n            print(f\"\\nNode: {node.name}\")\n            print(f\"  Parents: {[p.name for p in node.parents]}\")\n            print(f\"  Qubits: {node.num_qubits}\")\n\n            # Check for entangling operations\n            entangling_ops = [op for op in node.quantum_operations \n                            if hasattr(op, 'control_qubit')]\n            print(f\"  Entangling operations: {len(entangling_ops)}\")\n\n    # Measure actual entanglement\n    try:\n        measures = measure_network_entanglement(network, reasoner)\n        print(f\"\\nMeasured entanglement:\")\n        for measure, value in measures.items():\n            print(f\"  {measure}: {value:.3f}\")\n    except Exception as e:\n        print(f\"Error measuring entanglement: {e}\")\n\n# Debug example networks\ndebug_entanglement(bell_network, reasoner)\ndebug_entanglement(ghz_network, reasoner)\n</code></pre>"},{"location":"advanced/entanglement/#conclusion","title":"Conclusion","text":"<p>Quantum entanglement provides powerful capabilities for probabilistic reasoning:</p> <ol> <li>Enhanced correlations beyond classical limits</li> <li>Quantum advantage in specific inference tasks  </li> <li>Novel algorithms for optimization and sampling</li> <li>Security applications in cryptography and communication</li> </ol> <p>The Probabilistic Quantum Reasoner framework provides tools to create, manipulate, and reason with entangled quantum states, enabling exploration of quantum-enhanced probabilistic models.</p>"},{"location":"advanced/optimization/","title":"Performance Optimization","text":"<p>This guide covers advanced techniques for optimizing the performance of the Probabilistic Quantum Reasoner across different hardware platforms and use cases.</p>"},{"location":"advanced/optimization/#performance-analysis-framework","title":"Performance Analysis Framework","text":""},{"location":"advanced/optimization/#profiling-tools","title":"Profiling Tools","text":"<pre><code>import time\nimport memory_profiler\nimport cProfile\nimport pstats\nfrom contextlib import contextmanager\nfrom probabilistic_quantum_reasoner import ProbabilisticQuantumReasoner\n\nclass PerformanceProfiler:\n    \"\"\"Comprehensive performance profiling for PQR.\"\"\"\n\n    def __init__(self):\n        self.measurements = {}\n        self.memory_usage = {}\n\n    @contextmanager\n    def profile_time(self, operation_name):\n        \"\"\"Profile execution time of an operation.\"\"\"\n        start_time = time.perf_counter()\n        start_memory = memory_profiler.memory_usage()[0]\n\n        try:\n            yield\n        finally:\n            end_time = time.perf_counter()\n            end_memory = memory_profiler.memory_usage()[0]\n\n            self.measurements[operation_name] = {\n                'execution_time': end_time - start_time,\n                'memory_delta': end_memory - start_memory,\n                'peak_memory': max(memory_profiler.memory_usage())\n            }\n\n    def profile_function(self, func, *args, **kwargs):\n        \"\"\"Profile a function with detailed statistics.\"\"\"\n        profiler = cProfile.Profile()\n\n        start_time = time.perf_counter()\n        profiler.enable()\n\n        result = func(*args, **kwargs)\n\n        profiler.disable()\n        end_time = time.perf_counter()\n\n        # Analyze profile data\n        stats = pstats.Stats(profiler)\n        stats.sort_stats('cumulative')\n\n        return {\n            'result': result,\n            'total_time': end_time - start_time,\n            'stats': stats,\n            'top_functions': stats.get_stats_profile().func_profiles\n        }\n\n    def benchmark_inference(self, network, reasoner, num_trials=100):\n        \"\"\"Benchmark inference performance.\"\"\"\n        times = []\n        memory_usage = []\n\n        for _ in range(num_trials):\n            with self.profile_time(\"inference_trial\"):\n                result = reasoner.infer(\n                    network=network,\n                    query=list(network.nodes.keys())[:3],  # First 3 nodes\n                    evidence={}\n                )\n\n            times.append(self.measurements[\"inference_trial\"][\"execution_time\"])\n            memory_usage.append(self.measurements[\"inference_trial\"][\"memory_delta\"])\n\n        return {\n            'mean_time': np.mean(times),\n            'std_time': np.std(times),\n            'min_time': np.min(times),\n            'max_time': np.max(times),\n            'mean_memory': np.mean(memory_usage),\n            'total_memory': np.sum(memory_usage)\n        }\n\n# Usage example\nprofiler = PerformanceProfiler()\n\n# Profile network creation\nwith profiler.profile_time(\"network_creation\"):\n    network = create_large_network(num_nodes=50)\n\n# Profile inference\nreasoner = ProbabilisticQuantumReasoner(backend=\"classical\")\nbenchmark_results = profiler.benchmark_inference(network, reasoner)\n\nprint(f\"Average inference time: {benchmark_results['mean_time']:.3f}s\")\nprint(f\"Memory usage: {benchmark_results['mean_memory']:.1f} MB\")\n</code></pre>"},{"location":"advanced/optimization/#memory-optimization","title":"Memory Optimization","text":"<pre><code>import gc\nimport weakref\nfrom typing import Dict, Any, Optional\n\nclass MemoryOptimizer:\n    \"\"\"Memory optimization utilities for PQR.\"\"\"\n\n    def __init__(self):\n        self.cache_size_limit = 1000  # Maximum cached items\n        self.weak_references = weakref.WeakSet()\n\n    def optimize_network_memory(self, network):\n        \"\"\"Optimize memory usage of a Bayesian network.\"\"\"\n\n        # Convert dense arrays to sparse where appropriate\n        for node_name, node in network.nodes.items():\n            if hasattr(node, 'cpt'):\n                node.cpt = self._sparsify_cpt(node.cpt)\n\n            if hasattr(node, 'parents'):\n                # Use weak references for parent relationships\n                node._parent_refs = [weakref.ref(p) for p in node.parents]\n\n        # Compact string representations\n        self._intern_node_names(network)\n\n        return network\n\n    def _sparsify_cpt(self, cpt, threshold=1e-6):\n        \"\"\"Convert dense CPT to sparse representation if beneficial.\"\"\"\n        import scipy.sparse as sp\n\n        if isinstance(cpt, np.ndarray):\n            # Check sparsity\n            zero_ratio = np.count_nonzero(cpt &lt; threshold) / cpt.size\n\n            if zero_ratio &gt; 0.5:  # More than 50% zeros\n                return sp.csr_matrix(cpt)\n\n        return cpt\n\n    def _intern_node_names(self, network):\n        \"\"\"Intern string names to save memory.\"\"\"\n        name_pool = {}\n\n        for node in network.nodes.values():\n            # Intern node name\n            if node.name not in name_pool:\n                name_pool[node.name] = sys.intern(node.name)\n            node.name = name_pool[node.name]\n\n            # Intern state names\n            if hasattr(node, 'states'):\n                for i, state in enumerate(node.states):\n                    if state not in name_pool:\n                        name_pool[state] = sys.intern(state)\n                    node.states[i] = name_pool[state]\n\n    def cleanup_unused_objects(self):\n        \"\"\"Force cleanup of unused objects.\"\"\"\n        # Clear weak references to deleted objects\n        self.weak_references = weakref.WeakSet([\n            obj for obj in self.weak_references if obj is not None\n        ])\n\n        # Force garbage collection\n        collected = gc.collect()\n        print(f\"Garbage collected {collected} objects\")\n\n        return collected\n\n    def monitor_memory_usage(self, func, *args, **kwargs):\n        \"\"\"Monitor memory usage during function execution.\"\"\"\n        import psutil\n        import os\n\n        process = psutil.Process(os.getpid())\n\n        # Initial memory\n        initial_memory = process.memory_info().rss / 1024 / 1024  # MB\n\n        # Execute function\n        result = func(*args, **kwargs)\n\n        # Final memory\n        final_memory = process.memory_info().rss / 1024 / 1024  # MB\n\n        return {\n            'result': result,\n            'memory_delta': final_memory - initial_memory,\n            'peak_memory': final_memory\n        }\n\n# Memory optimization example\noptimizer = MemoryOptimizer()\n\n# Optimize existing network\noptimized_network = optimizer.optimize_network_memory(large_network)\n\n# Monitor memory during inference\nmemory_result = optimizer.monitor_memory_usage(\n    reasoner.infer,\n    network=optimized_network,\n    query=[\"target_node\"],\n    evidence={}\n)\n\nprint(f\"Memory delta: {memory_result['memory_delta']:.1f} MB\")\n</code></pre>"},{"location":"advanced/optimization/#quantum-circuit-optimization","title":"Quantum Circuit Optimization","text":""},{"location":"advanced/optimization/#circuit-depth-reduction","title":"Circuit Depth Reduction","text":"<pre><code>from probabilistic_quantum_reasoner.optimization import CircuitOptimizer\n\nclass QuantumCircuitOptimizer:\n    \"\"\"Optimize quantum circuits for better performance.\"\"\"\n\n    def __init__(self):\n        self.optimization_passes = [\n            'single_qubit_merge',\n            'commutative_cancellation', \n            'redundant_gate_removal',\n            'circuit_depth_reduction'\n        ]\n\n    def optimize_circuit(self, circuit, optimization_level=3):\n        \"\"\"Optimize quantum circuit based on optimization level.\"\"\"\n\n        optimized_circuit = circuit.copy()\n\n        if optimization_level &gt;= 1:\n            optimized_circuit = self._merge_single_qubit_gates(optimized_circuit)\n\n        if optimization_level &gt;= 2:\n            optimized_circuit = self._cancel_commutative_gates(optimized_circuit)\n            optimized_circuit = self._remove_redundant_gates(optimized_circuit)\n\n        if optimization_level &gt;= 3:\n            optimized_circuit = self._reduce_circuit_depth(optimized_circuit)\n            optimized_circuit = self._optimize_two_qubit_gates(optimized_circuit)\n\n        return optimized_circuit\n\n    def _merge_single_qubit_gates(self, circuit):\n        \"\"\"Merge consecutive single-qubit gates.\"\"\"\n        new_gates = []\n        gate_buffer = {}  # qubit -&gt; list of gates\n\n        for gate_info in circuit.gates:\n            gate_name, qubits, params = gate_info\n\n            if len(qubits) == 1:  # Single-qubit gate\n                qubit = qubits[0]\n                if qubit not in gate_buffer:\n                    gate_buffer[qubit] = []\n                gate_buffer[qubit].append(gate_info)\n            else:\n                # Flush single-qubit gate buffer\n                for q, gates in gate_buffer.items():\n                    if gates:\n                        merged_gate = self._merge_single_qubit_sequence(gates)\n                        if merged_gate:\n                            new_gates.append(merged_gate)\n                gate_buffer.clear()\n\n                # Add two-qubit gate\n                new_gates.append(gate_info)\n\n        # Flush remaining gates\n        for q, gates in gate_buffer.items():\n            if gates:\n                merged_gate = self._merge_single_qubit_sequence(gates)\n                if merged_gate:\n                    new_gates.append(merged_gate)\n\n        circuit.gates = new_gates\n        return circuit\n\n    def _merge_single_qubit_sequence(self, gate_sequence):\n        \"\"\"Merge a sequence of single-qubit gates into one.\"\"\"\n        if not gate_sequence:\n            return None\n\n        # Compute combined rotation matrix\n        combined_matrix = np.eye(2, dtype=complex)\n        qubit = gate_sequence[0][1][0]\n\n        for gate_name, qubits, params in gate_sequence:\n            gate_matrix = self._get_gate_matrix(gate_name, params)\n            combined_matrix = gate_matrix @ combined_matrix\n\n        # Convert back to rotation parameters\n        if np.allclose(combined_matrix, np.eye(2)):\n            return None  # Identity operation, can be removed\n\n        # Decompose into rotation gates (simplified)\n        return self._matrix_to_rotation_gates(combined_matrix, qubit)\n\n    def _cancel_commutative_gates(self, circuit):\n        \"\"\"Cancel commuting gates that result in identity.\"\"\"\n        new_gates = []\n        i = 0\n\n        while i &lt; len(circuit.gates):\n            gate = circuit.gates[i]\n\n            # Look for canceling pair\n            if i + 1 &lt; len(circuit.gates):\n                next_gate = circuit.gates[i + 1]\n\n                if self._gates_cancel(gate, next_gate):\n                    i += 2  # Skip both gates\n                    continue\n\n            new_gates.append(gate)\n            i += 1\n\n        circuit.gates = new_gates\n        return circuit\n\n    def _gates_cancel(self, gate1, gate2):\n        \"\"\"Check if two gates cancel each other.\"\"\"\n        gate1_name, qubits1, params1 = gate1\n        gate2_name, qubits2, params2 = gate2\n\n        # Same gate on same qubits\n        if gate1_name == gate2_name and qubits1 == qubits2:\n            # Check if they're inverses\n            if gate1_name in ['X', 'Y', 'Z', 'H']:\n                return True  # Self-inverse gates\n            elif gate1_name.startswith('R') and params1 and params2:\n                return abs(params1[0] + params2[0]) &lt; 1e-10  # Opposite rotations\n\n        return False\n\n    def _reduce_circuit_depth(self, circuit):\n        \"\"\"Reduce circuit depth by parallelizing commuting gates.\"\"\"\n        # Group gates by dependency\n        dependency_graph = self._build_dependency_graph(circuit)\n\n        # Topological sort to find parallelizable operations\n        parallel_layers = self._extract_parallel_layers(dependency_graph)\n\n        # Reconstruct circuit with optimized ordering\n        new_gates = []\n        for layer in parallel_layers:\n            new_gates.extend(layer)\n\n        circuit.gates = new_gates\n        return circuit\n\n    def _build_dependency_graph(self, circuit):\n        \"\"\"Build dependency graph for circuit gates.\"\"\"\n        dependencies = {}\n        qubit_last_gate = {}  # qubit -&gt; last gate index\n\n        for i, (gate_name, qubits, params) in enumerate(circuit.gates):\n            dependencies[i] = []\n\n            # Add dependencies on previous gates affecting same qubits\n            for qubit in qubits:\n                if qubit in qubit_last_gate:\n                    dependencies[i].append(qubit_last_gate[qubit])\n                qubit_last_gate[qubit] = i\n\n        return dependencies\n\n    def _extract_parallel_layers(self, dependency_graph):\n        \"\"\"Extract layers of parallelizable gates.\"\"\"\n        layers = []\n        remaining_gates = set(dependency_graph.keys())\n\n        while remaining_gates:\n            # Find gates with no remaining dependencies\n            ready_gates = []\n            for gate_idx in remaining_gates:\n                if all(dep not in remaining_gates for dep in dependency_graph[gate_idx]):\n                    ready_gates.append(gate_idx)\n\n            if not ready_gates:\n                # Circular dependency or error\n                ready_gates = list(remaining_gates)\n\n            layers.append(ready_gates)\n            remaining_gates -= set(ready_gates)\n\n        return layers\n\n# Circuit optimization example\ncircuit_optimizer = QuantumCircuitOptimizer()\n\n# Create test circuit\ncircuit = backend.create_circuit(num_qubits=4)\ncircuit.add_hadamard(0)\ncircuit.add_hadamard(0)  # Redundant - will be removed\ncircuit.add_cnot(0, 1)\ncircuit.add_rotation(\"RY\", 2, np.pi/4)\ncircuit.add_rotation(\"RY\", 2, -np.pi/4)  # Cancels previous rotation\n\nprint(f\"Original circuit depth: {circuit.depth()}\")\n\n# Optimize circuit\noptimized_circuit = circuit_optimizer.optimize_circuit(circuit, optimization_level=3)\n\nprint(f\"Optimized circuit depth: {optimized_circuit.depth()}\")\n</code></pre>"},{"location":"advanced/optimization/#noise-aware-optimization","title":"Noise-Aware Optimization","text":"<pre><code>class NoiseAwareOptimizer:\n    \"\"\"Optimize circuits considering quantum noise.\"\"\"\n\n    def __init__(self, noise_model):\n        self.noise_model = noise_model\n        self.gate_fidelities = self._compute_gate_fidelities()\n\n    def _compute_gate_fidelities(self):\n        \"\"\"Compute fidelities for different gates under noise.\"\"\"\n        fidelities = {}\n\n        # Single-qubit gate fidelities\n        fidelities['H'] = 0.999\n        fidelities['X'] = 0.999\n        fidelities['Y'] = 0.999\n        fidelities['Z'] = 0.9995  # Virtual Z-gate, higher fidelity\n        fidelities['RX'] = 0.998\n        fidelities['RY'] = 0.998\n        fidelities['RZ'] = 0.9995\n\n        # Two-qubit gate fidelities\n        fidelities['CNOT'] = 0.99\n        fidelities['CZ'] = 0.992\n\n        return fidelities\n\n    def optimize_for_noise(self, circuit):\n        \"\"\"Optimize circuit considering noise characteristics.\"\"\"\n        optimized_circuit = circuit.copy()\n\n        # Replace gates with higher-fidelity equivalents\n        optimized_circuit = self._replace_low_fidelity_gates(optimized_circuit)\n\n        # Minimize two-qubit gates\n        optimized_circuit = self._minimize_two_qubit_gates(optimized_circuit)\n\n        # Add error correction if beneficial\n        optimized_circuit = self._add_error_correction(optimized_circuit)\n\n        return optimized_circuit\n\n    def _replace_low_fidelity_gates(self, circuit):\n        \"\"\"Replace gates with higher-fidelity alternatives.\"\"\"\n        new_gates = []\n\n        for gate_name, qubits, params in circuit.gates:\n            if gate_name == 'Y':\n                # Replace Y with Z-RX-Z sequence (higher fidelity)\n                new_gates.extend([\n                    ('Z', qubits, []),\n                    ('RX', qubits, [np.pi]),\n                    ('Z', qubits, [])\n                ])\n            elif gate_name == 'CNOT' and len(qubits) == 2:\n                # Check if CZ is available and has higher fidelity\n                if self.gate_fidelities.get('CZ', 0) &gt; self.gate_fidelities.get('CNOT', 0):\n                    # Convert CNOT to CZ + single-qubit gates\n                    control, target = qubits\n                    new_gates.extend([\n                        ('H', [target], []),\n                        ('CZ', qubits, []),\n                        ('H', [target], [])\n                    ])\n                else:\n                    new_gates.append((gate_name, qubits, params))\n            else:\n                new_gates.append((gate_name, qubits, params))\n\n        circuit.gates = new_gates\n        return circuit\n\n    def _minimize_two_qubit_gates(self, circuit):\n        \"\"\"Minimize the number of two-qubit gates.\"\"\"\n        # Count current two-qubit gates\n        two_qubit_count = sum(1 for gate_name, qubits, _ in circuit.gates \n                             if len(qubits) == 2)\n\n        if two_qubit_count &lt;= 5:  # Already minimal\n            return circuit\n\n        # Apply more aggressive single-qubit optimizations\n        optimized = circuit.copy()\n\n        # Try to decompose multi-qubit gates differently\n        optimized = self._decompose_for_minimal_cnots(optimized)\n\n        return optimized\n\n    def _add_error_correction(self, circuit):\n        \"\"\"Add error correction if circuit is long enough to benefit.\"\"\"\n        circuit_depth = circuit.depth()\n\n        if circuit_depth &gt; 100:  # Only for deep circuits\n            # Add simple repetition code\n            return self._add_repetition_code(circuit)\n\n        return circuit\n\n    def estimate_circuit_fidelity(self, circuit):\n        \"\"\"Estimate overall circuit fidelity under noise.\"\"\"\n        total_fidelity = 1.0\n\n        for gate_name, qubits, params in circuit.gates:\n            gate_fidelity = self.gate_fidelities.get(gate_name, 0.95)\n            total_fidelity *= gate_fidelity\n\n        # Account for decoherence time\n        circuit_time = self._estimate_circuit_time(circuit)\n        decoherence_factor = np.exp(-circuit_time / self.noise_model.t1_time)\n\n        return total_fidelity * decoherence_factor\n\n# Noise-aware optimization example\nfrom probabilistic_quantum_reasoner.noise import DepolarizingNoise\n\nnoise_model = DepolarizingNoise(probability=0.01)\nnoise_optimizer = NoiseAwareOptimizer(noise_model)\n\n# Optimize for noise\nnoisy_circuit = create_test_circuit()\noptimized_for_noise = noise_optimizer.optimize_for_noise(noisy_circuit)\n\noriginal_fidelity = noise_optimizer.estimate_circuit_fidelity(noisy_circuit)\noptimized_fidelity = noise_optimizer.estimate_circuit_fidelity(optimized_for_noise)\n\nprint(f\"Original fidelity: {original_fidelity:.4f}\")\nprint(f\"Optimized fidelity: {optimized_fidelity:.4f}\")\nprint(f\"Improvement: {(optimized_fidelity/original_fidelity - 1)*100:.1f}%\")\n</code></pre>"},{"location":"advanced/optimization/#classical-inference-optimization","title":"Classical Inference Optimization","text":""},{"location":"advanced/optimization/#sparse-matrix-operations","title":"Sparse Matrix Operations","text":"<pre><code>import scipy.sparse as sp\nfrom scipy.sparse.linalg import spsolve\n\nclass SparseInferenceEngine:\n    \"\"\"Inference engine optimized for sparse networks.\"\"\"\n\n    def __init__(self, sparsity_threshold=0.1):\n        self.sparsity_threshold = sparsity_threshold\n        self.sparse_cache = {}\n\n    def optimize_network_for_sparsity(self, network):\n        \"\"\"Convert network to sparse representation.\"\"\"\n\n        for node_name, node in network.nodes.items():\n            if hasattr(node, 'cpt'):\n                # Convert CPT to sparse if beneficial\n                cpt = node.cpt\n                sparsity = np.count_nonzero(cpt) / cpt.size\n\n                if sparsity &lt; self.sparsity_threshold:\n                    node.cpt = sp.csr_matrix(cpt)\n                    print(f\"Converted {node_name} CPT to sparse (sparsity: {sparsity:.3f})\")\n\n        return network\n\n    def sparse_variable_elimination(self, network, query_vars, evidence):\n        \"\"\"Perform variable elimination using sparse operations.\"\"\"\n\n        # Convert factors to sparse matrices\n        sparse_factors = self._convert_factors_to_sparse(network, evidence)\n\n        # Determine elimination order\n        elimination_order = self._compute_elimination_order(network, query_vars)\n\n        # Eliminate variables one by one\n        for var in elimination_order:\n            if var not in query_vars:\n                sparse_factors = self._eliminate_variable_sparse(sparse_factors, var)\n\n        # Compute final marginals\n        return self._compute_marginals_sparse(sparse_factors, query_vars)\n\n    def _convert_factors_to_sparse(self, network, evidence):\n        \"\"\"Convert network factors to sparse representation.\"\"\"\n        factors = []\n\n        for node_name, node in network.nodes.items():\n            if hasattr(node, 'cpt'):\n                factor = node.cpt\n\n                # Apply evidence\n                if node_name in evidence:\n                    factor = self._apply_evidence_to_factor(factor, evidence[node_name])\n\n                # Convert to sparse if not already\n                if not sp.issparse(factor):\n                    factor = sp.csr_matrix(factor)\n\n                factors.append({\n                    'factor': factor,\n                    'variables': [node_name] + [p.name for p in node.parents],\n                    'name': node_name\n                })\n\n        return factors\n\n    def _eliminate_variable_sparse(self, factors, var):\n        \"\"\"Eliminate a variable using sparse operations.\"\"\"\n        # Find factors involving the variable\n        relevant_factors = [f for f in factors if var in f['variables']]\n        other_factors = [f for f in factors if var not in f['variables']]\n\n        if not relevant_factors:\n            return factors\n\n        # Multiply relevant factors\n        product_factor = relevant_factors[0]['factor']\n        product_variables = relevant_factors[0]['variables']\n\n        for factor_info in relevant_factors[1:]:\n            product_factor = self._multiply_sparse_factors(\n                product_factor, factor_info['factor']\n            )\n            product_variables = list(set(product_variables + factor_info['variables']))\n\n        # Sum out the variable\n        marginalized_factor = self._marginalize_sparse(product_factor, var, product_variables)\n        marginalized_variables = [v for v in product_variables if v != var]\n\n        # Add marginalized factor to other factors\n        other_factors.append({\n            'factor': marginalized_factor,\n            'variables': marginalized_variables,\n            'name': f'marginalized_{var}'\n        })\n\n        return other_factors\n\n    def _multiply_sparse_factors(self, factor1, factor2):\n        \"\"\"Multiply two sparse factors.\"\"\"\n        # This is a simplified implementation\n        # Real implementation would handle arbitrary tensor operations\n\n        if factor1.shape == factor2.shape:\n            return factor1.multiply(factor2)\n        else:\n            # Handle different shapes through broadcasting\n            return sp.kron(factor1, factor2)\n\n    def _marginalize_sparse(self, factor, var, variables):\n        \"\"\"Marginalize out a variable from sparse factor.\"\"\"\n        # Simplified marginalization for sparse matrices\n        # Real implementation would handle arbitrary tensor marginalization\n\n        var_index = variables.index(var)\n\n        if factor.ndim == 2 and var_index == 0:\n            return sp.csr_matrix(factor.sum(axis=0))\n        elif factor.ndim == 2 and var_index == 1:\n            return sp.csr_matrix(factor.sum(axis=1))\n        else:\n            # For higher dimensions, convert to dense temporarily\n            dense_factor = factor.toarray()\n            marginalized = np.sum(dense_factor, axis=var_index)\n            return sp.csr_matrix(marginalized)\n\n# Sparse optimization example\nsparse_engine = SparseInferenceEngine(sparsity_threshold=0.15)\n\n# Optimize network for sparsity\nsparse_network = sparse_engine.optimize_network_for_sparsity(large_network)\n\n# Perform sparse inference\nstart_time = time.time()\nsparse_result = sparse_engine.sparse_variable_elimination(\n    sparse_network, \n    query_vars=[\"target\"],\n    evidence={\"obs1\": \"value1\"}\n)\nsparse_time = time.time() - start_time\n\nprint(f\"Sparse inference time: {sparse_time:.3f}s\")\n</code></pre>"},{"location":"advanced/optimization/#parallel-classical-inference","title":"Parallel Classical Inference","text":"<pre><code>import concurrent.futures\nimport multiprocessing as mp\nfrom functools import partial\n\nclass ParallelInferenceEngine:\n    \"\"\"Parallel inference engine for classical networks.\"\"\"\n\n    def __init__(self, num_workers=None):\n        self.num_workers = num_workers or mp.cpu_count()\n        self.chunk_size = 1000  # For batch operations\n\n    def parallel_variable_elimination(self, network, queries, evidences):\n        \"\"\"Perform variable elimination in parallel for multiple queries.\"\"\"\n\n        # Create worker function\n        worker_func = partial(self._single_inference_worker, network)\n\n        # Execute in parallel\n        with concurrent.futures.ProcessPoolExecutor(max_workers=self.num_workers) as executor:\n            futures = [\n                executor.submit(worker_func, query, evidence)\n                for query, evidence in zip(queries, evidences)\n            ]\n\n            results = []\n            for future in concurrent.futures.as_completed(futures):\n                results.append(future.result())\n\n        return results\n\n    def _single_inference_worker(self, network, query, evidence):\n        \"\"\"Worker function for single inference task.\"\"\"\n        from probabilistic_quantum_reasoner.inference import BeliefPropagation\n\n        bp = BeliefPropagation()\n        return bp.infer(network, query, evidence)\n\n    def parallel_factor_multiplication(self, factors_list):\n        \"\"\"Multiply factors in parallel.\"\"\"\n\n        if len(factors_list) &lt;= 2:\n            return self._multiply_factors_sequential(factors_list)\n\n        # Divide factors into chunks\n        chunk_size = max(2, len(factors_list) // self.num_workers)\n        chunks = [factors_list[i:i+chunk_size] \n                 for i in range(0, len(factors_list), chunk_size)]\n\n        # Multiply within chunks in parallel\n        with concurrent.futures.ThreadPoolExecutor(max_workers=self.num_workers) as executor:\n            futures = [\n                executor.submit(self._multiply_factors_sequential, chunk)\n                for chunk in chunks\n            ]\n\n            chunk_results = [future.result() for future in futures]\n\n        # Multiply chunk results sequentially\n        return self._multiply_factors_sequential(chunk_results)\n\n    def _multiply_factors_sequential(self, factors):\n        \"\"\"Multiply a list of factors sequentially.\"\"\"\n        if not factors:\n            return None\n\n        result = factors[0]\n        for factor in factors[1:]:\n            result = np.multiply(result, factor)\n\n        return result\n\n    def parallel_sampling(self, network, num_samples, batch_size=None):\n        \"\"\"Generate samples in parallel.\"\"\"\n\n        if batch_size is None:\n            batch_size = max(1, num_samples // self.num_workers)\n\n        # Create batches\n        batches = []\n        remaining = num_samples\n        while remaining &gt; 0:\n            current_batch = min(batch_size, remaining)\n            batches.append(current_batch)\n            remaining -= current_batch\n\n        # Generate samples in parallel\n        with concurrent.futures.ProcessPoolExecutor(max_workers=self.num_workers) as executor:\n            futures = [\n                executor.submit(self._generate_samples_batch, network, batch_size)\n                for batch_size in batches\n            ]\n\n            all_samples = []\n            for future in futures:\n                all_samples.extend(future.result())\n\n        return all_samples\n\n    def _generate_samples_batch(self, network, num_samples):\n        \"\"\"Generate a batch of samples.\"\"\"\n        samples = []\n\n        for _ in range(num_samples):\n            sample = {}\n\n            # Topological sampling\n            for node_name in self._topological_sort(network):\n                node = network.nodes[node_name]\n\n                if hasattr(node, 'sample'):\n                    # Sample from node distribution\n                    value = node.sample(evidence=sample)\n                    sample[node_name] = value\n                else:\n                    # Default sampling\n                    if hasattr(node, 'states'):\n                        value = np.random.choice(node.states)\n                        sample[node_name] = value\n\n            samples.append(sample)\n\n        return samples\n\n    def _topological_sort(self, network):\n        \"\"\"Topological sort of network nodes.\"\"\"\n        # Simplified topological sort\n        sorted_nodes = []\n        in_degree = {name: 0 for name in network.nodes}\n\n        # Compute in-degrees\n        for node_name, node in network.nodes.items():\n            if hasattr(node, 'parents'):\n                in_degree[node_name] = len(node.parents)\n\n        # Find nodes with no incoming edges\n        queue = [name for name, degree in in_degree.items() if degree == 0]\n\n        while queue:\n            current = queue.pop(0)\n            sorted_nodes.append(current)\n\n            # Update in-degrees\n            current_node = network.nodes[current]\n            if hasattr(current_node, 'children'):\n                for child in current_node.children:\n                    in_degree[child.name] -= 1\n                    if in_degree[child.name] == 0:\n                        queue.append(child.name)\n\n        return sorted_nodes\n\n# Parallel inference example\nparallel_engine = ParallelInferenceEngine(num_workers=4)\n\n# Multiple queries in parallel\nqueries = [[\"node1\"], [\"node2\"], [\"node3\"]]\nevidences = [{}, {\"obs\": \"val1\"}, {\"obs\": \"val2\"}]\n\nparallel_results = parallel_engine.parallel_variable_elimination(\n    network, queries, evidences\n)\n\nprint(f\"Processed {len(queries)} queries in parallel\")\n\n# Parallel sampling\nsamples = parallel_engine.parallel_sampling(network, num_samples=10000)\nprint(f\"Generated {len(samples)} samples in parallel\")\n</code></pre>"},{"location":"advanced/optimization/#hardware-specific-optimizations","title":"Hardware-Specific Optimizations","text":""},{"location":"advanced/optimization/#gpu-acceleration","title":"GPU Acceleration","text":"<pre><code>import cupy as cp\nimport numpy as np\n\nclass GPUOptimizedReasoner:\n    \"\"\"GPU-optimized quantum reasoner.\"\"\"\n\n    def __init__(self, device_id=0):\n        cp.cuda.Device(device_id).use()\n        self.device_id = device_id\n        self.stream = cp.cuda.Stream()\n\n    def gpu_accelerated_inference(self, network, query, evidence):\n        \"\"\"Perform inference using GPU acceleration.\"\"\"\n\n        with self.stream:\n            # Convert network to GPU arrays\n            gpu_factors = self._network_to_gpu(network)\n\n            # Apply evidence on GPU\n            gpu_factors = self._apply_evidence_gpu(gpu_factors, evidence)\n\n            # Perform inference on GPU\n            result = self._infer_on_gpu(gpu_factors, query)\n\n            # Transfer result back to CPU\n            cpu_result = cp.asnumpy(result)\n\n        return cpu_result\n\n    def _network_to_gpu(self, network):\n        \"\"\"Transfer network to GPU memory.\"\"\"\n        gpu_factors = []\n\n        for node_name, node in network.nodes.items():\n            if hasattr(node, 'cpt'):\n                gpu_cpt = cp.asarray(node.cpt)\n                gpu_factors.append({\n                    'name': node_name,\n                    'cpt': gpu_cpt,\n                    'variables': [node_name] + [p.name for p in node.parents]\n                })\n\n        return gpu_factors\n\n    def batch_quantum_simulation(self, circuits, shots_per_circuit):\n        \"\"\"Simulate multiple quantum circuits in parallel on GPU.\"\"\"\n\n        # Batch state vector computations\n        batch_states = []\n\n        for circuit in circuits:\n            state = self._compute_state_vector_gpu(circuit)\n            batch_states.append(state)\n\n        # Stack states for batch processing\n        batch_tensor = cp.stack(batch_states)\n\n        # Batch measurement simulation\n        results = self._batch_measure_gpu(batch_tensor, shots_per_circuit)\n\n        return results\n\n    def _compute_state_vector_gpu(self, circuit):\n        \"\"\"Compute state vector on GPU.\"\"\"\n        num_qubits = circuit.num_qubits\n        state = cp.zeros(2**num_qubits, dtype=cp.complex128)\n        state[0] = 1.0  # |00...0\u27e9\n\n        # Apply gates using GPU operations\n        for gate_name, qubits, params in circuit.gates:\n            gate_matrix = self._get_gate_matrix_gpu(gate_name, params)\n            state = self._apply_gate_gpu(state, gate_matrix, qubits, num_qubits)\n\n        return state\n\n    def _apply_gate_gpu(self, state, gate_matrix, qubits, num_qubits):\n        \"\"\"Apply quantum gate on GPU.\"\"\"\n        # This is a simplified implementation\n        # Real implementation would use tensor contractions\n\n        if len(qubits) == 1:\n            # Single-qubit gate\n            full_matrix = self._construct_full_matrix_gpu(gate_matrix, qubits[0], num_qubits)\n            return full_matrix @ state\n        else:\n            # Multi-qubit gate (simplified)\n            return gate_matrix @ state  # Placeholder\n\n    def _batch_measure_gpu(self, batch_states, shots_per_circuit):\n        \"\"\"Perform batch measurements on GPU.\"\"\"\n        batch_results = []\n\n        for i, state in enumerate(batch_states):\n            # Compute probabilities\n            probabilities = cp.abs(state) ** 2\n\n            # Sample on GPU\n            samples = cp.random.choice(\n                len(probabilities), \n                size=shots_per_circuit[i],\n                p=probabilities\n            )\n\n            # Convert to measurement outcomes\n            outcomes = {}\n            for sample in samples:\n                bitstring = format(int(sample), f'0{int(cp.log2(len(state)))}b')\n                outcomes[bitstring] = outcomes.get(bitstring, 0) + 1\n\n            batch_results.append(outcomes)\n\n        return batch_results\n\n# GPU optimization example\ngpu_reasoner = GPUOptimizedReasoner(device_id=0)\n\n# Batch circuit simulation\ntest_circuits = [create_test_circuit(i) for i in range(10)]\nshots_list = [1000] * 10\n\ngpu_results = gpu_reasoner.batch_quantum_simulation(test_circuits, shots_list)\nprint(f\"Simulated {len(test_circuits)} circuits on GPU\")\n</code></pre>"},{"location":"advanced/optimization/#fpga-acceleration","title":"FPGA Acceleration","text":"<pre><code>class FPGAAcceleratedBackend:\n    \"\"\"FPGA-accelerated backend for specific operations.\"\"\"\n\n    def __init__(self, fpga_device=\"/dev/fpga0\"):\n        self.fpga_device = fpga_device\n        self.fpga_available = self._check_fpga_availability()\n\n    def _check_fpga_availability(self):\n        \"\"\"Check if FPGA device is available.\"\"\"\n        try:\n            import os\n            return os.path.exists(self.fpga_device)\n        except:\n            return False\n\n    def fpga_accelerated_matrix_multiplication(self, matrices):\n        \"\"\"Perform matrix multiplication on FPGA.\"\"\"\n\n        if not self.fpga_available:\n            # Fallback to CPU\n            return self._cpu_matrix_multiplication(matrices)\n\n        # FPGA-specific implementation\n        return self._fpga_multiply_matrices(matrices)\n\n    def _fpga_multiply_matrices(self, matrices):\n        \"\"\"FPGA matrix multiplication implementation.\"\"\"\n        # This would interface with actual FPGA hardware\n        # Using placeholder implementation\n\n        result = matrices[0]\n        for matrix in matrices[1:]:\n            # Simulate FPGA operation with optimized CPU code\n            result = np.dot(result, matrix)\n\n        return result\n\n    def fpga_quantum_simulation(self, circuit):\n        \"\"\"Simulate quantum circuit on FPGA.\"\"\"\n\n        if not self.fpga_available:\n            return None\n\n        # FPGA-specific quantum simulation\n        # This would use dedicated quantum simulation cores on FPGA\n        return self._fpga_simulate_circuit(circuit)\n\n# FPGA example\nfpga_backend = FPGAAcceleratedBackend()\n\nif fpga_backend.fpga_available:\n    print(\"FPGA acceleration available\")\nelse:\n    print(\"FPGA not available, using CPU fallback\")\n</code></pre>"},{"location":"advanced/optimization/#benchmark-results","title":"Benchmark Results","text":""},{"location":"advanced/optimization/#performance-comparison","title":"Performance Comparison","text":"<pre><code>def comprehensive_benchmark():\n    \"\"\"Comprehensive performance benchmark.\"\"\"\n\n    # Test configurations\n    configurations = [\n        {\"backend\": \"classical\", \"optimization\": \"none\"},\n        {\"backend\": \"classical\", \"optimization\": \"sparse\"},\n        {\"backend\": \"classical\", \"optimization\": \"parallel\"},\n        {\"backend\": \"qiskit\", \"optimization\": \"none\"},\n        {\"backend\": \"qiskit\", \"optimization\": \"circuit_opt\"},\n        {\"backend\": \"gpu_classical\", \"optimization\": \"gpu\"},\n    ]\n\n    # Test networks of different sizes\n    network_sizes = [10, 25, 50, 100]\n\n    results = {}\n\n    for config in configurations:\n        config_name = f\"{config['backend']}_{config['optimization']}\"\n        results[config_name] = {}\n\n        for size in network_sizes:\n            print(f\"Benchmarking {config_name} with {size} nodes...\")\n\n            # Create test network\n            network = create_test_network(size)\n\n            # Setup reasoner with configuration\n            reasoner = setup_reasoner(config)\n\n            # Benchmark inference\n            times = []\n            for _ in range(10):  # 10 trials\n                start_time = time.time()\n                result = reasoner.infer(\n                    network=network,\n                    query=list(network.nodes.keys())[:3],\n                    evidence={}\n                )\n                end_time = time.time()\n                times.append(end_time - start_time)\n\n            results[config_name][size] = {\n                'mean_time': np.mean(times),\n                'std_time': np.std(times),\n                'min_time': np.min(times)\n            }\n\n    return results\n\n# Run comprehensive benchmark\nbenchmark_results = comprehensive_benchmark()\n\n# Display results\nprint(\"\\nBenchmark Results:\")\nprint(\"=\"*50)\n\nfor config, size_results in benchmark_results.items():\n    print(f\"\\n{config}:\")\n    for size, metrics in size_results.items():\n        print(f\"  {size} nodes: {metrics['mean_time']:.3f}s \u00b1 {metrics['std_time']:.3f}s\")\n</code></pre>"},{"location":"advanced/optimization/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"advanced/optimization/#performance-optimization-guidelines","title":"Performance Optimization Guidelines","text":"<ol> <li>Profile First: Always profile before optimizing</li> <li>Start with Algorithms: Algorithmic improvements usually beat micro-optimizations</li> <li>Use Appropriate Data Structures: Sparse vs dense, GPU vs CPU arrays</li> <li>Cache Wisely: Cache expensive computations but manage memory</li> <li>Parallelize When Possible: Use all available cores and accelerators</li> <li>Optimize for Your Use Case: Different applications need different optimizations</li> </ol>"},{"location":"advanced/optimization/#memory-management","title":"Memory Management","text":"<ol> <li>Monitor Memory Usage: Track memory consumption during inference</li> <li>Use Weak References: Prevent memory leaks in large networks</li> <li>Clear Caches Regularly: Implement cache eviction policies</li> <li>Optimize Data Types: Use appropriate precision (float32 vs float64)</li> </ol>"},{"location":"advanced/optimization/#hardware-utilization","title":"Hardware Utilization","text":"<ol> <li>Match Backend to Hardware: Use GPU backends for GPU systems</li> <li>Batch Operations: Process multiple items together when possible</li> <li>Minimize Data Transfer: Keep data on accelerators when possible</li> <li>Use Vendor Optimizations: Leverage hardware-specific libraries</li> </ol> <p>This comprehensive guide provides the foundation for optimizing PQR performance across different hardware platforms and use cases.</p>"},{"location":"api/backends/","title":"\ud83d\udd0c API Reference: Backends","text":"<p>This section documents the backend interfaces \u2014 both classical and quantum \u2014 that power simulation, execution, and quantum-classical hybrid computation in the Probabilistic Quantum Reasoner.</p>"},{"location":"api/backends/#backend-base-classes","title":"\ud83e\udde0 Backend Base Classes","text":""},{"location":"api/backends/#abstract-backend-interface","title":"Abstract Backend Interface","text":""},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.Backend","title":"<code>probabilistic_quantum_reasoner.backends.simulator.Backend</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for quantum backends.</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.Backend.compute_expectation","title":"<code>compute_expectation(circuit, observable)</code>  <code>abstractmethod</code>","text":"<p>Compute expectation value of observable.</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.Backend.execute_circuit","title":"<code>execute_circuit(circuit, shots=1024)</code>  <code>abstractmethod</code>","text":"<p>Execute quantum circuit and return measurement counts.</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.Backend.get_statevector","title":"<code>get_statevector(circuit)</code>  <code>abstractmethod</code>","text":"<p>Get the state vector from a quantum circuit.</p>"},{"location":"api/backends/#classical-simulator-backend","title":"Classical Simulator Backend","text":""},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.ClassicalSimulator","title":"<code>probabilistic_quantum_reasoner.backends.simulator.ClassicalSimulator(max_qubits=20, noise_model=None)</code>","text":"<p>               Bases: <code>Backend</code></p> <p>Classical simulation backend for quantum operations.</p> <p>Provides quantum circuit simulation using classical linear algebra operations. Suitable for small to medium-sized quantum circuits.</p> <p>Initialize classical simulator.</p> <p>Parameters:</p> Name Type Description Default <code>max_qubits</code> <code>int</code> <p>Maximum number of qubits to simulate</p> <code>20</code> <code>noise_model</code> <code>Optional[Any]</code> <p>Optional noise model for realistic simulation</p> <code>None</code>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.ClassicalSimulator.apply_unitary","title":"<code>apply_unitary(unitary, qubits)</code>","text":"<p>Apply unitary operation to specified qubits.</p> <p>Parameters:</p> Name Type Description Default <code>unitary</code> <code>ndarray</code> <p>Unitary matrix</p> required <code>qubits</code> <code>List[int]</code> <p>List of qubit indices to apply operation to</p> required"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.ClassicalSimulator.compute_expectation_value","title":"<code>compute_expectation_value(observable)</code>","text":"<p>Compute expectation value of observable.</p> <p>Parameters:</p> Name Type Description Default <code>observable</code> <code>ndarray</code> <p>Observable operator matrix</p> required <p>Returns:</p> Type Description <code>float</code> <p>Expectation value \u27e8\u03c8|O|\u03c8\u27e9</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.ClassicalSimulator.execute_circuit","title":"<code>execute_circuit(circuit, shots=1024)</code>","text":"<p>Execute a quantum circuit (simplified interface).</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.ClassicalSimulator.get_backend_info","title":"<code>get_backend_info()</code>","text":"<p>Get backend information and statistics.</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.ClassicalSimulator.get_probabilities","title":"<code>get_probabilities(qubits=None)</code>","text":"<p>Get measurement probabilities for specified qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>Optional[List[int]]</code> <p>Qubits to get probabilities for (all if None)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, float]</code> <p>Dictionary mapping measurement outcomes to probabilities</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.ClassicalSimulator.get_statevector","title":"<code>get_statevector()</code>","text":"<p>Get current quantum state vector.</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.ClassicalSimulator.initialize_state","title":"<code>initialize_state(n_qubits, initial_state=None)</code>","text":"<p>Initialize quantum state.</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>Number of qubits</p> required <code>initial_state</code> <code>Optional[ndarray]</code> <p>Initial state vector (defaults to |0...0\u27e9)</p> <code>None</code>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.ClassicalSimulator.measure","title":"<code>measure(qubits=None, shots=1024)</code>","text":"<p>Perform measurement on specified qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>Optional[List[int]]</code> <p>Qubits to measure (all if None)</p> <code>None</code> <code>shots</code> <code>int</code> <p>Number of measurement shots</p> <code>1024</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dictionary mapping measurement outcomes to counts</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.ClassicalSimulator.reset","title":"<code>reset()</code>","text":"<p>Reset simulator to initial state.</p>"},{"location":"api/backends/#quantum-backends","title":"\u269b\ufe0f Quantum Backends","text":""},{"location":"api/backends/#qiskit-backend","title":"Qiskit Backend","text":""},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend","title":"<code>probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend(backend_name='aer_simulator', use_runtime=False, api_token=None, hub=None, group=None, project=None)</code>","text":"<p>               Bases: <code>Backend</code></p> <p>Qiskit backend for IBM Quantum systems.</p> <p>Provides integration with Qiskit for quantum circuit execution on simulators and real quantum hardware.</p> <p>Initialize Qiskit backend.</p> <p>Parameters:</p> Name Type Description Default <code>backend_name</code> <code>str</code> <p>Name of Qiskit backend to use</p> <code>'aer_simulator'</code> <code>use_runtime</code> <code>bool</code> <p>Whether to use IBM Runtime service</p> <code>False</code> <code>api_token</code> <code>Optional[str]</code> <p>IBM Quantum API token</p> <code>None</code> <code>hub</code> <code>Optional[str]</code> <p>IBM Quantum hub</p> <code>None</code> <code>group</code> <code>Optional[str]</code> <p>IBM Quantum group</p> <code>None</code> <code>project</code> <code>Optional[str]</code> <p>IBM Quantum project</p> <code>None</code>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.add_measurement","title":"<code>add_measurement(circuit, qubits=None)</code>","text":"<p>Add measurement operations to circuit.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>QuantumCircuit</code> <p>Quantum circuit to modify</p> required <code>qubits</code> <code>Optional[List[int]]</code> <p>Qubits to measure (all if None)</p> <code>None</code>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.apply_pauli_gates","title":"<code>apply_pauli_gates(circuit, pauli_string)</code>","text":"<p>Apply Pauli gates according to Pauli string.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>QuantumCircuit</code> <p>Quantum circuit</p> required <code>pauli_string</code> <code>str</code> <p>String of Pauli operators (e.g., \"XYZI\")</p> required"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.apply_unitary_to_circuit","title":"<code>apply_unitary_to_circuit(circuit, unitary, qubits)</code>","text":"<p>Apply unitary operator to quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>QuantumCircuit</code> <p>Quantum circuit to modify</p> required <code>unitary</code> <code>UnitaryOperator</code> <p>Unitary operator to apply</p> required <code>qubits</code> <code>List[int]</code> <p>Target qubits</p> required"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.compute_expectation","title":"<code>compute_expectation(circuit, observable)</code>","text":"<p>Compute expectation value of observable.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>QuantumCircuit</code> <p>Quantum circuit</p> required <code>observable</code> <code>Any</code> <p>Observable operator (SparsePauliOp or matrix)</p> required <p>Returns:</p> Type Description <code>float</code> <p>Expectation value</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.create_bell_state","title":"<code>create_bell_state(qubits)</code>","text":"<p>Create Bell state circuit.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>List[int]</code> <p>Two qubits to entangle</p> required <p>Returns:</p> Type Description <code>QuantumCircuit</code> <p>Quantum circuit creating Bell state</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.create_circuit","title":"<code>create_circuit(n_qubits, n_classical=None)</code>","text":"<p>Create a quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>Number of qubits</p> required <code>n_classical</code> <code>Optional[int]</code> <p>Number of classical bits (defaults to n_qubits)</p> <code>None</code> <p>Returns:</p> Type Description <code>QuantumCircuit</code> <p>QuantumCircuit instance</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.create_ghz_state","title":"<code>create_ghz_state(qubits)</code>","text":"<p>Create GHZ state circuit.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>List[int]</code> <p>Qubits to entangle in GHZ state</p> required <p>Returns:</p> Type Description <code>QuantumCircuit</code> <p>Quantum circuit creating GHZ state</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.create_quantum_state","title":"<code>create_quantum_state(amplitudes, basis_labels)</code>","text":"<p>Create QuantumState from amplitudes.</p> <p>Parameters:</p> Name Type Description Default <code>amplitudes</code> <code>ndarray</code> <p>State amplitudes</p> required <code>basis_labels</code> <code>List[str]</code> <p>Basis state labels</p> required <p>Returns:</p> Type Description <code>QuantumState</code> <p>QuantumState instance</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.estimate_runtime","title":"<code>estimate_runtime(circuit, shots=1024)</code>","text":"<p>Estimate runtime for circuit execution.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>QuantumCircuit</code> <p>Circuit to analyze</p> required <code>shots</code> <code>int</code> <p>Number of shots</p> <code>1024</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Runtime estimation information</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.execute_circuit","title":"<code>execute_circuit(circuit, shots=1024)</code>","text":"<p>Execute quantum circuit and return measurement counts.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>QuantumCircuit</code> <p>Quantum circuit to execute</p> required <code>shots</code> <code>int</code> <p>Number of measurement shots</p> <code>1024</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dictionary mapping measurement outcomes to counts</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.get_backend_properties","title":"<code>get_backend_properties()</code>","text":"<p>Get backend properties and capabilities.</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.get_statevector","title":"<code>get_statevector(circuit)</code>","text":"<p>Get state vector from quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>QuantumCircuit</code> <p>Quantum circuit</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>State vector as numpy array</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.qiskit_backend.QiskitBackend.optimize_circuit","title":"<code>optimize_circuit(circuit, optimization_level=1)</code>","text":"<p>Optimize quantum circuit for the backend.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>QuantumCircuit</code> <p>Circuit to optimize</p> required <code>optimization_level</code> <code>int</code> <p>Optimization level (0-3)</p> <code>1</code> <p>Returns:</p> Type Description <code>QuantumCircuit</code> <p>Optimized circuit</p>"},{"location":"api/backends/#pennylane-backend","title":"PennyLane Backend","text":""},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend","title":"<code>probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend(device_name='default.qubit', n_qubits=4, shots=None, **device_kwargs)</code>","text":"<p>               Bases: <code>Backend</code></p> <p>PennyLane backend for quantum machine learning.</p> <p>Provides integration with PennyLane for variational quantum algorithms, quantum machine learning, and automatic differentiation.</p> <p>Initialize PennyLane backend.</p> <p>Parameters:</p> Name Type Description Default <code>device_name</code> <code>str</code> <p>PennyLane device name</p> <code>'default.qubit'</code> <code>n_qubits</code> <code>int</code> <p>Number of qubits</p> <code>4</code> <code>shots</code> <code>Optional[int]</code> <p>Number of shots (None for exact simulation)</p> <code>None</code> <code>**device_kwargs</code> <p>Additional device arguments</p> <code>{}</code>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.apply_unitary_circuit","title":"<code>apply_unitary_circuit(unitary, qubits, parameters=None)</code>","text":"<p>Create circuit function that applies unitary operator.</p> <p>Parameters:</p> Name Type Description Default <code>unitary</code> <code>UnitaryOperator</code> <p>Unitary operator to apply</p> required <code>qubits</code> <code>List[int]</code> <p>Target qubits</p> required <code>parameters</code> <code>Optional[ndarray]</code> <p>Optional parameters for parametric unitaries</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Circuit function</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.compute_expectation","title":"<code>compute_expectation(circuit_func, observable)</code>","text":"<p>Compute expectation value of observable.</p> <p>Parameters:</p> Name Type Description Default <code>circuit_func</code> <code>Callable</code> <p>Circuit function</p> required <code>observable</code> <code>Any</code> <p>Observable (PennyLane observable or matrix)</p> required <p>Returns:</p> Type Description <code>float</code> <p>Expectation value</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.compute_gradient","title":"<code>compute_gradient(circuit_func, parameters, cost_function=None)</code>","text":"<p>Compute gradient of circuit with respect to parameters.</p> <p>Parameters:</p> Name Type Description Default <code>circuit_func</code> <code>Callable</code> <p>Parametric circuit function</p> required <code>parameters</code> <code>ndarray</code> <p>Circuit parameters</p> required <code>cost_function</code> <code>Optional[Callable]</code> <p>Cost function (defaults to expectation of PauliZ)</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Gradient array</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.create_bell_circuit","title":"<code>create_bell_circuit(qubits)</code>","text":"<p>Create Bell state circuit.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>List[int]</code> <p>Two qubits to entangle</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Bell state circuit function</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.create_ghz_circuit","title":"<code>create_ghz_circuit(qubits)</code>","text":"<p>Create GHZ state circuit.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>List[int]</code> <p>Qubits to entangle</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>GHZ state circuit function</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.create_qnode","title":"<code>create_qnode(circuit_func, name='qnode')</code>","text":"<p>Create a quantum node (QNode) from circuit function.</p> <p>Parameters:</p> Name Type Description Default <code>circuit_func</code> <code>Callable</code> <p>Circuit function</p> required <code>name</code> <code>str</code> <p>Name for the QNode</p> <code>'qnode'</code> <p>Returns:</p> Type Description <code>QNode</code> <p>PennyLane QNode</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.create_quantum_neural_network","title":"<code>create_quantum_neural_network(n_layers=3, input_encoding='angle')</code>","text":"<p>Create quantum neural network circuit.</p> <p>Parameters:</p> Name Type Description Default <code>n_layers</code> <code>int</code> <p>Number of layers</p> <code>3</code> <code>input_encoding</code> <code>str</code> <p>Input encoding method</p> <code>'angle'</code> <p>Returns:</p> Type Description <code>Callable</code> <p>QNN circuit function</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.create_quantum_state","title":"<code>create_quantum_state(amplitudes, basis_labels)</code>","text":"<p>Create QuantumState from amplitudes.</p> <p>Parameters:</p> Name Type Description Default <code>amplitudes</code> <code>ndarray</code> <p>State amplitudes</p> required <code>basis_labels</code> <code>List[str]</code> <p>Basis state labels</p> required <p>Returns:</p> Type Description <code>QuantumState</code> <p>QuantumState instance</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.create_variational_circuit","title":"<code>create_variational_circuit(n_layers=3, template='StronglyEntanglingLayers')</code>","text":"<p>Create variational quantum circuit.</p> <p>Parameters:</p> Name Type Description Default <code>n_layers</code> <code>int</code> <p>Number of variational layers</p> <code>3</code> <code>template</code> <code>str</code> <p>PennyLane template to use</p> <code>'StronglyEntanglingLayers'</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Variational circuit function</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.execute_circuit","title":"<code>execute_circuit(circuit_func, shots=1024)</code>","text":"<p>Execute circuit and return measurement counts.</p> <p>Parameters:</p> Name Type Description Default <code>circuit_func</code> <code>Callable</code> <p>Circuit function to execute</p> required <code>shots</code> <code>int</code> <p>Number of measurement shots</p> <code>1024</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dictionary mapping measurement outcomes to counts</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.get_device_info","title":"<code>get_device_info()</code>","text":"<p>Get device information and capabilities.</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.get_statevector","title":"<code>get_statevector(circuit_func)</code>","text":"<p>Get state vector from circuit.</p> <p>Parameters:</p> Name Type Description Default <code>circuit_func</code> <code>Callable</code> <p>Circuit function</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>State vector as numpy array</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.optimize_circuit","title":"<code>optimize_circuit(circuit_func, initial_params, cost_function, optimizer='AdamOptimizer', max_iterations=100, learning_rate=0.1)</code>","text":"<p>Optimize circuit parameters.</p> <p>Parameters:</p> Name Type Description Default <code>circuit_func</code> <code>Callable</code> <p>Parametric circuit function</p> required <code>initial_params</code> <code>ndarray</code> <p>Initial parameters</p> required <code>cost_function</code> <code>Callable</code> <p>Cost function to minimize</p> required <code>optimizer</code> <code>str</code> <p>Optimizer name</p> <code>'AdamOptimizer'</code> <code>max_iterations</code> <code>int</code> <p>Maximum optimization iterations</p> <code>100</code> <code>learning_rate</code> <code>float</code> <p>Learning rate</p> <code>0.1</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Optimization results</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.prepare_state","title":"<code>prepare_state(target_state)</code>","text":"<p>Create circuit to prepare target quantum state.</p> <p>Parameters:</p> Name Type Description Default <code>target_state</code> <code>ndarray</code> <p>Target state vector</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>State preparation circuit function</p>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.pennylane_backend.PennyLaneBackend.tensor_network_contraction","title":"<code>tensor_network_contraction(tensors)</code>","text":"<p>Perform tensor network contraction (if supported by device).</p> <p>Parameters:</p> Name Type Description Default <code>tensors</code> <code>List[ndarray]</code> <p>List of tensors to contract</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Contracted tensor</p>"},{"location":"api/backends/#noise-modeling","title":"\ud83e\uddea Noise Modeling","text":""},{"location":"api/backends/#noise-model-base-class","title":"Noise Model Base Class","text":""},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.NoiseModel","title":"<code>probabilistic_quantum_reasoner.backends.simulator.NoiseModel(measurement_error=0.01, gate_error=0.001, decoherence_time=None)</code>","text":"<p>Simple noise model for classical simulation.</p> <p>Initialize noise model.</p> <p>Parameters:</p> Name Type Description Default <code>measurement_error</code> <code>float</code> <p>Probability of measurement bit flip</p> <code>0.01</code> <code>gate_error</code> <code>float</code> <p>Probability of gate error</p> <code>0.001</code> <code>decoherence_time</code> <code>Optional[float]</code> <p>T2 decoherence time (microseconds)</p> <code>None</code>"},{"location":"api/backends/#probabilistic_quantum_reasoner.backends.simulator.NoiseModel.apply_gate_noise","title":"<code>apply_gate_noise(state, gate_time=0.1)</code>","text":"<p>Apply gate noise to quantum state.</p>"},{"location":"api/core/","title":"API Reference","text":""},{"location":"api/core/#core-network","title":"\ud83e\udde0 Core Network","text":""},{"location":"api/core/#probabilistic_quantum_reasoner.core.network.QuantumBayesianNetwork","title":"<code>probabilistic_quantum_reasoner.core.network.QuantumBayesianNetwork(name='QuantumBayesianNetwork', backend=None)</code>","text":"<p>A quantum-classical hybrid Bayesian network for probabilistic reasoning.</p> <p>This class implements a graph structure that combines quantum nodes (with amplitudes and superposition) and classical nodes (with probability distributions) to enable sophisticated uncertainty modeling and inference.</p> <p>Initialize a quantum Bayesian network.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name identifier for the network</p> <code>'QuantumBayesianNetwork'</code> <code>backend</code> <code>Optional[Any]</code> <p>Quantum computing backend (Qiskit, PennyLane, etc.)</p> <code>None</code>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.network.QuantumBayesianNetwork.add_quantum_node","title":"<code>add_quantum_node(node_id, outcome_space, name=None, initial_amplitudes=None, **kwargs)</code>","text":"<p>Convenience method to add a quantum node.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.network.QuantumBayesianNetwork.add_stochastic_node","title":"<code>add_stochastic_node(node_id, outcome_space, name=None, prior_probabilities=None, **kwargs)</code>","text":"<p>Convenience method to add a classical stochastic node.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.network.QuantumBayesianNetwork.add_hybrid_node","title":"<code>add_hybrid_node(node_id, outcome_space, name=None, mixing_parameter=0.5, **kwargs)</code>","text":"<p>Convenience method to add a hybrid quantum-classical node.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.network.QuantumBayesianNetwork.add_edge","title":"<code>add_edge(parent_id, child_id, **edge_attrs)</code>","text":"<p>Add a directed edge (causal relationship) between nodes.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>str</code> <p>ID of parent node</p> required <code>child_id</code> <code>str</code> <p>ID of child node</p> required <code>**edge_attrs</code> <p>Additional edge attributes</p> <code>{}</code> <p>Raises:</p> Type Description <code>NetworkTopologyError</code> <p>If nodes don't exist or edge creates cycle</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.network.QuantumBayesianNetwork.entangle","title":"<code>entangle(node_ids)</code>","text":"<p>Create quantum entanglement between specified nodes.</p> <p>Parameters:</p> Name Type Description Default <code>node_ids</code> <code>List[str]</code> <p>List of node IDs to entangle</p> required <p>Raises:</p> Type Description <code>NetworkTopologyError</code> <p>If nodes are not quantum nodes</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.network.QuantumBayesianNetwork.infer","title":"<code>infer(query_nodes=None, evidence=None, algorithm='belief_propagation', **kwargs)</code>","text":"<p>Perform probabilistic inference on the network.</p> <p>Parameters:</p> Name Type Description Default <code>query_nodes</code> <code>Optional[List[str]]</code> <p>Nodes to compute marginals for (all if None)</p> <code>None</code> <code>evidence</code> <code>Optional[Dict[str, Any]]</code> <p>Evidence to condition on</p> <code>None</code> <code>algorithm</code> <code>str</code> <p>Inference algorithm to use</p> <code>'belief_propagation'</code> <code>**kwargs</code> <p>Algorithm-specific parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>InferenceResult</code> <p>InferenceResult with marginal probabilities and metadata</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.network.QuantumBayesianNetwork.intervene","title":"<code>intervene(interventions, query_nodes=None, **kwargs)</code>","text":"<p>Perform causal intervention (do-calculus).</p> <p>Parameters:</p> Name Type Description Default <code>interventions</code> <code>Dict[str, Any]</code> <p>Dictionary of node_id -&gt; intervention_value</p> required <code>query_nodes</code> <code>Optional[List[str]]</code> <p>Nodes to query after intervention</p> <code>None</code> <code>**kwargs</code> <p>Additional parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>InferenceResult</code> <p>InferenceResult after intervention</p>"},{"location":"api/core/#nodes","title":"\ud83e\udde9 Nodes","text":""},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.QuantumNode","title":"<code>probabilistic_quantum_reasoner.core.nodes.QuantumNode(node_id, name, outcome_space, initial_state=None, conditional_operators=None)</code>","text":"<p>               Bases: <code>BaseNode</code></p> <p>Node representing a quantum random variable with amplitude-based states.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.QuantumNode.apply_unitary","title":"<code>apply_unitary(unitary)</code>","text":"<p>Apply unitary transformation to quantum state.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.QuantumNode.entangle_with","title":"<code>entangle_with(other_node_id)</code>","text":"<p>Mark this node as entangled with another.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.QuantumNode.get_amplitude","title":"<code>get_amplitude(outcome)</code>","text":"<p>Get quantum amplitude for specific outcome.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.QuantumNode.is_entangled","title":"<code>is_entangled()</code>","text":"<p>Check if node is entangled with others.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.QuantumNode.log_probability","title":"<code>log_probability(value, parent_values=None)</code>","text":"<p>Compute log probability using Born rule.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.QuantumNode.sample","title":"<code>sample(parent_values=None)</code>","text":"<p>Sample from quantum state by performing measurement.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.QuantumNode.set_amplitude","title":"<code>set_amplitude(outcome, amplitude)</code>","text":"<p>Set quantum amplitude for specific outcome.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.StochasticNode","title":"<code>probabilistic_quantum_reasoner.core.nodes.StochasticNode(node_id, name, outcome_space, cpt=None, prior_distribution=None)</code>","text":"<p>               Bases: <code>BaseNode</code></p> <p>Classical probabilistic node with conditional probability tables.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.StochasticNode.log_probability","title":"<code>log_probability(value, parent_values=None)</code>","text":"<p>Compute log probability from CPT or prior.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.StochasticNode.sample","title":"<code>sample(parent_values=None)</code>","text":"<p>Sample from conditional or prior distribution.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.StochasticNode.update_cpt","title":"<code>update_cpt(cpt)</code>","text":"<p>Update the conditional probability table.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.HybridNode","title":"<code>probabilistic_quantum_reasoner.core.nodes.HybridNode(node_id, name, outcome_space, quantum_component=None, classical_component=None, mixing_parameter=0.5)</code>","text":"<p>               Bases: <code>BaseNode</code></p> <p>Node that combines quantum and classical probabilistic elements.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.HybridNode.get_classical_probability","title":"<code>get_classical_probability(value, parent_values=None)</code>","text":"<p>Get probability from classical component only.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.HybridNode.get_quantum_probability","title":"<code>get_quantum_probability(value, parent_values=None)</code>","text":"<p>Get probability from quantum component only.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.HybridNode.log_probability","title":"<code>log_probability(value, parent_values=None)</code>","text":"<p>Compute mixture log probability.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.HybridNode.sample","title":"<code>sample(parent_values=None)</code>","text":"<p>Sample using mixture of quantum and classical components.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.nodes.HybridNode.update_mixing_parameter","title":"<code>update_mixing_parameter(new_lambda)</code>","text":"<p>Update the quantum-classical mixing parameter.</p>"},{"location":"api/core/#quantum-operators","title":"\u2699\ufe0f Quantum Operators","text":""},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.QuantumOperator","title":"<code>probabilistic_quantum_reasoner.core.operators.QuantumOperator(name, dimension)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for quantum operators.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.QuantumOperator.apply","title":"<code>apply(state)</code>  <code>abstractmethod</code>","text":"<p>Apply the operator to a quantum state.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.QuantumOperator.is_hermitian","title":"<code>is_hermitian()</code>","text":"<p>Check if the operator is Hermitian.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.QuantumOperator.is_unitary","title":"<code>is_unitary()</code>","text":"<p>Check if the operator is unitary.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.QuantumOperator.matrix_representation","title":"<code>matrix_representation()</code>  <code>abstractmethod</code>","text":"<p>Get the matrix representation of the operator.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.UnitaryOperator","title":"<code>probabilistic_quantum_reasoner.core.operators.UnitaryOperator(name, matrix=None, generator=None, angle=0.0)</code>","text":"<p>               Bases: <code>QuantumOperator</code></p> <p>Unitary quantum operator for reversible quantum operations.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.UnitaryOperator.apply","title":"<code>apply(state)</code>","text":"<p>Apply unitary transformation to quantum state.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.UnitaryOperator.inverse","title":"<code>inverse()</code>","text":"<p>Get the inverse (adjoint) of the unitary operator.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.UnitaryOperator.matrix_representation","title":"<code>matrix_representation()</code>","text":"<p>Get the unitary matrix representation.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.MeasurementOperator","title":"<code>probabilistic_quantum_reasoner.core.operators.MeasurementOperator(name, projectors, outcome_labels)</code>","text":"<p>               Bases: <code>QuantumOperator</code></p> <p>Measurement operator for quantum state collapse.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.MeasurementOperator.apply","title":"<code>apply(state)</code>","text":"<p>Apply measurement and return post-measurement state.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.MeasurementOperator.collapse_to_outcome","title":"<code>collapse_to_outcome(state, outcome_idx)</code>","text":"<p>Collapse state to specific measurement outcome.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.MeasurementOperator.matrix_representation","title":"<code>matrix_representation()</code>","text":"<p>Get matrix representation (sum of projectors).</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.MeasurementOperator.measure_probabilities","title":"<code>measure_probabilities(state)</code>","text":"<p>Calculate measurement outcome probabilities.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.ParametricUnitaryOperator","title":"<code>probabilistic_quantum_reasoner.core.operators.ParametricUnitaryOperator(name, parameter_symbols, generator_function, initial_parameters=None)</code>","text":"<p>               Bases: <code>UnitaryOperator</code></p> <p>Parametric unitary operator for variational quantum algorithms.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.ParametricUnitaryOperator.gradient","title":"<code>gradient(parameter_idx, epsilon=1e-08)</code>","text":"<p>Compute parameter gradient using finite differences.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.ParametricUnitaryOperator.update_parameters","title":"<code>update_parameters(new_parameters)</code>","text":"<p>Update the operator parameters.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.PauliOperators","title":"<code>probabilistic_quantum_reasoner.core.operators.PauliOperators</code>","text":"<p>Collection of Pauli operators.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.PauliOperators.X","title":"<code>X()</code>  <code>staticmethod</code>","text":"<p>Pauli-X (NOT) gate.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.PauliOperators.Y","title":"<code>Y()</code>  <code>staticmethod</code>","text":"<p>Pauli-Y gate.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.PauliOperators.Z","title":"<code>Z()</code>  <code>staticmethod</code>","text":"<p>Pauli-Z gate.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.HadamardOperator","title":"<code>probabilistic_quantum_reasoner.core.operators.HadamardOperator()</code>","text":"<p>               Bases: <code>UnitaryOperator</code></p> <p>Hadamard gate for creating superposition.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.CNOTOperator","title":"<code>probabilistic_quantum_reasoner.core.operators.CNOTOperator()</code>","text":"<p>               Bases: <code>UnitaryOperator</code></p> <p>Controlled-NOT gate for creating entanglement.</p>"},{"location":"api/core/#probabilistic_quantum_reasoner.core.operators.ComputationalBasisMeasurement","title":"<code>probabilistic_quantum_reasoner.core.operators.ComputationalBasisMeasurement(dimension)</code>","text":"<p>               Bases: <code>MeasurementOperator</code></p> <p>Standard computational basis measurement.</p>"},{"location":"api/examples/","title":"API Reference: Examples","text":"<p>This section provides detailed API documentation for the example implementations in the Probabilistic Quantum Reasoner.</p>"},{"location":"api/examples/#example-networks","title":"Example Networks","text":""},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.WeatherMoodExample","title":"<code>probabilistic_quantum_reasoner.examples.WeatherMoodExample(backend=None)</code>","text":"<p>Weather-Mood causal relationship example.</p> <p>Models the causal relationship between weather and mood using: - Classical probabilistic dependencies - Quantum entanglement effects - Hybrid reasoning mechanisms</p> <p>Initialize weather-mood example.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Optional[Any]</code> <p>Quantum backend (defaults to classical simulator)</p> <code>None</code>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.WeatherMoodExample.conditional_inference","title":"<code>conditional_inference(evidence)</code>","text":"<p>Run conditional inference given evidence.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.WeatherMoodExample.counterfactual_analysis","title":"<code>counterfactual_analysis()</code>","text":"<p>Perform counterfactual analysis.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.WeatherMoodExample.estimate_causal_effect","title":"<code>estimate_causal_effect(treatment, outcome)</code>","text":"<p>Estimate causal effect of treatment on outcome.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.WeatherMoodExample.generate_report","title":"<code>generate_report()</code>","text":"<p>Generate a human-readable analysis report.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.WeatherMoodExample.quantum_vs_classical_comparison","title":"<code>quantum_vs_classical_comparison()</code>","text":"<p>Compare quantum vs classical reasoning.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.WeatherMoodExample.run_basic_inference","title":"<code>run_basic_inference()</code>","text":"<p>Run basic inference on the network.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.WeatherMoodExample.run_complete_analysis","title":"<code>run_complete_analysis()</code>","text":"<p>Run complete weather-mood analysis.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.WeatherMoodExample.sensitivity_analysis","title":"<code>sensitivity_analysis()</code>","text":"<p>Perform sensitivity analysis on quantum entanglement.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.WeatherMoodExample.temporal_reasoning","title":"<code>temporal_reasoning()</code>","text":"<p>Demonstrate temporal quantum reasoning.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.QuantumXORExample","title":"<code>probabilistic_quantum_reasoner.examples.QuantumXORExample(backend=None)</code>","text":"<p>Quantum XOR gate reasoning example.</p> <p>Demonstrates quantum logical reasoning using: - Quantum superposition of inputs - Entangled XOR relationships - Amplitude interference effects - Quantum vs classical logical inference</p> <p>Initialize quantum XOR example.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Optional[Any]</code> <p>Quantum backend (defaults to classical simulator)</p> <code>None</code>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.QuantumXORExample.demonstrate_interference_effects","title":"<code>demonstrate_interference_effects()</code>","text":"<p>Demonstrate quantum interference in XOR reasoning.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.QuantumXORExample.demonstrate_superposition_xor","title":"<code>demonstrate_superposition_xor()</code>","text":"<p>Demonstrate XOR with superposition inputs.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.QuantumXORExample.generate_xor_report","title":"<code>generate_xor_report()</code>","text":"<p>Generate human-readable XOR analysis report.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.QuantumXORExample.multi_qubit_xor_reasoning","title":"<code>multi_qubit_xor_reasoning(n_inputs=3)</code>","text":"<p>Demonstrate multi-qubit XOR reasoning.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.QuantumXORExample.run_complete_xor_analysis","title":"<code>run_complete_xor_analysis()</code>","text":"<p>Run complete quantum XOR analysis.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.QuantumPrisonersDilemmaExample","title":"<code>probabilistic_quantum_reasoner.examples.QuantumPrisonersDilemmaExample(backend=None)</code>","text":"<p>Quantum Prisoner's Dilemma with counterfactual reasoning.</p> <p>Models strategic decision making using: - Quantum superposition of strategies - Entangled player decisions - Counterfactual strategy analysis - Nash equilibrium under quantum uncertainty</p> <p>Initialize quantum prisoner's dilemma example.</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>Optional[Any]</code> <p>Quantum backend (defaults to classical simulator)</p> <code>None</code>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.QuantumPrisonersDilemmaExample.analyze_quantum_nash_equilibrium","title":"<code>analyze_quantum_nash_equilibrium()</code>","text":"<p>Analyze Nash equilibrium under quantum uncertainty.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.QuantumPrisonersDilemmaExample.counterfactual_strategy_analysis","title":"<code>counterfactual_strategy_analysis()</code>","text":"<p>Perform counterfactual analysis of strategic decisions.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.QuantumPrisonersDilemmaExample.generate_game_report","title":"<code>generate_game_report()</code>","text":"<p>Generate human-readable game analysis report.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.QuantumPrisonersDilemmaExample.run_complete_game_analysis","title":"<code>run_complete_game_analysis()</code>","text":"<p>Run complete quantum game theory analysis.</p>"},{"location":"api/examples/#probabilistic_quantum_reasoner.examples.QuantumPrisonersDilemmaExample.simulate_repeated_game","title":"<code>simulate_repeated_game(n_rounds=10)</code>","text":"<p>Simulate repeated prisoner's dilemma with learning.</p>"},{"location":"api/examples/#example-usage","title":"Example Usage","text":""},{"location":"api/examples/#weather-mood-network","title":"Weather-Mood Network","text":"<pre><code>from probabilistic_quantum_reasoner.examples import WeatherMoodExample\n\nexample = WeatherMoodExample()\nnetwork = example.create_network()\nnetwork.infer(query_nodes=[\"mood\"], evidence={\"weather\": \"sunny\"})\n</code></pre>"},{"location":"api/examples/#quantum-xor-network","title":"Quantum XOR Network","text":"<pre><code>from probabilistic_quantum_reasoner.examples import QuantumXORExample\n\nxor_example = QuantumXORExample()\nnetwork = xor_example.create_network()\nresult = network.infer(query_nodes=[\"output\"])\n</code></pre>"},{"location":"api/examples/#quantum-prisoners-dilemma","title":"Quantum Prisoner's Dilemma","text":"<pre><code>from probabilistic_quantum_reasoner.examples import QuantumPrisonersDilemmaExample\n\nqpd = QuantumPrisonersDilemmaExample()\nanalysis = qpd.run_complete_game_analysis()\nprint(qpd.generate_game_report())\n</code></pre>"},{"location":"api/inference/","title":"\ud83e\udde0 Inference API Reference","text":"<p>This section documents the inference engines and algorithms used for probabilistic reasoning in quantum-classical hybrid networks.</p>"},{"location":"api/inference/#core-inference-engine","title":"\ud83d\udd04 Core Inference Engine","text":""},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.engine.QuantumInferenceEngine","title":"<code>probabilistic_quantum_reasoner.inference.engine.QuantumInferenceEngine(network, backend=None)</code>","text":"<p>Central inference engine for quantum Bayesian networks.</p> <p>Coordinates different inference algorithms and provides a unified interface for probabilistic reasoning in quantum-classical hybrid models.</p> <p>Initialize the inference engine.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>Any</code> <p>QuantumBayesianNetwork instance</p> required <code>backend</code> <code>Optional[Any]</code> <p>Quantum computing backend</p> <code>None</code>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.engine.QuantumInferenceEngine.estimate_complexity","title":"<code>estimate_complexity(algorithm)</code>","text":"<p>Estimate computational complexity for given algorithm.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.engine.QuantumInferenceEngine.infer","title":"<code>infer(query_nodes, algorithm='belief_propagation', **kwargs)</code>","text":"<p>Perform inference on the network.</p> <p>Parameters:</p> Name Type Description Default <code>query_nodes</code> <code>List[str]</code> <p>List of nodes to compute marginals for</p> required <code>algorithm</code> <code>str</code> <p>Inference algorithm to use</p> <code>'belief_propagation'</code> <code>**kwargs</code> <p>Algorithm-specific parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>InferenceResult</code> <p>InferenceResult with marginal probabilities and metadata</p> <p>Raises:</p> Type Description <code>InferenceError</code> <p>If inference fails</p>"},{"location":"api/inference/#variational-inference","title":"\ud83e\udde0 Variational Inference","text":""},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.VariationalQuantumInference","title":"<code>probabilistic_quantum_reasoner.inference.variational.VariationalQuantumInference(network, backend, n_layers=3, optimizer='adam')</code>","text":"<p>Variational quantum inference for quantum Bayesian networks.</p> <p>Uses variational quantum circuits to approximate marginal distributions and perform approximate inference in quantum probabilistic models.</p> <p>Initialize variational quantum inference.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>Any</code> <p>QuantumBayesianNetwork instance</p> required <code>backend</code> <code>Any</code> <p>Quantum computing backend</p> required <code>n_layers</code> <code>int</code> <p>Number of variational layers</p> <code>3</code> <code>optimizer</code> <code>str</code> <p>Classical optimizer for parameters</p> <code>'adam'</code>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.VariationalQuantumInference.run_inference","title":"<code>run_inference(query_nodes, max_iterations=100, learning_rate=0.1, tolerance=1e-06, **kwargs)</code>","text":"<p>Run variational quantum inference.</p> <p>Parameters:</p> Name Type Description Default <code>query_nodes</code> <code>List[str]</code> <p>Nodes to compute marginals for</p> required <code>max_iterations</code> <code>int</code> <p>Maximum optimization iterations</p> <code>100</code> <code>learning_rate</code> <code>float</code> <p>Learning rate for parameter updates</p> <code>0.1</code> <code>tolerance</code> <code>float</code> <p>Convergence tolerance</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>Tuple[Dict[str, Dict[Any, float]], Dict[str, Any]]</code> <p>Tuple of (marginals, metadata)</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.PennyLaneCircuit","title":"<code>probabilistic_quantum_reasoner.inference.variational.PennyLaneCircuit(n_qubits, n_layers=3)</code>","text":"<p>               Bases: <code>ParametricQuantumCircuit</code></p> <p>PennyLane implementation of parametric quantum circuit.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.PennyLaneCircuit.build_circuit","title":"<code>build_circuit(parameters)</code>","text":"<p>Build circuit and return state vector.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.PennyLaneCircuit.expectation_value","title":"<code>expectation_value(parameters, observable)</code>","text":"<p>Compute expectation value.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.QiskitCircuit","title":"<code>probabilistic_quantum_reasoner.inference.variational.QiskitCircuit(n_qubits, n_layers=3)</code>","text":"<p>               Bases: <code>ParametricQuantumCircuit</code></p> <p>Qiskit implementation of parametric quantum circuit.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.QiskitCircuit.build_circuit","title":"<code>build_circuit(parameters)</code>","text":"<p>Build parametric quantum circuit.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.QiskitCircuit.expectation_value","title":"<code>expectation_value(parameters, observable)</code>","text":"<p>Compute expectation value using Qiskit primitives.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.Optimizer","title":"<code>probabilistic_quantum_reasoner.inference.variational.Optimizer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for optimizers.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.Optimizer.update","title":"<code>update(parameters, gradient)</code>  <code>abstractmethod</code>","text":"<p>Update parameters using gradient.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.AdamOptimizer","title":"<code>probabilistic_quantum_reasoner.inference.variational.AdamOptimizer(learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08)</code>","text":"<p>               Bases: <code>Optimizer</code></p> <p>Adam optimizer with momentum and adaptive learning rates.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.AdamOptimizer.update","title":"<code>update(parameters, gradient)</code>","text":"<p>Adam update rule.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.SGDOptimizer","title":"<code>probabilistic_quantum_reasoner.inference.variational.SGDOptimizer(learning_rate=0.1)</code>","text":"<p>               Bases: <code>Optimizer</code></p> <p>Stochastic gradient descent optimizer.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.variational.SGDOptimizer.update","title":"<code>update(parameters, gradient)</code>","text":"<p>SGD update rule.</p>"},{"location":"api/inference/#belief-propagation","title":"\ud83e\udde0 Belief Propagation","text":""},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.belief_propagation.QuantumBeliefPropagation","title":"<code>probabilistic_quantum_reasoner.inference.belief_propagation.QuantumBeliefPropagation(network, max_iterations=100, tolerance=1e-06)</code>","text":"<p>Quantum belief propagation algorithm for inference.</p> <p>Extends classical belief propagation to handle quantum amplitudes, superposition, and entanglement in hybrid probabilistic networks.</p> <p>Initialize quantum belief propagation.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>Any</code> <p>QuantumBayesianNetwork instance</p> required <code>max_iterations</code> <code>int</code> <p>Maximum number of iterations</p> <code>100</code> <code>tolerance</code> <code>float</code> <p>Convergence tolerance</p> <code>1e-06</code>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.belief_propagation.QuantumBeliefPropagation.get_convergence_info","title":"<code>get_convergence_info()</code>","text":"<p>Get information about convergence.</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.belief_propagation.QuantumBeliefPropagation.run_inference","title":"<code>run_inference(query_nodes=None, evidence=None)</code>","text":"<p>Run quantum belief propagation inference.</p> <p>Parameters:</p> Name Type Description Default <code>query_nodes</code> <code>Optional[List[str]]</code> <p>Nodes to compute beliefs for</p> <code>None</code> <code>evidence</code> <code>Optional[Dict[str, Any]]</code> <p>Evidence to condition on</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Dict[Any, float]]</code> <p>Dictionary mapping node IDs to probability distributions</p>"},{"location":"api/inference/#causal-inference","title":"\ud83e\udde0 Causal Inference","text":""},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.causal.QuantumCausalInference","title":"<code>probabilistic_quantum_reasoner.inference.causal.QuantumCausalInference(network, backend=None)</code>","text":"<p>Quantum causal inference engine.</p> <p>Implements quantum analogs of Pearl's causal hierarchy: 1. Association (observation): P(Y|X) 2. Intervention (action): P(Y|do(X)) 3. Counterfactuals: P(Y_x|X',Y')</p> <p>Initialize quantum causal inference engine.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>Any</code> <p>QuantumBayesianNetwork instance</p> required <code>backend</code> <code>Optional[Any]</code> <p>Quantum computing backend</p> <code>None</code>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.causal.QuantumCausalInference.counterfactual_query","title":"<code>counterfactual_query(factual_evidence, counterfactual_interventions, query_nodes, **kwargs)</code>","text":"<p>Perform counterfactual query: P(Y_x | X', Y').</p> <p>Parameters:</p> Name Type Description Default <code>factual_evidence</code> <code>Dict[str, Any]</code> <p>Observed evidence in actual world</p> required <code>counterfactual_interventions</code> <code>Dict[str, Any]</code> <p>Interventions in counterfactual world</p> required <code>query_nodes</code> <code>List[str]</code> <p>Nodes to query in counterfactual world</p> required <p>Returns:</p> Type Description <code>InferenceResult</code> <p>Counterfactual inference result</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.causal.QuantumCausalInference.do_calculus","title":"<code>do_calculus(interventions, query_nodes=None, **kwargs)</code>","text":"<p>Perform quantum do-calculus intervention.</p> <p>Parameters:</p> Name Type Description Default <code>interventions</code> <code>Dict[str, Any]</code> <p>Dictionary of node_id -&gt; intervention_value</p> required <code>query_nodes</code> <code>Optional[List[str]]</code> <p>Nodes to query after intervention</p> <code>None</code> <code>**kwargs</code> <p>Additional parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>InferenceResult</code> <p>InferenceResult after intervention</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.causal.QuantumCausalInference.estimate_causal_effect","title":"<code>estimate_causal_effect(treatment, outcome, confounders=None, **kwargs)</code>","text":"<p>Estimate causal effect of treatment on outcome.</p> <p>Parameters:</p> Name Type Description Default <code>treatment</code> <code>str</code> <p>Treatment variable</p> required <code>outcome</code> <code>str</code> <p>Outcome variable</p> required <code>confounders</code> <code>Optional[List[str]]</code> <p>List of confounding variables</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with causal effect estimates</p>"},{"location":"api/inference/#probabilistic_quantum_reasoner.inference.causal.QuantumCausalInference.is_identifiable","title":"<code>is_identifiable(treatment, outcome)</code>","text":"<p>Check if causal effect is identifiable from observational data.</p>"},{"location":"api/inference/#example-usage","title":"\ud83e\uddea Example Usage","text":""},{"location":"api/inference/#basic-inference","title":"\ud83d\udccc Basic Inference","text":"<p>```python from probabilistic_quantum_reasoner.inference.engine import QuantumInferenceEngine engine = QuantumInferenceEngine(network) result = engine.infer(query_nodes=[\"A\", \"B\"])</p>"},{"location":"architecture/backends/","title":"Quantum Backends","text":"<p>This document describes the quantum backend architecture that enables the Probabilistic Quantum Reasoner to run on different quantum computing platforms.</p>"},{"location":"architecture/backends/#backend-architecture","title":"Backend Architecture","text":"<p>The backend system provides a unified interface for quantum operations across different quantum computing frameworks:</p> <pre><code>graph TD\n    A[QuantumBackend Interface] --&gt; B[ClassicalSimulator]\n    A --&gt; C[QiskitBackend]\n    A --&gt; D[PennyLaneBackend]\n    A --&gt; E[CustomBackend]\n\n    B --&gt; F[NumPy/SciPy]\n    C --&gt; G[IBM Quantum]\n    C --&gt; H[Qiskit Aer]\n    D --&gt; I[PennyLane Devices]\n    D --&gt; J[Various ML Frameworks]</code></pre>"},{"location":"architecture/backends/#backend-interface","title":"Backend Interface","text":"<p>All backends implement the <code>QuantumBackend</code> abstract base class:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Dict, List, Any, Optional\nimport numpy as np\n\nclass QuantumBackend(ABC):\n    \"\"\"Abstract base class for quantum backends.\"\"\"\n\n    @abstractmethod\n    def create_quantum_state(self, amplitudes: np.ndarray) -&gt; Any:\n        \"\"\"Create a quantum state from amplitudes.\"\"\"\n        pass\n\n    @abstractmethod\n    def apply_unitary(self, state: Any, unitary: np.ndarray) -&gt; Any:\n        \"\"\"Apply unitary operator to quantum state.\"\"\"\n        pass\n\n    @abstractmethod\n    def measure_state(self, state: Any, measurement_basis: Optional[np.ndarray] = None) -&gt; Dict[str, Any]:\n        \"\"\"Measure quantum state.\"\"\"\n        pass\n\n    @abstractmethod\n    def compute_expectation(self, state: Any, observable: np.ndarray) -&gt; float:\n        \"\"\"Compute expectation value of observable.\"\"\"\n        pass\n\n    @abstractmethod\n    def tensor_product(self, states: List[Any]) -&gt; Any:\n        \"\"\"Compute tensor product of quantum states.\"\"\"\n        pass\n\n    @abstractmethod\n    def partial_trace(self, state: Any, subsystem: int, dimensions: List[int]) -&gt; Any:\n        \"\"\"Compute partial trace over subsystem.\"\"\"\n        pass\n</code></pre>"},{"location":"architecture/backends/#available-backends","title":"Available Backends","text":""},{"location":"architecture/backends/#classical-simulator","title":"Classical Simulator","text":"<p>Perfect for development, testing, and educational purposes:</p> <pre><code>from probabilistic_quantum_reasoner.backends import ClassicalSimulator\n\nclass ClassicalSimulator(QuantumBackend):\n    \"\"\"Classical simulation of quantum systems.\"\"\"\n\n    def __init__(self, seed: Optional[int] = None):\n        \"\"\"Initialize classical simulator.\n\n        Args:\n            seed: Random seed for reproducible results\n        \"\"\"\n        self.rng = np.random.RandomState(seed)\n\n    def create_quantum_state(self, amplitudes: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Create quantum state as complex amplitude vector.\"\"\"\n        normalized = amplitudes / np.linalg.norm(amplitudes)\n        return normalized.astype(complex)\n\n    def apply_unitary(self, state: np.ndarray, unitary: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Apply unitary matrix multiplication.\"\"\"\n        return unitary @ state\n\n    def measure_state(self, state: np.ndarray, \n                     measurement_basis: Optional[np.ndarray] = None) -&gt; Dict[str, Any]:\n        \"\"\"Simulate quantum measurement via Born rule.\"\"\"\n        probabilities = np.abs(state) ** 2\n        outcome = self.rng.choice(len(state), p=probabilities)\n\n        # Create post-measurement state\n        post_state = np.zeros_like(state)\n        post_state[outcome] = 1.0\n\n        return {\n            \"outcome\": outcome,\n            \"probability\": probabilities[outcome],\n            \"post_measurement_state\": post_state\n        }\n</code></pre> <p>Features:</p> <ul> <li>Perfect quantum simulation (no noise)</li> <li>Efficient for small systems (&lt;20 qubits)</li> <li>Deterministic with optional random seeding</li> <li>Full quantum state access for debugging</li> </ul> <p>Use Cases:</p> <ul> <li>Algorithm development and testing</li> <li>Educational demonstrations</li> <li>Classical limit verification</li> <li>Performance benchmarking</li> </ul>"},{"location":"architecture/backends/#qiskit-backend","title":"Qiskit Backend","text":"<p>Interface to IBM Quantum systems and simulators:</p> <pre><code>from probabilistic_quantum_reasoner.backends import QiskitBackend\n\nclass QiskitBackend(QuantumBackend):\n    \"\"\"Qiskit-based quantum backend.\"\"\"\n\n    def __init__(self, device_name: str = \"aer_simulator\", \n                 shots: int = 1024, optimization_level: int = 1):\n        \"\"\"Initialize Qiskit backend.\n\n        Args:\n            device_name: Qiskit device/simulator name\n            shots: Number of measurement shots\n            optimization_level: Circuit optimization level\n        \"\"\"\n        try:\n            from qiskit import Aer, IBMQ\n            from qiskit.circuit import QuantumCircuit\n            from qiskit.quantum_info import Statevector\n        except ImportError:\n            raise ImportError(\"Qiskit required for QiskitBackend\")\n\n        self.device_name = device_name\n        self.shots = shots\n        self.optimization_level = optimization_level\n        self.backend = Aer.get_backend(device_name)\n\n    def create_quantum_state(self, amplitudes: np.ndarray) -&gt; 'Statevector':\n        \"\"\"Create Qiskit Statevector.\"\"\"\n        from qiskit.quantum_info import Statevector\n        return Statevector(amplitudes)\n\n    def apply_unitary(self, state: 'Statevector', unitary: np.ndarray) -&gt; 'Statevector':\n        \"\"\"Apply unitary using Qiskit.\"\"\"\n        return state.evolve(unitary)\n\n    def measure_state(self, state: 'Statevector', \n                     measurement_basis: Optional[np.ndarray] = None) -&gt; Dict[str, Any]:\n        \"\"\"Perform quantum measurement via circuit execution.\"\"\"\n        from qiskit import QuantumCircuit, execute\n\n        # Create measurement circuit\n        n_qubits = int(np.log2(len(state.data)))\n        qc = QuantumCircuit(n_qubits, n_qubits)\n\n        # Initialize state\n        qc.initialize(state.data, range(n_qubits))\n\n        # Add measurements\n        qc.measure_all()\n\n        # Execute circuit\n        job = execute(qc, self.backend, shots=self.shots)\n        result = job.result()\n        counts = result.get_counts()\n\n        # Process results\n        total_shots = sum(counts.values())\n        outcome_probs = {int(outcome, 2): count/total_shots \n                        for outcome, count in counts.items()}\n\n        # Sample outcome based on measurement statistics\n        outcomes = list(outcome_probs.keys())\n        probabilities = list(outcome_probs.values())\n        sampled_outcome = np.random.choice(outcomes, p=probabilities)\n\n        return {\n            \"outcome\": sampled_outcome,\n            \"probability\": outcome_probs[sampled_outcome],\n            \"measurement_counts\": counts,\n            \"shots\": self.shots\n        }\n</code></pre> <p>Features:</p> <ul> <li>Access to IBM Quantum hardware</li> <li>Realistic noise models</li> <li>Circuit optimization</li> <li>Quantum error correction</li> </ul> <p>Use Cases:</p> <ul> <li>Real quantum hardware experiments</li> <li>Noise-aware algorithm testing</li> <li>Quantum advantage demonstrations</li> <li>Research applications</li> </ul>"},{"location":"architecture/backends/#pennylane-backend","title":"PennyLane Backend","text":"<p>Optimized for variational quantum algorithms and machine learning:</p> <pre><code>from probabilistic_quantum_reasoner.backends import PennyLaneBackend\n\nclass PennyLaneBackend(QuantumBackend):\n    \"\"\"PennyLane-based quantum backend.\"\"\"\n\n    def __init__(self, device_name: str = \"default.qubit\", \n                 shots: Optional[int] = None, **device_kwargs):\n        \"\"\"Initialize PennyLane backend.\n\n        Args:\n            device_name: PennyLane device name\n            shots: Number of shots (None for analytic)\n            **device_kwargs: Additional device arguments\n        \"\"\"\n        try:\n            import pennylane as qml\n        except ImportError:\n            raise ImportError(\"PennyLane required for PennyLaneBackend\")\n\n        self.device_name = device_name\n        self.shots = shots\n        self.device_kwargs = device_kwargs\n\n    def create_quantum_device(self, n_qubits: int):\n        \"\"\"Create PennyLane quantum device.\"\"\"\n        import pennylane as qml\n        return qml.device(self.device_name, wires=n_qubits, \n                         shots=self.shots, **self.device_kwargs)\n\n    def create_variational_circuit(self, n_qubits: int, parameters: np.ndarray):\n        \"\"\"Create parameterized quantum circuit.\"\"\"\n        import pennylane as qml\n\n        dev = self.create_quantum_device(n_qubits)\n\n        @qml.qnode(dev)\n        def circuit(params):\n            # Ansatz: alternating rotation and entanglement layers\n            for i in range(n_qubits):\n                qml.RY(params[i], wires=i)\n\n            for i in range(n_qubits - 1):\n                qml.CNOT(wires=[i, i + 1])\n\n            # Additional parameterized layers\n            layer_size = len(params) // 2\n            for i in range(min(layer_size, n_qubits)):\n                qml.RZ(params[n_qubits + i], wires=i)\n\n            return [qml.probs(wires=i) for i in range(n_qubits)]\n\n        return circuit\n\n    def optimize_variational_circuit(self, circuit, target_distribution: np.ndarray, \n                                   max_iterations: int = 100):\n        \"\"\"Optimize circuit parameters to match target distribution.\"\"\"\n        import pennylane as qml\n\n        # Initialize parameters\n        n_params = circuit.func.__code__.co_argcount - 1  # Exclude self\n        params = np.random.uniform(0, 2*np.pi, n_params)\n\n        # Optimizer\n        optimizer = qml.GradientDescentOptimizer(stepsize=0.1)\n\n        def cost_function(params):\n            probs = circuit(params)\n            # Flatten probability distributions\n            flat_probs = np.concatenate([p for p in probs])\n            flat_target = target_distribution.flatten()\n\n            # KL divergence loss\n            return np.sum(flat_target * np.log(flat_target / (flat_probs + 1e-10)))\n\n        # Optimization loop\n        for iteration in range(max_iterations):\n            params = optimizer.step(cost_function, params)\n\n            if iteration % 20 == 0:\n                loss = cost_function(params)\n                print(f\"Iteration {iteration}: Loss = {loss:.6f}\")\n\n        return params\n</code></pre> <p>Features:</p> <ul> <li>Automatic differentiation</li> <li>Variational algorithm support</li> <li>Multiple backend targets</li> <li>Machine learning integration</li> </ul> <p>Use Cases:</p> <ul> <li>Variational quantum eigensolvers (VQE)</li> <li>Quantum approximate optimization (QAOA)</li> <li>Quantum machine learning</li> <li>Hybrid classical-quantum optimization</li> </ul>"},{"location":"architecture/backends/#backend-selection-guidelines","title":"Backend Selection Guidelines","text":""},{"location":"architecture/backends/#development-phase","title":"Development Phase","text":"<p>Use <code>ClassicalSimulator</code> for:</p> <ul> <li>Algorithm prototyping</li> <li>Unit testing</li> <li>Educational examples</li> <li>Performance benchmarking</li> </ul>"},{"location":"architecture/backends/#research-phase","title":"Research Phase","text":"<p>Use <code>QiskitBackend</code> for:</p> <ul> <li>Hardware validation</li> <li>Noise characterization</li> <li>Quantum advantage studies</li> <li>Publication-quality results</li> </ul>"},{"location":"architecture/backends/#machine-learning","title":"Machine Learning","text":"<p>Use <code>PennyLaneBackend</code> for:</p> <ul> <li>Variational algorithms</li> <li>Parameter optimization</li> <li>Hybrid models</li> <li>Gradient-based learning</li> </ul>"},{"location":"architecture/backends/#configuration-examples","title":"Configuration Examples","text":""},{"location":"architecture/backends/#local-development","title":"Local Development","text":"<pre><code># Classical simulation for development\nfrom probabilistic_quantum_reasoner.backends import ClassicalSimulator\n\nbackend = ClassicalSimulator(seed=42)  # Reproducible results\nnetwork = QuantumBayesianNetwork(\"DevNetwork\", backend)\n</code></pre>"},{"location":"architecture/backends/#ibm-quantum","title":"IBM Quantum","text":"<pre><code># Real quantum hardware\nfrom probabilistic_quantum_reasoner.backends import QiskitBackend\n\nbackend = QiskitBackend(\n    device_name=\"ibmq_qasm_simulator\",  # or real device like \"ibmq_lima\"\n    shots=8192,\n    optimization_level=3\n)\nnetwork = QuantumBayesianNetwork(\"ProductionNetwork\", backend)\n</code></pre>"},{"location":"architecture/backends/#variational-optimization","title":"Variational Optimization","text":"<pre><code># PennyLane for variational algorithms\nfrom probabilistic_quantum_reasoner.backends import PennyLaneBackend\n\nbackend = PennyLaneBackend(\n    device_name=\"default.qubit\",\n    shots=None  # Analytic gradients\n)\nnetwork = QuantumBayesianNetwork(\"VariationalNetwork\", backend)\n</code></pre>"},{"location":"architecture/backends/#performance-comparison","title":"Performance Comparison","text":"Backend Qubits Speed Noise Gradients Hardware Classical ~20 Fast None Finite-diff CPU Qiskit Variable Medium Realistic Finite-diff IBM Quantum PennyLane ~20 Medium Optional Automatic Multiple"},{"location":"architecture/backends/#custom-backends","title":"Custom Backends","text":"<p>You can implement custom backends for specialized hardware:</p> <pre><code>class CustomBackend(QuantumBackend):\n    \"\"\"Custom quantum backend implementation.\"\"\"\n\n    def __init__(self, custom_device):\n        self.device = custom_device\n\n    def create_quantum_state(self, amplitudes: np.ndarray):\n        # Custom state creation logic\n        return self.device.create_state(amplitudes)\n\n    # Implement other required methods...\n</code></pre>"},{"location":"architecture/backends/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Inference Engines</li> <li>Explore User Guide for practical usage</li> <li>See Performance Optimization</li> <li>Check API Reference for detailed documentation</li> </ul>"},{"location":"architecture/core/","title":"Core Components","text":"<p>This document describes the core components of the Probabilistic Quantum Reasoner architecture.</p>"},{"location":"architecture/core/#overview","title":"Overview","text":"<p>The library is built around several key components that work together to enable quantum-classical hybrid reasoning:</p> <pre><code>graph TD\n    A[QuantumBayesianNetwork] --&gt; B[Quantum Nodes]\n    A --&gt; C[Stochastic Nodes] \n    A --&gt; D[Hybrid Nodes]\n    B --&gt; E[Quantum Operators]\n    B --&gt; F[Quantum States]\n    A --&gt; G[Inference Engine]\n    G --&gt; H[Belief Propagation]\n    G --&gt; I[Variational Methods]\n    G --&gt; J[Causal Inference]\n    A --&gt; K[Backend Interface]\n    K --&gt; L[Classical Simulator]\n    K --&gt; M[Qiskit Backend]\n    K --&gt; N[PennyLane Backend]</code></pre>"},{"location":"architecture/core/#core-classes","title":"Core Classes","text":""},{"location":"architecture/core/#quantumbayesiannetwork","title":"QuantumBayesianNetwork","text":"<p>The main orchestrator class that manages the entire network:</p> <pre><code>from probabilistic_quantum_reasoner import QuantumBayesianNetwork\n\nclass QuantumBayesianNetwork:\n    \"\"\"Main quantum Bayesian network class.\"\"\"\n\n    def __init__(self, name: str, backend: QuantumBackend)\n    def add_quantum_node(self, node_id: str, **kwargs) -&gt; QuantumNode\n    def add_stochastic_node(self, node_id: str, **kwargs) -&gt; StochasticNode  \n    def add_hybrid_node(self, node_id: str, **kwargs) -&gt; HybridNode\n    def add_edge(self, parent: Node, child: Node) -&gt; None\n    def entangle(self, nodes: List[QuantumNode]) -&gt; None\n    def infer(self, **kwargs) -&gt; InferenceResult\n    def intervene(self, **kwargs) -&gt; InferenceResult\n    def measure_node(self, node_id: str) -&gt; MeasurementResult\n</code></pre> <p>Key Features:</p> <ul> <li>Graph structure management</li> <li>Node lifecycle management  </li> <li>Edge relationship tracking</li> <li>Quantum entanglement coordination</li> <li>Inference orchestration</li> </ul>"},{"location":"architecture/core/#node-types","title":"Node Types","text":""},{"location":"architecture/core/#quantumnode","title":"QuantumNode","text":"<p>Represents quantum probabilistic variables:</p> <pre><code>class QuantumNode:\n    \"\"\"Quantum node with superposition states.\"\"\"\n\n    def __init__(self, node_id: str, outcome_space: List[Any], \n                 initial_amplitudes: np.ndarray)\n\n    @property\n    def quantum_state(self) -&gt; QuantumState\n    @property \n    def probability_distribution(self) -&gt; Dict[Any, float]\n\n    def apply_operator(self, operator: UnitaryOperator) -&gt; None\n    def measure(self, measurement: MeasurementOperator) -&gt; MeasurementResult\n    def set_amplitudes(self, amplitudes: np.ndarray) -&gt; None\n</code></pre> <p>Properties:</p> <ul> <li>Complex amplitude vectors</li> <li>Quantum superposition support</li> <li>Unitary evolution capability</li> <li>Measurement collapse behavior</li> </ul>"},{"location":"architecture/core/#stochasticnode","title":"StochasticNode","text":"<p>Classical probabilistic nodes:</p> <pre><code>class StochasticNode:\n    \"\"\"Classical stochastic node.\"\"\"\n\n    def __init__(self, node_id: str, outcome_space: List[Any])\n\n    @property\n    def prior_distribution(self) -&gt; np.ndarray\n    @property\n    def conditional_probability_table(self) -&gt; ConditionalProbabilityTable\n\n    def set_evidence(self, value: Any) -&gt; None\n    def sample(self) -&gt; Any\n</code></pre> <p>Properties:</p> <ul> <li>Probability distributions</li> <li>Conditional probability tables</li> <li>Classical sampling</li> <li>Evidence integration</li> </ul>"},{"location":"architecture/core/#hybridnode","title":"HybridNode","text":"<p>Quantum-classical hybrid nodes:</p> <pre><code>class HybridNode:\n    \"\"\"Hybrid quantum-classical node.\"\"\"\n\n    def __init__(self, node_id: str, outcome_space: List[Any],\n                 mixing_parameter: float)\n\n    @property\n    def quantum_component(self) -&gt; QuantumNode\n    @property\n    def classical_component(self) -&gt; StochasticNode\n    @property\n    def mixing_parameter(self) -&gt; float\n\n    def get_hybrid_distribution(self) -&gt; Dict[Any, float]\n</code></pre> <p>Properties:</p> <ul> <li>Weighted quantum-classical mixing</li> <li>Coherent superposition with decoherence</li> <li>Flexible reasoning paradigms</li> <li>Smooth classical limit</li> </ul>"},{"location":"architecture/core/#quantum-state-management","title":"Quantum State Management","text":""},{"location":"architecture/core/#quantumstate","title":"QuantumState","text":"<p>Core quantum state representation:</p> <pre><code>class QuantumState:\n    \"\"\"Quantum state with amplitudes and phase.\"\"\"\n\n    def __init__(self, amplitudes: np.ndarray)\n\n    @property\n    def amplitudes(self) -&gt; np.ndarray\n    @property \n    def probabilities(self) -&gt; np.ndarray\n    @property\n    def dimension(self) -&gt; int\n\n    def normalize(self) -&gt; None\n    def tensor_product(self, other: 'QuantumState') -&gt; 'QuantumState'\n    def partial_trace(self, subsystem: int) -&gt; 'QuantumState'\n    def fidelity(self, other: 'QuantumState') -&gt; float\n</code></pre> <p>Features:</p> <ul> <li>Amplitude normalization</li> <li>Tensor product composition</li> <li>Partial trace for subsystems</li> <li>State fidelity computation</li> </ul>"},{"location":"architecture/core/#quantum-operators","title":"Quantum Operators","text":""},{"location":"architecture/core/#unitaryoperator","title":"UnitaryOperator","text":"<p>Quantum unitary transformations:</p> <pre><code>class UnitaryOperator:\n    \"\"\"Unitary quantum operator.\"\"\"\n\n    def __init__(self, matrix: np.ndarray)\n\n    @property\n    def matrix(self) -&gt; np.ndarray\n    @property\n    def dimension(self) -&gt; int\n\n    def apply(self, state: np.ndarray) -&gt; np.ndarray\n    def dagger(self) -&gt; 'UnitaryOperator'\n    def compose(self, other: 'UnitaryOperator') -&gt; 'UnitaryOperator'\n</code></pre>"},{"location":"architecture/core/#measurementoperator","title":"MeasurementOperator","text":"<p>Quantum measurement processes:</p> <pre><code>class MeasurementOperator:\n    \"\"\"Quantum measurement operator.\"\"\"\n\n    def __init__(self, measurement_basis: List[np.ndarray])\n\n    def measure(self, state: np.ndarray) -&gt; MeasurementResult\n    def expectation_value(self, state: np.ndarray) -&gt; float\n    def variance(self, state: np.ndarray) -&gt; float\n</code></pre>"},{"location":"architecture/core/#conditional-probability-tables","title":"Conditional Probability Tables","text":"<p>Classical conditional dependencies:</p> <pre><code>class ConditionalProbabilityTable:\n    \"\"\"Conditional probability table for classical nodes.\"\"\"\n\n    def __init__(self, child_outcomes: List[Any], \n                 parent_outcomes: List[List[Any]])\n\n    def set_probability(self, child_value: Any, parent_values: Tuple,\n                       probability: float) -&gt; None\n    def get_probability(self, child_value: Any, \n                       parent_values: Tuple) -&gt; float\n    def get_distribution(self, parent_values: Tuple) -&gt; Dict[Any, float]\n    def normalize(self) -&gt; None\n</code></pre>"},{"location":"architecture/core/#data-flow","title":"Data Flow","text":""},{"location":"architecture/core/#inference-pipeline","title":"Inference Pipeline","text":"<ol> <li>State Preparation: Initialize quantum and classical nodes</li> <li>Message Passing: Propagate information through network</li> <li>Quantum Evolution: Apply unitary operators and entanglement</li> <li>Measurement: Collapse quantum states when needed</li> <li>Result Compilation: Aggregate marginal and joint distributions</li> </ol>"},{"location":"architecture/core/#memory-management","title":"Memory Management","text":"<ul> <li>Quantum States: Exponential scaling in qubit number</li> <li>Classical Tables: Polynomial scaling in variable count  </li> <li>Hybrid Mixing: Linear combination overhead</li> <li>Entanglement: Tensor product state spaces</li> </ul>"},{"location":"architecture/core/#error-handling","title":"Error Handling","text":"<pre><code># Custom exception hierarchy\nclass QuantumReasoningError(Exception): pass\nclass QuantumStateError(QuantumReasoningError): pass\nclass InferenceError(QuantumReasoningError): pass\nclass BackendError(QuantumReasoningError): pass\nclass MeasurementError(QuantumReasoningError): pass\n</code></pre>"},{"location":"architecture/core/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/core/#scalability-limits","title":"Scalability Limits","text":"<ul> <li>Classical simulation: ~20 qubits practical limit</li> <li>Quantum hardware: Noise and decoherence constraints</li> <li>Memory usage: 2^n complex numbers for n qubits</li> <li>Computational complexity: Exponential in general case</li> </ul>"},{"location":"architecture/core/#optimization-strategies","title":"Optimization Strategies","text":"<ul> <li>Sparse representations: For mostly classical networks</li> <li>Approximate methods: Variational and sampling approaches</li> <li>Backend selection: Match algorithm to hardware capabilities</li> <li>Caching: Reuse computed quantum states and measurements</li> </ul>"},{"location":"architecture/core/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Quantum Backends</li> <li>Explore Inference Engines </li> <li>See User Guide for practical usage</li> <li>Check API Reference for detailed documentation</li> </ul>"},{"location":"architecture/inference/","title":"Inference Engines","text":"<p>This document describes the inference algorithms and engines that power probabilistic reasoning in quantum-classical hybrid networks.</p>"},{"location":"architecture/inference/#overview","title":"Overview","text":"<p>The inference system combines classical probabilistic reasoning with quantum amplitude-based computation to provide powerful uncertainty modeling capabilities:</p> <pre><code>graph TD\n    A[Inference Engine] --&gt; B[Belief Propagation]\n    A --&gt; C[Variational Methods]\n    A --&gt; D[Causal Inference]\n    A --&gt; E[Quantum Algorithms]\n\n    B --&gt; F[Message Passing]\n    B --&gt; G[Amplitude Propagation]\n\n    C --&gt; H[VQE]\n    C --&gt; I[QAOA]\n\n    D --&gt; J[Do-Calculus]\n    D --&gt; K[Counterfactuals]\n\n    E --&gt; L[Grover Search]\n    E --&gt; M[Quantum Sampling]</code></pre>"},{"location":"architecture/inference/#inference-engine-architecture","title":"Inference Engine Architecture","text":"<p>The main inference coordinator manages different reasoning algorithms:</p> <pre><code>from probabilistic_quantum_reasoner.inference import InferenceEngine\n\nclass InferenceEngine:\n    \"\"\"Main inference engine for quantum Bayesian networks.\"\"\"\n\n    def __init__(self, network: QuantumBayesianNetwork):\n        self.network = network\n        self.belief_propagation = QuantumBeliefPropagation(network)\n        self.variational_engine = VariationalInference(network)\n        self.causal_engine = CausalInference(network)\n\n    def infer(self, query_nodes: List[str], evidence: Dict[str, Any] = None,\n              method: str = \"belief_propagation\", **kwargs) -&gt; InferenceResult:\n        \"\"\"Perform probabilistic inference.\"\"\"\n\n        if method == \"belief_propagation\":\n            return self.belief_propagation.infer(query_nodes, evidence, **kwargs)\n        elif method == \"variational\":\n            return self.variational_engine.infer(query_nodes, evidence, **kwargs)\n        elif method == \"sampling\":\n            return self._quantum_sampling(query_nodes, evidence, **kwargs)\n        else:\n            raise ValueError(f\"Unknown inference method: {method}\")\n</code></pre>"},{"location":"architecture/inference/#belief-propagation","title":"Belief Propagation","text":"<p>Quantum belief propagation extends classical message passing to quantum amplitude domains.</p>"},{"location":"architecture/inference/#quantum-message-passing","title":"Quantum Message Passing","text":"<pre><code>class QuantumBeliefPropagation:\n    \"\"\"Quantum belief propagation algorithm.\"\"\"\n\n    def propagate_messages(self, max_iterations: int = 50) -&gt; bool:\n        \"\"\"Propagate quantum amplitude messages through network.\"\"\"\n\n        for iteration in range(max_iterations):\n            converged = True\n\n            for edge in self.network.edges:\n                # Compute quantum message from parent to child\n                old_message = self.messages.get(edge, None)\n                new_message = self._compute_quantum_message(edge)\n\n                # Check convergence\n                if old_message is not None:\n                    fidelity = self._compute_message_fidelity(old_message, new_message)\n                    if fidelity &lt; 0.999:  # Convergence threshold\n                        converged = False\n\n                self.messages[edge] = new_message\n\n            if converged:\n                return True\n\n        return False  # Did not converge\n\n    def _compute_quantum_message(self, edge: Tuple[str, str]) -&gt; QuantumMessage:\n        \"\"\"Compute quantum amplitude message along edge.\"\"\"\n        parent_id, child_id = edge\n        parent_node = self.network.nodes[parent_id]\n        child_node = self.network.nodes[child_id]\n\n        if isinstance(parent_node, QuantumNode):\n            # Quantum parent sends amplitude message\n            parent_amplitudes = parent_node.quantum_state.amplitudes\n\n            # Apply conditional probability transformation\n            if hasattr(child_node, 'conditional_probability_table'):\n                cpt = child_node.conditional_probability_table\n                message_amplitudes = self._apply_cpt_to_amplitudes(\n                    parent_amplitudes, cpt\n                )\n            else:\n                # Direct amplitude propagation\n                message_amplitudes = parent_amplitudes\n\n            return QuantumMessage(\n                amplitudes=message_amplitudes,\n                sender=parent_id,\n                receiver=child_id\n            )\n\n        else:\n            # Classical parent sends probability message (converted to amplitudes)\n            parent_probs = parent_node.probability_distribution\n            message_amplitudes = np.sqrt(list(parent_probs.values())).astype(complex)\n\n            return QuantumMessage(\n                amplitudes=message_amplitudes,\n                sender=parent_id,\n                receiver=child_id\n            )\n</code></pre>"},{"location":"architecture/inference/#amplitude-integration","title":"Amplitude Integration","text":"<pre><code>def _integrate_messages(self, node_id: str) -&gt; QuantumState:\n    \"\"\"Integrate incoming quantum messages at a node.\"\"\"\n    node = self.network.nodes[node_id]\n    incoming_messages = [msg for msg in self.messages.values() \n                        if msg.receiver == node_id]\n\n    if isinstance(node, QuantumNode):\n        # Start with node's intrinsic quantum state\n        combined_amplitudes = node.quantum_state.amplitudes.copy()\n\n        # Multiply by incoming amplitude messages\n        for message in incoming_messages:\n            combined_amplitudes = self._multiply_amplitudes(\n                combined_amplitudes, message.amplitudes\n            )\n\n        # Normalize\n        combined_amplitudes /= np.linalg.norm(combined_amplitudes)\n\n        return QuantumState(combined_amplitudes)\n\n    else:\n        # Classical node: convert messages to probabilities\n        combined_probs = np.ones(len(node.outcome_space))\n\n        for message in incoming_messages:\n            message_probs = np.abs(message.amplitudes) ** 2\n            combined_probs *= message_probs\n\n        # Normalize and convert back to amplitudes\n        combined_probs /= np.sum(combined_probs)\n        combined_amplitudes = np.sqrt(combined_probs).astype(complex)\n\n        return QuantumState(combined_amplitudes)\n</code></pre>"},{"location":"architecture/inference/#variational-inference","title":"Variational Inference","text":"<p>Variational methods optimize parameterized quantum circuits to approximate posterior distributions.</p>"},{"location":"architecture/inference/#variational-quantum-eigensolver-vqe","title":"Variational Quantum Eigensolver (VQE)","text":"<pre><code>class VariationalInference:\n    \"\"\"Variational quantum inference using VQE.\"\"\"\n\n    def __init__(self, network: QuantumBayesianNetwork, backend: QuantumBackend):\n        self.network = network\n        self.backend = backend\n\n    def optimize_variational_distribution(self, target_nodes: List[str], \n                                        evidence: Dict[str, Any] = None,\n                                        max_iterations: int = 100) -&gt; Dict[str, Any]:\n        \"\"\"Optimize variational quantum circuit to approximate posterior.\"\"\"\n\n        # Create parameterized quantum circuit\n        n_qubits = len(target_nodes)\n        n_parameters = 2 * n_qubits  # RY and RZ rotations per qubit\n\n        def create_ansatz(parameters: np.ndarray):\n            \"\"\"Create variational ansatz circuit.\"\"\"\n            circuit_ops = []\n\n            # Layer 1: Individual rotations\n            for i, param in enumerate(parameters[:n_qubits]):\n                circuit_ops.append(('RY', i, param))\n\n            # Layer 2: Entangling gates\n            for i in range(n_qubits - 1):\n                circuit_ops.append(('CNOT', i, i + 1))\n\n            # Layer 3: More rotations\n            for i, param in enumerate(parameters[n_qubits:2*n_qubits]):\n                circuit_ops.append(('RZ', i, param))\n\n            return circuit_ops\n\n        # Cost function: KL divergence from target distribution\n        def cost_function(parameters: np.ndarray) -&gt; float:\n            circuit = create_ansatz(parameters)\n            variational_state = self._execute_circuit(circuit)\n\n            # Compute target distribution from network inference\n            target_result = self.network.infer(\n                query_nodes=target_nodes, \n                evidence=evidence,\n                method=\"belief_propagation\"\n            )\n\n            # Extract target probabilities\n            target_probs = []\n            for node_id in target_nodes:\n                node_dist = target_result.marginal_probabilities[node_id]\n                target_probs.extend(list(node_dist.values()))\n\n            target_probs = np.array(target_probs)\n            variational_probs = np.abs(variational_state.amplitudes) ** 2\n\n            # KL divergence\n            epsilon = 1e-10\n            kl_div = np.sum(target_probs * np.log(\n                (target_probs + epsilon) / (variational_probs + epsilon)\n            ))\n\n            return kl_div\n\n        # Optimization using classical optimizer\n        from scipy.optimize import minimize\n\n        initial_params = np.random.uniform(0, 2*np.pi, n_parameters)\n        result = minimize(\n            cost_function, \n            initial_params, \n            method='L-BFGS-B',\n            options={'maxiter': max_iterations}\n        )\n\n        # Return optimized parameters and final state\n        optimal_circuit = create_ansatz(result.x)\n        optimal_state = self._execute_circuit(optimal_circuit)\n\n        return {\n            \"optimal_parameters\": result.x,\n            \"optimal_state\": optimal_state,\n            \"final_cost\": result.fun,\n            \"optimization_success\": result.success,\n            \"iterations\": result.nit\n        }\n</code></pre>"},{"location":"architecture/inference/#quantum-approximate-optimization-algorithm-qaoa","title":"Quantum Approximate Optimization Algorithm (QAOA)","text":"<pre><code>def qaoa_inference(self, query_nodes: List[str], evidence: Dict[str, Any] = None,\n                  p_layers: int = 3) -&gt; Dict[str, Any]:\n    \"\"\"Use QAOA for approximate inference.\"\"\"\n\n    # Define problem Hamiltonian based on network structure\n    problem_hamiltonian = self._construct_problem_hamiltonian(query_nodes, evidence)\n\n    # Define mixer Hamiltonian (usually sum of X rotations)\n    mixer_hamiltonian = self._construct_mixer_hamiltonian(len(query_nodes))\n\n    # QAOA ansatz with p layers\n    def qaoa_circuit(gamma_params: np.ndarray, beta_params: np.ndarray):\n        \"\"\"QAOA circuit with alternating problem and mixer unitaries.\"\"\"\n\n        # Initialize in uniform superposition\n        state = np.ones(2**len(query_nodes), dtype=complex) / np.sqrt(2**len(query_nodes))\n\n        for p in range(p_layers):\n            # Apply problem unitary: exp(-i * gamma * H_problem)\n            problem_unitary = self._matrix_exponential(-1j * gamma_params[p] * problem_hamiltonian)\n            state = problem_unitary @ state\n\n            # Apply mixer unitary: exp(-i * beta * H_mixer)\n            mixer_unitary = self._matrix_exponential(-1j * beta_params[p] * mixer_hamiltonian)\n            state = mixer_unitary @ state\n\n        return state\n\n    # Optimize QAOA parameters\n    def qaoa_cost(params):\n        gamma_params = params[:p_layers]\n        beta_params = params[p_layers:]\n\n        final_state = qaoa_circuit(gamma_params, beta_params)\n        expectation = np.real(np.conj(final_state) @ problem_hamiltonian @ final_state)\n\n        return expectation\n\n    # Classical optimization\n    initial_params = np.random.uniform(0, np.pi, 2 * p_layers)\n    result = minimize(qaoa_cost, initial_params, method='COBYLA')\n\n    # Extract final quantum state\n    optimal_gamma = result.x[:p_layers]\n    optimal_beta = result.x[p_layers:]\n    final_state = qaoa_circuit(optimal_gamma, optimal_beta)\n\n    return {\n        \"optimal_state\": final_state,\n        \"optimal_parameters\": {\"gamma\": optimal_gamma, \"beta\": optimal_beta},\n        \"expectation_value\": result.fun,\n        \"optimization_success\": result.success\n    }\n</code></pre>"},{"location":"architecture/inference/#causal-inference","title":"Causal Inference","text":"<p>Implement do-calculus and counterfactual reasoning in quantum networks.</p>"},{"location":"architecture/inference/#do-calculus-implementation","title":"Do-Calculus Implementation","text":"<pre><code>class CausalInference:\n    \"\"\"Causal inference with quantum interventions.\"\"\"\n\n    def do_intervention(self, interventions: Dict[str, Any], \n                       query_nodes: List[str]) -&gt; InferenceResult:\n        \"\"\"Perform causal intervention using do-calculus.\"\"\"\n\n        # Create modified network with interventions\n        modified_network = self.network.copy()\n\n        for node_id, intervention_value in interventions.items():\n            node = modified_network.nodes[node_id]\n\n            if isinstance(node, QuantumNode):\n                # Quantum intervention: set node to specific amplitude pattern\n                intervention_amplitudes = self._create_intervention_amplitudes(\n                    node.outcome_space, intervention_value\n                )\n                node.set_amplitudes(intervention_amplitudes)\n\n                # Remove incoming edges (break causal dependencies)\n                incoming_edges = [edge for edge in modified_network.edges \n                                if edge[1] == node_id]\n                for edge in incoming_edges:\n                    modified_network.remove_edge(edge)\n\n            else:\n                # Classical intervention: set deterministic distribution\n                intervention_dist = {value: 1.0 if value == intervention_value else 0.0\n                                   for value in node.outcome_space}\n                node.set_distribution(intervention_dist)\n\n                # Remove incoming edges\n                incoming_edges = [edge for edge in modified_network.edges \n                                if edge[1] == node_id]\n                for edge in incoming_edges:\n                    modified_network.remove_edge(edge)\n\n        # Perform inference on modified network\n        return modified_network.infer(query_nodes=query_nodes)\n</code></pre>"},{"location":"architecture/inference/#counterfactual-reasoning","title":"Counterfactual Reasoning","text":"<pre><code>def counterfactual_inference(self, factual_evidence: Dict[str, Any],\n                           counterfactual_intervention: Dict[str, Any],\n                           query_nodes: List[str]) -&gt; Dict[str, Any]:\n    \"\"\"Perform counterfactual reasoning: \"What if X had been Y instead of Z?\".\"\"\"\n\n    # Step 1: Abduction - infer latent variables given factual evidence\n    latent_inference = self.network.infer(\n        query_nodes=self._get_latent_nodes(),\n        evidence=factual_evidence\n    )\n\n    # Step 2: Action - apply counterfactual intervention\n    counterfactual_network = self.network.copy()\n\n    # Set latent variables to inferred values\n    for latent_id in self._get_latent_nodes():\n        latent_dist = latent_inference.marginal_probabilities[latent_id]\n        # Sample from posterior or use expected value\n        latent_value = max(latent_dist.items(), key=lambda x: x[1])[0]\n        counterfactual_network.set_evidence(latent_id, latent_value)\n\n    # Apply intervention\n    counterfactual_result = counterfactual_network.intervene(\n        interventions=counterfactual_intervention,\n        query_nodes=query_nodes\n    )\n\n    # Step 3: Prediction - compute counterfactual outcome\n    return {\n        \"factual_evidence\": factual_evidence,\n        \"counterfactual_intervention\": counterfactual_intervention,\n        \"latent_posterior\": latent_inference.marginal_probabilities,\n        \"counterfactual_outcome\": counterfactual_result.marginal_probabilities,\n        \"causal_effect\": self._compute_causal_effect(\n            factual_evidence, counterfactual_result.marginal_probabilities\n        )\n    }\n</code></pre>"},{"location":"architecture/inference/#quantum-specific-algorithms","title":"Quantum-Specific Algorithms","text":""},{"location":"architecture/inference/#grover-based-search","title":"Grover-Based Search","text":"<pre><code>def grover_inference(self, query_predicate: callable, \n                    max_iterations: Optional[int] = None) -&gt; Dict[str, Any]:\n    \"\"\"Use Grover's algorithm for quantum search-based inference.\"\"\"\n\n    n_qubits = len(self.network.quantum_nodes)\n    n_items = 2 ** n_qubits\n\n    if max_iterations is None:\n        max_iterations = int(np.pi * np.sqrt(n_items) / 4)\n\n    # Initialize uniform superposition\n    state = np.ones(n_items, dtype=complex) / np.sqrt(n_items)\n\n    # Grover iterations\n    for iteration in range(max_iterations):\n        # Oracle: mark satisfying states\n        oracle_matrix = self._construct_oracle_matrix(query_predicate)\n        state = oracle_matrix @ state\n\n        # Diffusion operator: amplify marked amplitudes\n        diffusion_matrix = self._construct_diffusion_matrix(n_items)\n        state = diffusion_matrix @ state\n\n    # Measure final state\n    probabilities = np.abs(state) ** 2\n\n    return {\n        \"amplitudes\": state,\n        \"probabilities\": probabilities,\n        \"most_likely_state\": np.argmax(probabilities),\n        \"iterations\": max_iterations\n    }\n</code></pre>"},{"location":"architecture/inference/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/inference/#complexity-analysis","title":"Complexity Analysis","text":"Algorithm Time Complexity Space Complexity Quantum Advantage Belief Propagation O(n\u00b2d^k) O(nd) Amplitude interference Variational O(poly(n)) O(2^n) Circuit expressivity QAOA O(p\u00b7poly(n)) O(2^n) Quantum parallelism Grover Search O(\u221aN) O(log N) Quadratic speedup <p>Where: - n = number of nodes - d = domain size - k = maximum node degree - p = QAOA layers - N = search space size</p>"},{"location":"architecture/inference/#accuracy-vs-speed-trade-offs","title":"Accuracy vs Speed Trade-offs","text":"<pre><code># Configuration for different use cases\nINFERENCE_CONFIGS = {\n    \"fast\": {\n        \"method\": \"belief_propagation\",\n        \"max_iterations\": 10,\n        \"convergence_threshold\": 1e-3\n    },\n    \"accurate\": {\n        \"method\": \"variational\",\n        \"max_iterations\": 1000,\n        \"convergence_threshold\": 1e-6\n    },\n    \"quantum_advantage\": {\n        \"method\": \"grover\",\n        \"max_iterations\": None,  # Optimal\n        \"post_processing\": True\n    }\n}\n</code></pre>"},{"location":"architecture/inference/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about building networks </li> <li>Explore causal reasoning in detail</li> <li>See variational methods examples</li> <li>Check API Reference for complete documentation</li> </ul>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>The Probabilistic Quantum Reasoner is designed with a modular, extensible architecture that supports both classical simulation and quantum hardware execution.</p>"},{"location":"architecture/overview/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>graph TB\n    A[User Application] --&gt; B[QuantumBayesianNetwork]\n    B --&gt; C[Core Components]\n    B --&gt; D[Inference Engine]\n    B --&gt; E[Quantum Backends]\n\n    C --&gt; F[Quantum Nodes]\n    C --&gt; G[Classical Nodes]\n    C --&gt; H[Hybrid Nodes]\n    C --&gt; I[Quantum Operators]\n\n    D --&gt; J[Belief Propagation]\n    D --&gt; K[Causal Inference]\n    D --&gt; L[Variational Methods]\n\n    E --&gt; M[Classical Simulator]\n    E --&gt; N[Qiskit Backend]\n    E --&gt; O[PennyLane Backend]\n    E --&gt; P[Custom Backends]</code></pre>"},{"location":"architecture/overview/#core-design-principles","title":"Core Design Principles","text":""},{"location":"architecture/overview/#1-quantum-classical-hybrid-architecture","title":"1. Quantum-Classical Hybrid Architecture","text":"<p>The library seamlessly integrates quantum and classical computation:</p> <ul> <li>Quantum Variables: Represented as quantum states with complex amplitudes</li> <li>Classical Variables: Traditional discrete random variables</li> <li>Hybrid Variables: Mixture of quantum and classical uncertainty</li> </ul>"},{"location":"architecture/overview/#2-backend-abstraction","title":"2. Backend Abstraction","text":"<p>All quantum operations go through an abstract backend interface:</p> <pre><code>class QuantumBackend:\n    def execute_circuit(self, circuit, measurements):\n        \"\"\"Execute quantum circuit and return measurement results.\"\"\"\n        pass\n\n    def get_quantum_state(self, circuit):\n        \"\"\"Return the quantum state vector.\"\"\"\n        pass\n\n    def apply_gate(self, gate, qubits):\n        \"\"\"Apply quantum gate to specified qubits.\"\"\"\n        pass\n</code></pre> <p>This allows the same high-level code to run on:</p> <ul> <li>Classical simulators (NumPy-based)</li> <li>IBM Quantum hardware (via Qiskit)</li> <li>Variational quantum processors (via PennyLane)</li> <li>Custom quantum devices</li> </ul>"},{"location":"architecture/overview/#3-probabilistic-graphical-model-foundation","title":"3. Probabilistic Graphical Model Foundation","text":"<p>Built on established PGM principles:</p> <ul> <li>Nodes: Random variables (quantum, classical, or hybrid)</li> <li>Edges: Conditional dependencies</li> <li>Inference: Message passing and belief propagation</li> <li>Causal: Do-calculus for interventions</li> </ul>"},{"location":"architecture/overview/#component-details","title":"Component Details","text":""},{"location":"architecture/overview/#core-components-core","title":"Core Components (<code>core/</code>)","text":""},{"location":"architecture/overview/#quantumbayesiannetwork","title":"QuantumBayesianNetwork","text":"<p>The main orchestrator that manages:</p> <ul> <li>Network topology (nodes and edges)</li> <li>Quantum state management</li> <li>Inference coordination</li> <li>Causal operations</li> </ul>"},{"location":"architecture/overview/#node-types","title":"Node Types","text":"<ul> <li>QuantumNode: Variables in quantum superposition</li> <li>StochasticNode: Classical discrete random variables  </li> <li>HybridNode: Mixed quantum-classical variables</li> </ul>"},{"location":"architecture/overview/#quantum-operators","title":"Quantum Operators","text":"<ul> <li>UnitaryOperator: Reversible quantum transformations</li> <li>MeasurementOperator: Quantum measurements with Born rule</li> <li>QuantumGate: Library of standard quantum gates</li> </ul>"},{"location":"architecture/overview/#inference-engine-inference","title":"Inference Engine (<code>inference/</code>)","text":""},{"location":"architecture/overview/#belief-propagation-belief_propagationpy","title":"Belief Propagation (<code>belief_propagation.py</code>)","text":"<p>Quantum-enhanced message passing:</p> <ul> <li>Amplitude-based messages</li> <li>Quantum interference effects</li> <li>Entanglement-aware propagation</li> </ul>"},{"location":"architecture/overview/#causal-inference-causalpy","title":"Causal Inference (<code>causal.py</code>)","text":"<p>Quantum do-calculus implementation:</p> <ul> <li>Interventional distributions P(Y|do(X))</li> <li>Counterfactual reasoning</li> <li>Causal effect identification</li> </ul>"},{"location":"architecture/overview/#variational-methods-variationalpy","title":"Variational Methods (<code>variational.py</code>)","text":"<p>Quantum optimization algorithms:</p> <ul> <li>Variational Quantum Eigensolver (VQE)</li> <li>Quantum Approximate Optimization Algorithm (QAOA)</li> <li>Parameter optimization</li> </ul>"},{"location":"architecture/overview/#backend-implementations-backends","title":"Backend Implementations (<code>backends/</code>)","text":""},{"location":"architecture/overview/#classical-simulator-simulatorpy","title":"Classical Simulator (<code>simulator.py</code>)","text":"<p>High-performance NumPy-based simulation:</p> <ul> <li>Exact quantum state vector simulation</li> <li>Efficient tensor operations</li> <li>Automatic classical fallbacks</li> </ul>"},{"location":"architecture/overview/#qiskit-backend-qiskit_backendpy","title":"Qiskit Backend (<code>qiskit_backend.py</code>)","text":"<p>IBM Quantum integration:</p> <ul> <li>IBMQ hardware access</li> <li>Quantum circuit compilation</li> <li>Error mitigation techniques</li> </ul>"},{"location":"architecture/overview/#pennylane-backend-pennylane_backendpy","title":"PennyLane Backend (<code>pennylane_backend.py</code>)","text":"<p>Variational quantum computing:</p> <ul> <li>Automatic differentiation</li> <li>Multiple device support</li> <li>Hybrid optimization</li> </ul>"},{"location":"architecture/overview/#data-flow","title":"Data Flow","text":""},{"location":"architecture/overview/#1-network-construction","title":"1. Network Construction","text":"<pre><code>network = QuantumBayesianNetwork(\"MyNetwork\", backend)\nnode = network.add_quantum_node(\"variable\", outcome_space, amplitudes)\nnetwork.add_edge(parent, child)\n</code></pre>"},{"location":"architecture/overview/#2-quantum-state-management","title":"2. Quantum State Management","text":"<ul> <li>Nodes maintain quantum states as complex amplitude vectors</li> <li>Edges define conditional dependencies via quantum operators</li> <li>Network tracks entanglement relationships</li> </ul>"},{"location":"architecture/overview/#3-inference-process","title":"3. Inference Process","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Network\n    participant InferenceEngine\n    participant Backend\n\n    User-&gt;&gt;Network: infer(evidence, query_nodes)\n    Network-&gt;&gt;InferenceEngine: prepare_inference(evidence)\n    InferenceEngine-&gt;&gt;Backend: execute_quantum_operations()\n    Backend--&gt;&gt;InferenceEngine: quantum_results\n    InferenceEngine--&gt;&gt;Network: marginal_probabilities\n    Network--&gt;&gt;User: InferenceResult</code></pre>"},{"location":"architecture/overview/#4-backend-execution","title":"4. Backend Execution","text":"<ul> <li>Abstract quantum operations into backend calls</li> <li>Graceful fallback to classical simulation</li> <li>Result validation and error handling</li> </ul>"},{"location":"architecture/overview/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/overview/#time-complexity","title":"Time Complexity","text":"<ul> <li>Classical simulation: O(2^n) for n quantum variables</li> <li>Quantum hardware: O(poly(n)) for many algorithms</li> <li>Hybrid algorithms: Problem-dependent optimization</li> </ul>"},{"location":"architecture/overview/#space-complexity","title":"Space Complexity","text":"<ul> <li>Quantum states: O(2^n) amplitudes stored</li> <li>Classical variables: O(k^m) for k states, m variables</li> <li>Hybrid representation: Automatic optimization</li> </ul>"},{"location":"architecture/overview/#scalability-limits","title":"Scalability Limits","text":"<ul> <li>Classical simulation: ~20 quantum variables</li> <li>NISQ devices: ~100 quantum variables (noisy)</li> <li>Future quantum: Exponential scaling potential</li> </ul>"},{"location":"architecture/overview/#extensibility-points","title":"Extensibility Points","text":""},{"location":"architecture/overview/#custom-node-types","title":"Custom Node Types","text":"<pre><code>class MyCustomNode(BaseNode):\n    def __init__(self, node_id, outcome_space, **kwargs):\n        super().__init__(node_id, outcome_space, **kwargs)\n        # Custom initialization\n\n    def compute_message(self, evidence):\n        # Custom message computation\n        pass\n</code></pre>"},{"location":"architecture/overview/#custom-inference-algorithms","title":"Custom Inference Algorithms","text":"<pre><code>class MyInferenceAlgorithm(InferenceAlgorithm):\n    def infer(self, network, evidence, query_nodes):\n        # Custom inference logic\n        return InferenceResult(...)\n</code></pre>"},{"location":"architecture/overview/#custom-backends","title":"Custom Backends","text":"<pre><code>class MyQuantumBackend(QuantumBackend):\n    def execute_circuit(self, circuit, measurements):\n        # Interface to your quantum hardware\n        pass\n</code></pre>"},{"location":"architecture/overview/#error-handling-strategy","title":"Error Handling Strategy","text":""},{"location":"architecture/overview/#quantum-specific-errors","title":"Quantum-Specific Errors","text":"<ul> <li>QuantumStateError: Invalid quantum states</li> <li>EntanglementError: Entanglement consistency issues</li> <li>MeasurementError: Measurement operation failures</li> <li>BackendError: Quantum backend communication errors</li> </ul>"},{"location":"architecture/overview/#graceful-degradation","title":"Graceful Degradation","text":"<ul> <li>Automatic fallback to classical simulation</li> <li>Approximate algorithms when exact solutions intractable</li> <li>Warning systems for quantum coherence loss</li> </ul>"},{"location":"architecture/overview/#validation","title":"Validation","text":"<ul> <li>Quantum state normalization checks</li> <li>Probability distribution validation</li> <li>Network topology consistency verification</li> </ul>"},{"location":"architecture/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Core Components: Detailed component documentation</li> <li>Quantum Backends: Backend-specific guides</li> <li>Inference Engines: Algorithm details</li> </ul>"},{"location":"contributing/docs/","title":"Documentation Guidelines","text":"<p>This document provides guidelines for contributing to and maintaining the project documentation.</p>"},{"location":"contributing/docs/#documentation-philosophy","title":"Documentation Philosophy","text":"<p>Our documentation follows these principles:</p> <ul> <li>User-First: Write for the user's needs and experience level</li> <li>Complete: Cover all functionality with examples</li> <li>Accurate: Keep documentation synchronized with code</li> <li>Accessible: Use clear language and good structure</li> <li>Maintainable: Make documentation easy to update</li> </ul>"},{"location":"contributing/docs/#documentation-structure","title":"Documentation Structure","text":""},{"location":"contributing/docs/#overview","title":"Overview","text":"<pre><code>docs/\n\u251c\u2500\u2500 index.md                   # Main landing page\n\u251c\u2500\u2500 getting-started/           # Getting started guides\n\u2502   \u251c\u2500\u2500 installation.md\n\u2502   \u251c\u2500\u2500 quick-start.md\n\u2502   \u2514\u2500\u2500 basic-concepts.md\n\u251c\u2500\u2500 architecture/              # System architecture\n\u2502   \u251c\u2500\u2500 overview.md\n\u2502   \u251c\u2500\u2500 quantum-backends.md\n\u2502   \u2514\u2500\u2500 inference-engines.md\n\u251c\u2500\u2500 user-guide/               # Detailed user guides\n\u2502   \u251c\u2500\u2500 creating-networks.md\n\u2502   \u251c\u2500\u2500 inference.md\n\u2502   \u251c\u2500\u2500 causal-reasoning.md\n\u2502   \u2514\u2500\u2500 performance.md\n\u251c\u2500\u2500 examples/                 # Code examples\n\u2502   \u251c\u2500\u2500 weather-prediction.md\n\u2502   \u251c\u2500\u2500 medical-diagnosis.md\n\u2502   \u251c\u2500\u2500 quantum-xor.md\n\u2502   \u2514\u2500\u2500 prisoners-dilemma.md\n\u251c\u2500\u2500 api/                      # API documentation\n\u2502   \u251c\u2500\u2500 inference.md\n\u2502   \u251c\u2500\u2500 backends.md\n\u2502   \u2514\u2500\u2500 examples.md\n\u251c\u2500\u2500 advanced/                 # Advanced topics\n\u2502   \u251c\u2500\u2500 entanglement.md\n\u2502   \u251c\u2500\u2500 custom-backends.md\n\u2502   \u2514\u2500\u2500 optimization.md\n\u2514\u2500\u2500 contributing/             # Contributing guides\n    \u251c\u2500\u2500 setup.md\n    \u251c\u2500\u2500 testing.md\n    \u2514\u2500\u2500 docs.md\n</code></pre>"},{"location":"contributing/docs/#writing-guidelines","title":"Writing Guidelines","text":""},{"location":"contributing/docs/#markdown-standards","title":"Markdown Standards","text":""},{"location":"contributing/docs/#headers","title":"Headers","text":"<p>Use ATX-style headers with proper hierarchy:</p> <pre><code># Page Title (H1) - Only one per page\n\n## Major Section (H2)\n\n### Subsection (H3)\n\n#### Sub-subsection (H4)\n</code></pre>"},{"location":"contributing/docs/#code-blocks","title":"Code Blocks","text":"<p>Always specify the language for syntax highlighting:</p> <pre><code>```python\ndef example_function():\n    return \"Always specify language\"\n</code></pre> <pre><code># For shell commands\npip install probabilistic-quantum-reasoner\n</code></pre> <p><pre><code># For configuration files\nconfig:\n  backend: qiskit\n</code></pre> <pre><code>#### Links\n\nUse descriptive link text:\n\n```markdown\n&lt;!-- Good --&gt;\nSee the [installation guide](installation.md) for setup instructions.\n\n&lt;!-- Bad --&gt;\nClick [here](installation.md) for installation.\n</code></pre></p>"},{"location":"contributing/docs/#lists","title":"Lists","text":"<p>Use consistent formatting:</p> <pre><code>- First item\n- Second item\n  - Nested item\n  - Another nested item\n- Third item\n\n1. Numbered first item\n2. Numbered second item\n3. Numbered third item\n</code></pre>"},{"location":"contributing/docs/#content-guidelines","title":"Content Guidelines","text":""},{"location":"contributing/docs/#code-examples","title":"Code Examples","text":"<p>All code examples should be:</p> <ol> <li>Complete: Include all necessary imports and setup</li> <li>Runnable: Examples should work when copy-pasted</li> <li>Explained: Include context and explanation</li> <li>Tested: Verify examples work with current codebase</li> </ol> <p>Example structure:</p> <pre><code>## Creating a Simple Network\n\nThis example shows how to create a basic Bayesian network:\n\n```python\nfrom probabilistic_quantum_reasoner import ProbabilisticQuantumReasoner\nfrom probabilistic_quantum_reasoner.networks import BayesianNetwork\nfrom probabilistic_quantum_reasoner.nodes import DiscreteNode\nimport numpy as np\n\n# Create a new network\nnetwork = BayesianNetwork(name=\"Weather Example\")\n\n# Add a weather node\nweather = DiscreteNode(\n    name=\"Weather\",\n    states=[\"sunny\", \"rainy\"],\n    prior=[0.7, 0.3]\n)\n\n# Add a mood node that depends on weather\nmood = DiscreteNode(\n    name=\"Mood\",\n    states=[\"happy\", \"sad\"],\n    parents=[weather],\n    cpt=np.array([\n        [0.8, 0.2],  # P(Mood | Weather=sunny)\n        [0.3, 0.7]   # P(Mood | Weather=rainy)\n    ])\n)\n\n# Add nodes to network\nnetwork.add_nodes([weather, mood])\n\n# Create reasoner and perform inference\nreasoner = ProbabilisticQuantumReasoner(backend=\"classical\")\nresult = reasoner.infer(\n    network=network,\n    query=[\"Mood\"],\n    evidence={\"Weather\": \"sunny\"}\n)\n\nprint(f\"P(Mood=happy | Weather=sunny) = {result['Mood']['happy']:.3f}\")\n# Output: P(Mood=happy | Weather=sunny) = 0.800\n</code></pre> <p>Key points:</p> <ul> <li>The <code>prior</code> parameter specifies initial probabilities</li> <li>The <code>cpt</code> (Conditional Probability Table) defines dependencies</li> <li>Evidence is provided as a dictionary of {variable: value} pairs <pre><code>#### Mathematical Notation\n\nUse MathJax for mathematical expressions:\n\n```markdown\nThe probability of state $s_i$ given evidence $e$ is:\n\n$$P(s_i | e) = \\frac{P(e | s_i) P(s_i)}{P(e)}$$\n\nFor inline math, use single dollar signs: $P(A|B)$.\n</code></pre></li> </ul>"},{"location":"contributing/docs/#diagrams","title":"Diagrams","text":"<p>Include diagrams for complex concepts:</p> <pre><code>### Network Structure\n\n```mermaid\ngraph TD\n    A[Weather] --&gt; B[Mood]\n    A --&gt; C[Activity]\n    B --&gt; D[Productivity]\n    C --&gt; D\n</code></pre> <p>This network represents causal relationships between weather conditions and daily outcomes. <pre><code>#### API Documentation\n\nUse consistent format for API documentation:\n\n```markdown\n### `infer(network, query, evidence=None, method=\"auto\")`\n\nPerform probabilistic inference on a Bayesian network.\n\n**Parameters:**\n\n- `network` (BayesianNetwork): The network to perform inference on\n- `query` (list): List of variable names to query\n- `evidence` (dict, optional): Evidence as {variable: value} pairs\n- `method` (str, optional): Inference method (\"exact\", \"approximate\", \"auto\")\n\n**Returns:**\n\n- `dict`: Probability distributions for queried variables\n\n**Raises:**\n\n- `ValueError`: If query variables don't exist in network\n- `InferenceError`: If inference fails to converge\n\n**Example:**\n\n```python\nresult = reasoner.infer(\n    network=my_network,\n    query=[\"Temperature\"],\n    evidence={\"Season\": \"winter\"},\n    method=\"exact\"\n)\n</code></pre> <pre><code>## Documentation Types\n\n### Getting Started Documentation\n\n**Purpose**: Help new users get up and running quickly\n\n**Characteristics**:\n- Step-by-step instructions\n- Minimal prerequisites assumed\n- Working examples\n- Links to more detailed documentation\n\n**Template**:\n\n```markdown\n# Getting Started with [Feature]\n\n## Prerequisites\n\nBefore you begin, ensure you have:\n\n- Python 3.10 or later installed\n- Basic understanding of probability theory\n\n## Installation\n\nInstall the package using pip:\n\n```bash\npip install probabilistic-quantum-reasoner\n</code></pre></p>"},{"location":"contributing/docs/#your-first-feature","title":"Your First [Feature]","text":"<p>Let's create a simple example:</p> <p>[Step-by-step example with explanations]</p>"},{"location":"contributing/docs/#next-steps","title":"Next Steps","text":"<p>Now that you've created your first [feature], you might want to:</p> <ul> <li>Learn about related concept A</li> <li>Explore advanced feature B</li> <li>See more examples <pre><code>### Tutorial Documentation\n\n**Purpose**: Guide users through complete workflows\n\n**Characteristics**:\n- Goal-oriented\n- Progressive complexity\n- Multiple interconnected examples\n- Learning checkpoints\n\n### Reference Documentation\n\n**Purpose**: Provide comprehensive API details\n\n**Characteristics**:\n- Complete parameter descriptions\n- Return value specifications\n- Exception documentation\n- Links to related functions\n\n### Conceptual Documentation\n\n**Purpose**: Explain underlying concepts and theory\n\n**Characteristics**:\n- Background information\n- Theoretical foundations\n- Design decisions\n- Comparison with alternatives\n\n## Documentation Tools\n\n### MkDocs Configuration\n\nOur documentation uses MkDocs with the Material theme:\n\n```yaml\n# mkdocs.yml key sections\nsite_name: Probabilistic Quantum Reasoner\ntheme:\n  name: material\n  features:\n    - navigation.tabs\n    - navigation.sections\n    - toc.integrate\n    - search.highlight\n\nplugins:\n  - search\n  - mkdocstrings:\n      handlers:\n        python:\n          options:\n            docstring_style: google\n  - mermaid2\n\nmarkdown_extensions:\n  - pymdownx.highlight\n  - pymdownx.superfences:\n      custom_fences:\n        - name: mermaid\n          class: mermaid\n          format: !!python/name:mermaid2.fence_mermaid\n  - pymdownx.arithmatex:\n      generic: true\n\nextra_javascript:\n  - https://polyfill.io/v3/polyfill.min.js?features=es6\n  - https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\n</code></pre></li> </ul>"},{"location":"contributing/docs/#docstring-format","title":"Docstring Format","text":"<p>Use Google-style docstrings for API documentation:</p> <pre><code>def infer(self, network, query, evidence=None, method=\"auto\"):\n    \"\"\"Perform probabilistic inference on a Bayesian network.\n\n    This method computes the posterior probability distribution for the\n    query variables given the evidence using the specified inference method.\n\n    Args:\n        network (BayesianNetwork): The network to perform inference on.\n        query (list[str]): List of variable names to query.\n        evidence (dict[str, Any], optional): Evidence as {variable: value} \n            pairs. Defaults to None.\n        method (str, optional): Inference method to use. Can be \"exact\",\n            \"approximate\", or \"auto\". Defaults to \"auto\".\n\n    Returns:\n        dict[str, dict[str, float]]: Probability distributions for each\n            queried variable. Structure is {variable: {state: probability}}.\n\n    Raises:\n        ValueError: If query variables don't exist in the network.\n        InferenceError: If inference fails to converge.\n\n    Example:\n        &gt;&gt;&gt; reasoner = ProbabilisticQuantumReasoner()\n        &gt;&gt;&gt; result = reasoner.infer(\n        ...     network=my_network,\n        ...     query=[\"Weather\"],\n        ...     evidence={\"Season\": \"summer\"}\n        ... )\n        &gt;&gt;&gt; print(result[\"Weather\"][\"sunny\"])\n        0.85\n\n    Note:\n        When method=\"auto\", the system will automatically choose the most\n        appropriate inference algorithm based on network characteristics.\n    \"\"\"\n</code></pre>"},{"location":"contributing/docs/#review-process","title":"Review Process","text":""},{"location":"contributing/docs/#documentation-reviews","title":"Documentation Reviews","text":"<p>All documentation changes should be reviewed for:</p> <ol> <li>Accuracy: Information matches current implementation</li> <li>Clarity: Content is understandable by target audience</li> <li>Completeness: All necessary information is included</li> <li>Consistency: Follows established style and conventions</li> <li>Examples: Code examples work and are relevant</li> </ol>"},{"location":"contributing/docs/#review-checklist","title":"Review Checklist","text":"<ul> <li>[ ] Content is accurate and up-to-date</li> <li>[ ] Examples are complete and runnable</li> <li>[ ] Links work and point to correct locations</li> <li>[ ] Spelling and grammar are correct</li> <li>[ ] Markdown formatting is proper</li> <li>[ ] Code blocks have language specified</li> <li>[ ] Mathematical notation renders correctly</li> <li>[ ] Images and diagrams are clear and necessary</li> </ul>"},{"location":"contributing/docs/#maintenance","title":"Maintenance","text":""},{"location":"contributing/docs/#keeping-documentation-current","title":"Keeping Documentation Current","text":"<ol> <li>Code Changes: Update docs when changing APIs</li> <li>Regular Reviews: Schedule periodic documentation audits</li> <li>User Feedback: Monitor and respond to documentation issues</li> <li>Testing: Include documentation in CI/CD pipelines</li> </ol>"},{"location":"contributing/docs/#documentation-testing","title":"Documentation Testing","text":"<p>Test documentation as part of the build process:</p> <pre><code># tests/test_docs.py\nimport subprocess\nimport pytest\n\ndef test_docs_build():\n    \"\"\"Test that documentation builds without errors.\"\"\"\n    result = subprocess.run(\n        [\"mkdocs\", \"build\", \"--strict\"],\n        capture_output=True,\n        text=True\n    )\n\n    assert result.returncode == 0, f\"Docs build failed: {result.stderr}\"\n\ndef test_example_code():\n    \"\"\"Test that code examples in documentation are valid.\"\"\"\n    # Extract and test code blocks from markdown files\n    # Implementation depends on documentation structure\n    pass\n\n@pytest.mark.slow\ndef test_links():\n    \"\"\"Test that all documentation links are valid.\"\"\"\n    # Check internal and external links\n    # Can use tools like linkchecker\n    pass\n</code></pre>"},{"location":"contributing/docs/#style-guide","title":"Style Guide","text":""},{"location":"contributing/docs/#voice-and-tone","title":"Voice and Tone","text":"<ul> <li>Active voice: \"Create a network\" rather than \"A network is created\"</li> <li>Present tense: \"The function returns\" rather than \"The function will return\"</li> <li>Second person: \"You can configure\" rather than \"One can configure\"</li> <li>Clear and direct: Avoid unnecessary jargon</li> </ul>"},{"location":"contributing/docs/#terminology","title":"Terminology","text":"<p>Maintain consistent terminology throughout:</p> <ul> <li>Bayesian Network (not Bayes Net or BN)</li> <li>Quantum Circuit (not quantum program)</li> <li>Inference Engine (not inference algorithm when referring to the component)</li> <li>Backend (not back-end or back end)</li> </ul>"},{"location":"contributing/docs/#common-phrases","title":"Common Phrases","text":"<p>Use consistent phrasing:</p> <ul> <li>\"Perform inference\" (not \"do inference\" or \"run inference\")</li> <li>\"Create a network\" (not \"build a network\" or \"make a network\")</li> <li>\"Install the package\" (not \"install the library\")</li> <li>\"Configure the backend\" (not \"setup the backend\")</li> </ul>"},{"location":"contributing/docs/#publishing","title":"Publishing","text":""},{"location":"contributing/docs/#local-development","title":"Local Development","text":"<p>To work on documentation locally:</p> <pre><code># Install development dependencies\npip install -e \".[docs]\"\n\n# Serve documentation locally\nmkdocs serve\n\n# Build documentation\nmkdocs build\n\n# Deploy to GitHub Pages (maintainers only)\nmkdocs gh-deploy\n</code></pre>"},{"location":"contributing/docs/#continuous-integration","title":"Continuous Integration","text":"<p>Documentation is automatically built and deployed:</p> <ul> <li>Pull Requests: Documentation builds are tested</li> <li>Main Branch: Documentation is deployed to GitHub Pages</li> <li>Releases: Documentation is tagged and archived</li> </ul> <p>This documentation system ensures that users have comprehensive, accurate, and maintainable guidance for using the Probabilistic Quantum Reasoner effectively.</p>"},{"location":"contributing/setup/","title":"Contributing to Probabilistic Quantum Reasoner","text":"<p>We welcome contributions from the quantum computing and AI communities! This guide will help you get started.</p>"},{"location":"contributing/setup/#development-setup","title":"Development Setup","text":""},{"location":"contributing/setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>Git</li> <li>Virtual environment tool (venv, conda, etc.)</li> </ul>"},{"location":"contributing/setup/#clone-and-setup","title":"Clone and Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/quantum-ai/probabilistic-quantum-reasoner.git\ncd probabilistic-quantum-reasoner\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in development mode\npip install -e \".[dev]\"\n\n# Install pre-commit hooks\npre-commit install\n</code></pre>"},{"location":"contributing/setup/#verify-installation","title":"Verify Installation","text":"<pre><code># Run tests\npytest\n\n# Check code formatting\nblack --check .\npylint probabilistic_quantum_reasoner\n\n# Type checking\nmypy probabilistic_quantum_reasoner\n</code></pre>"},{"location":"contributing/setup/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/setup/#1-create-feature-branch","title":"1. Create Feature Branch","text":"<pre><code>git checkout -b feature/quantum-causal-discovery\n</code></pre>"},{"location":"contributing/setup/#2-make-changes","title":"2. Make Changes","text":"<p>Follow our coding standards:</p> <ul> <li>Type hints: All functions must have type annotations</li> <li>Docstrings: Google-style docstrings for all public APIs</li> <li>Tests: Comprehensive test coverage for new features</li> <li>Black formatting: Automatic code formatting</li> </ul>"},{"location":"contributing/setup/#3-run-tests","title":"3. Run Tests","text":"<pre><code># Run all tests\npytest\n\n# Run specific test files\npytest tests/test_operators.py\n\n# Run with coverage\npytest --cov=probabilistic_quantum_reasoner --cov-report=html\n\n# Run quantum-specific tests (requires quantum backends)\npytest -m quantum\n</code></pre>"},{"location":"contributing/setup/#4-check-code-quality","title":"4. Check Code Quality","text":"<pre><code># Format code\nblack .\nisort .\n\n# Lint code\npylint probabilistic_quantum_reasoner\n\n# Type check\nmypy probabilistic_quantum_reasoner\n</code></pre>"},{"location":"contributing/setup/#5-commit-changes","title":"5. Commit Changes","text":"<pre><code>git add .\ngit commit -m \"feat: add quantum causal discovery algorithm\"\n</code></pre> <p>We use conventional commits format:</p> <ul> <li><code>feat:</code> for new features</li> <li><code>fix:</code> for bug fixes</li> <li><code>docs:</code> for documentation</li> <li><code>test:</code> for tests</li> <li><code>refactor:</code> for refactoring</li> </ul>"},{"location":"contributing/setup/#6-submit-pull-request","title":"6. Submit Pull Request","text":"<ul> <li>Push to your fork</li> <li>Create pull request with description</li> <li>Ensure CI passes</li> <li>Request review</li> </ul>"},{"location":"contributing/setup/#coding-standards","title":"Coding Standards","text":""},{"location":"contributing/setup/#code-style","title":"Code Style","text":"<p>We use Black for code formatting with these settings:</p> <pre><code>[tool.black]\nline-length = 88\ntarget-version = ['py310']\ninclude = '\\.pyi?$'\n</code></pre>"},{"location":"contributing/setup/#type-annotations","title":"Type Annotations","text":"<p>All functions must have complete type annotations:</p> <pre><code>from typing import Dict, List, Optional, Union\nimport numpy as np\n\ndef quantum_inference(\n    network: QuantumBayesianNetwork,\n    evidence: Dict[str, str],\n    query_nodes: List[str]\n) -&gt; InferenceResult:\n    \"\"\"Perform quantum inference on Bayesian network.\"\"\"\n    pass\n</code></pre>"},{"location":"contributing/setup/#docstring-format","title":"Docstring Format","text":"<p>Use Google-style docstrings:</p> <pre><code>def add_quantum_node(\n    self,\n    node_id: str,\n    outcome_space: List[str],\n    initial_amplitudes: Optional[np.ndarray] = None,\n    name: Optional[str] = None\n) -&gt; QuantumNode:\n    \"\"\"Add a quantum node to the network.\n\n    Args:\n        node_id: Unique identifier for the node.\n        outcome_space: List of possible outcomes.\n        initial_amplitudes: Complex amplitudes for quantum superposition.\n        name: Human-readable name for the node.\n\n    Returns:\n        The created quantum node.\n\n    Raises:\n        ValueError: If node_id already exists.\n        QuantumStateError: If amplitudes are not normalized.\n\n    Example:\n        &gt;&gt;&gt; network = QuantumBayesianNetwork(\"test\", backend)\n        &gt;&gt;&gt; node = network.add_quantum_node(\n        ...     \"weather\", \n        ...     [\"sunny\", \"rainy\"],\n        ...     np.array([0.8, 0.6], dtype=complex)\n        ... )\n    \"\"\"\n</code></pre>"},{"location":"contributing/setup/#error-handling","title":"Error Handling","text":"<p>Use custom exceptions for quantum-specific errors:</p> <pre><code>from probabilistic_quantum_reasoner.core.exceptions import (\n    QuantumStateError,\n    EntanglementError,\n    BackendError\n)\n\ndef normalize_quantum_state(amplitudes: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Normalize quantum state amplitudes.\"\"\"\n    norm_squared = np.sum(np.abs(amplitudes) ** 2)\n\n    if norm_squared == 0:\n        raise QuantumStateError(\"Cannot normalize zero state\")\n\n    return amplitudes / np.sqrt(norm_squared)\n</code></pre>"},{"location":"contributing/setup/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"contributing/setup/#test-structure","title":"Test Structure","text":"<p>Organize tests by component:</p> <pre><code>tests/\n\u251c\u2500\u2500 conftest.py              # Test fixtures and utilities\n\u251c\u2500\u2500 test_operators.py        # Quantum operator tests\n\u251c\u2500\u2500 test_nodes.py           # Node type tests\n\u251c\u2500\u2500 test_network.py         # Network functionality tests\n\u251c\u2500\u2500 test_inference.py       # Inference algorithm tests\n\u251c\u2500\u2500 test_backends.py        # Backend tests\n\u2514\u2500\u2500 integration/            # Integration tests\n    \u251c\u2500\u2500 test_examples.py    # Example tests\n    \u2514\u2500\u2500 test_workflows.py   # End-to-end tests\n</code></pre>"},{"location":"contributing/setup/#quantum-test-utilities","title":"Quantum Test Utilities","text":"<p>Use our quantum testing utilities:</p> <pre><code>from tests.conftest import (\n    assert_quantum_state_equal,\n    assert_probability_distribution_valid,\n    QuantumTestUtils\n)\n\ndef test_quantum_gate():\n    \"\"\"Test quantum gate application.\"\"\"\n    gate = QuantumGate.hadamard()\n    state = np.array([1, 0], dtype=complex)\n    result = gate.apply(state)\n\n    expected = np.array([1/np.sqrt(2), 1/np.sqrt(2)], dtype=complex)\n    assert_quantum_state_equal(result, expected)\n</code></pre>"},{"location":"contributing/setup/#test-markers","title":"Test Markers","text":"<p>Use pytest markers to categorize tests:</p> <pre><code>import pytest\n\n@pytest.mark.quantum\ndef test_with_quantum_backend():\n    \"\"\"Test requiring quantum backend.\"\"\"\n    pass\n\n@pytest.mark.slow\ndef test_expensive_computation():\n    \"\"\"Long-running test.\"\"\"\n    pass\n\n@pytest.mark.integration\ndef test_end_to_end_workflow():\n    \"\"\"Integration test.\"\"\"\n    pass\n</code></pre>"},{"location":"contributing/setup/#parametrized-tests","title":"Parametrized Tests","text":"<p>Use parametrization for comprehensive testing:</p> <pre><code>@pytest.mark.parametrize(\"angle\", [0, np.pi/4, np.pi/2, np.pi])\ndef test_rotation_gate(angle):\n    \"\"\"Test rotation gate with different angles.\"\"\"\n    gate = QuantumGate.rotation_x(angle)\n    # Test implementation\n</code></pre>"},{"location":"contributing/setup/#documentation","title":"Documentation","text":""},{"location":"contributing/setup/#building-documentation","title":"Building Documentation","text":"<pre><code># Install documentation dependencies\npip install -e \".[docs]\"\n\n# Build documentation\nmkdocs serve\n\n# Build for production\nmkdocs build\n</code></pre>"},{"location":"contributing/setup/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Use MkDocs with Material theme</li> <li>Include code examples in docstrings</li> <li>Add mathematical notation with MathJax</li> <li>Create tutorials for new features</li> </ul>"},{"location":"contributing/setup/#adding-examples","title":"Adding Examples","text":"<p>When adding new examples:</p> <ol> <li>Create example file in <code>probabilistic_quantum_reasoner/examples/</code></li> <li>Add comprehensive docstrings and comments</li> <li>Create documentation page in <code>docs/examples/</code></li> <li>Add tests in <code>tests/integration/test_examples.py</code></li> </ol>"},{"location":"contributing/setup/#performance-considerations","title":"Performance Considerations","text":""},{"location":"contributing/setup/#classical-simulation-optimization","title":"Classical Simulation Optimization","text":"<ul> <li>Use NumPy vectorized operations</li> <li>Minimize state vector copying</li> <li>Implement lazy evaluation where possible</li> </ul> <pre><code># Good: Vectorized operation\namplitudes = np.array([...], dtype=complex)\nprobabilities = np.abs(amplitudes) ** 2\n\n# Avoid: Element-wise loops\nprobabilities = [abs(amp) ** 2 for amp in amplitudes]\n</code></pre>"},{"location":"contributing/setup/#quantum-backend-efficiency","title":"Quantum Backend Efficiency","text":"<ul> <li>Minimize quantum circuit depth</li> <li>Batch quantum operations</li> <li>Use approximate algorithms for large networks</li> </ul>"},{"location":"contributing/setup/#memory-management","title":"Memory Management","text":"<ul> <li>Clean up large quantum states</li> <li>Use sparse representations when appropriate</li> <li>Implement gradient checkpointing for large networks</li> </ul>"},{"location":"contributing/setup/#release-process","title":"Release Process","text":""},{"location":"contributing/setup/#version-management","title":"Version Management","text":"<p>We use semantic versioning (semver): - Major: Breaking API changes - Minor: New features, backwards compatible - Patch: Bug fixes</p>"},{"location":"contributing/setup/#release-checklist","title":"Release Checklist","text":"<ol> <li>Update version in <code>pyproject.toml</code> and <code>setup.py</code></li> <li>Update <code>CHANGELOG.md</code></li> <li>Run full test suite</li> <li>Build documentation</li> <li>Create release tag</li> <li>Deploy to PyPI</li> </ol>"},{"location":"contributing/setup/#continuous-integration","title":"Continuous Integration","text":"<p>Our CI pipeline includes: - Multi-platform testing (Linux, macOS, Windows) - Multiple Python versions (3.10, 3.11, 3.12) - Code quality checks - Documentation building - Security scanning</p>"},{"location":"contributing/setup/#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>GitHub Discussions: General questions and discussions</li> <li>Documentation: Comprehensive guides and API reference</li> <li>Email: quantum-reasoner@example.com for sensitive issues</li> </ul>"},{"location":"contributing/setup/#recognition","title":"Recognition","text":"<p>Contributors are recognized in: - <code>CONTRIBUTORS.md</code> file - Release notes - Documentation acknowledgments - Conference presentations</p> <p>Thank you for contributing to the quantum AI community! \ud83d\ude80</p>"},{"location":"contributing/testing/","title":"Testing Guidelines","text":"<p>This document outlines the testing strategy and guidelines for the Probabilistic Quantum Reasoner project.</p>"},{"location":"contributing/testing/#testing-philosophy","title":"Testing Philosophy","text":"<p>We follow a comprehensive testing approach that includes:</p> <ul> <li>Unit Tests: Test individual components in isolation</li> <li>Integration Tests: Test interactions between components</li> <li>End-to-End Tests: Test complete workflows</li> <li>Performance Tests: Benchmark and validate performance</li> <li>Quantum Tests: Validate quantum-specific functionality</li> </ul>"},{"location":"contributing/testing/#test-structure","title":"Test Structure","text":""},{"location":"contributing/testing/#test-organization","title":"Test Organization","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py                    # Shared fixtures and configuration\n\u251c\u2500\u2500 unit/                          # Unit tests\n\u2502   \u251c\u2500\u2500 test_core/\n\u2502   \u2502   \u251c\u2500\u2500 test_reasoner.py\n\u2502   \u2502   \u251c\u2500\u2500 test_networks.py\n\u2502   \u2502   \u2514\u2500\u2500 test_nodes.py\n\u2502   \u251c\u2500\u2500 test_backends/\n\u2502   \u2502   \u251c\u2500\u2500 test_classical.py\n\u2502   \u2502   \u251c\u2500\u2500 test_qiskit.py\n\u2502   \u2502   \u2514\u2500\u2500 test_pennylane.py\n\u2502   \u2514\u2500\u2500 test_inference/\n\u2502       \u251c\u2500\u2500 test_belief_propagation.py\n\u2502       \u2514\u2500\u2500 test_variational.py\n\u251c\u2500\u2500 integration/                   # Integration tests\n\u2502   \u251c\u2500\u2500 test_end_to_end.py\n\u2502   \u251c\u2500\u2500 test_backend_switching.py\n\u2502   \u2514\u2500\u2500 test_causal_workflows.py\n\u251c\u2500\u2500 performance/                   # Performance tests\n\u2502   \u251c\u2500\u2500 test_benchmarks.py\n\u2502   \u2514\u2500\u2500 test_scalability.py\n\u2514\u2500\u2500 quantum/                       # Quantum-specific tests\n    \u251c\u2500\u2500 test_quantum_networks.py\n    \u251c\u2500\u2500 test_entanglement.py\n    \u2514\u2500\u2500 test_quantum_algorithms.py\n</code></pre>"},{"location":"contributing/testing/#writing-tests","title":"Writing Tests","text":""},{"location":"contributing/testing/#test-fixtures","title":"Test Fixtures","text":"<p>Use pytest fixtures for reusable test components:</p> <pre><code># tests/conftest.py\nimport pytest\nimport numpy as np\nfrom probabilistic_quantum_reasoner import ProbabilisticQuantumReasoner\nfrom probabilistic_quantum_reasoner.networks import BayesianNetwork\nfrom probabilistic_quantum_reasoner.nodes import DiscreteNode, QuantumNode\n\n@pytest.fixture\ndef simple_classical_network():\n    \"\"\"Create a simple classical Bayesian network for testing.\"\"\"\n    network = BayesianNetwork(name=\"Simple Test Network\")\n\n    # Weather node\n    weather = DiscreteNode(\n        name=\"Weather\",\n        states=[\"sunny\", \"rainy\"],\n        prior=[0.7, 0.3]\n    )\n\n    # Mood node (depends on weather)\n    mood = DiscreteNode(\n        name=\"Mood\",\n        states=[\"happy\", \"sad\"],\n        parents=[weather],\n        cpt=np.array([\n            [0.8, 0.2],  # sunny -&gt; happy/sad\n            [0.3, 0.7]   # rainy -&gt; happy/sad\n        ])\n    )\n\n    network.add_nodes([weather, mood])\n    return network\n\n@pytest.fixture\ndef simple_quantum_network():\n    \"\"\"Create a simple quantum network for testing.\"\"\"\n    network = BayesianNetwork(name=\"Simple Quantum Network\")\n\n    # Quantum node in superposition\n    qubit = QuantumNode(\n        name=\"Qubit\",\n        num_qubits=1,\n        initial_state=\"superposition\"\n    )\n\n    network.add_node(qubit)\n    return network\n\n@pytest.fixture\ndef classical_reasoner():\n    \"\"\"Create a classical reasoner for testing.\"\"\"\n    return ProbabilisticQuantumReasoner(backend=\"classical\")\n\n@pytest.fixture(params=[\"classical\", \"qiskit\"])\ndef reasoner(request):\n    \"\"\"Parametrized reasoner fixture for testing multiple backends.\"\"\"\n    if request.param == \"qiskit\":\n        pytest.importorskip(\"qiskit\")\n\n    return ProbabilisticQuantumReasoner(backend=request.param)\n\n@pytest.fixture\ndef sample_evidence():\n    \"\"\"Sample evidence for testing.\"\"\"\n    return {\"Weather\": \"sunny\"}\n\n@pytest.fixture\ndef sample_query():\n    \"\"\"Sample query for testing.\"\"\"\n    return [\"Mood\"]\n</code></pre>"},{"location":"contributing/testing/#unit-test-examples","title":"Unit Test Examples","text":""},{"location":"contributing/testing/#testing-core-components","title":"Testing Core Components","text":"<pre><code># tests/unit/test_core/test_networks.py\nimport pytest\nimport numpy as np\nfrom probabilistic_quantum_reasoner.networks import BayesianNetwork\nfrom probabilistic_quantum_reasoner.nodes import DiscreteNode\n\nclass TestBayesianNetwork:\n    \"\"\"Test suite for BayesianNetwork class.\"\"\"\n\n    def test_network_creation(self):\n        \"\"\"Test basic network creation.\"\"\"\n        network = BayesianNetwork(name=\"Test Network\")\n        assert network.name == \"Test Network\"\n        assert len(network.nodes) == 0\n        assert len(network.edges) == 0\n\n    def test_add_single_node(self):\n        \"\"\"Test adding a single node to network.\"\"\"\n        network = BayesianNetwork()\n\n        node = DiscreteNode(\n            name=\"TestNode\",\n            states=[\"state1\", \"state2\"],\n            prior=[0.6, 0.4]\n        )\n\n        network.add_node(node)\n\n        assert len(network.nodes) == 1\n        assert \"TestNode\" in network.nodes\n        assert network.nodes[\"TestNode\"] == node\n\n    def test_add_multiple_nodes(self):\n        \"\"\"Test adding multiple nodes at once.\"\"\"\n        network = BayesianNetwork()\n\n        node1 = DiscreteNode(name=\"Node1\", states=[\"a\", \"b\"], prior=[0.5, 0.5])\n        node2 = DiscreteNode(name=\"Node2\", states=[\"x\", \"y\"], prior=[0.3, 0.7])\n\n        network.add_nodes([node1, node2])\n\n        assert len(network.nodes) == 2\n        assert \"Node1\" in network.nodes\n        assert \"Node2\" in network.nodes\n\n    def test_node_dependencies(self, simple_classical_network):\n        \"\"\"Test that node dependencies are correctly established.\"\"\"\n        network = simple_classical_network\n\n        weather_node = network.nodes[\"Weather\"]\n        mood_node = network.nodes[\"Mood\"]\n\n        assert len(mood_node.parents) == 1\n        assert mood_node.parents[0] == weather_node\n        assert len(network.edges) == 1\n\n    def test_invalid_node_addition(self):\n        \"\"\"Test that invalid node additions raise appropriate errors.\"\"\"\n        network = BayesianNetwork()\n\n        # Add initial node\n        node1 = DiscreteNode(name=\"Node1\", states=[\"a\", \"b\"], prior=[0.5, 0.5])\n        network.add_node(node1)\n\n        # Try to add node with same name\n        node2 = DiscreteNode(name=\"Node1\", states=[\"x\", \"y\"], prior=[0.3, 0.7])\n\n        with pytest.raises(ValueError, match=\"already exists\"):\n            network.add_node(node2)\n\n    def test_network_validation(self, simple_classical_network):\n        \"\"\"Test network validation.\"\"\"\n        network = simple_classical_network\n\n        # Valid network should pass validation\n        assert network.validate()\n\n        # Create invalid network (circular dependency)\n        weather = network.nodes[\"Weather\"]\n        mood = network.nodes[\"Mood\"]\n\n        # This would create a cycle: Weather -&gt; Mood -&gt; Weather\n        weather.parents = [mood]\n\n        with pytest.raises(ValueError, match=\"circular\"):\n            network.validate()\n</code></pre>"},{"location":"contributing/testing/#testing-inference-algorithms","title":"Testing Inference Algorithms","text":"<pre><code># tests/unit/test_inference/test_belief_propagation.py\nimport pytest\nimport numpy as np\nfrom probabilistic_quantum_reasoner.inference import BeliefPropagation\n\nclass TestBeliefPropagation:\n    \"\"\"Test suite for Belief Propagation algorithm.\"\"\"\n\n    def test_exact_inference(self, simple_classical_network, classical_reasoner):\n        \"\"\"Test exact inference on simple network.\"\"\"\n        network = simple_classical_network\n\n        # Test inference without evidence\n        result = classical_reasoner.infer(\n            network=network,\n            query=[\"Mood\"],\n            evidence={}\n        )\n\n        # Check result structure\n        assert \"Mood\" in result\n        assert \"happy\" in result[\"Mood\"]\n        assert \"sad\" in result[\"Mood\"]\n\n        # Check probabilities sum to 1\n        prob_sum = sum(result[\"Mood\"].values())\n        assert abs(prob_sum - 1.0) &lt; 1e-10\n\n        # Check that probabilities are positive\n        for prob in result[\"Mood\"].values():\n            assert prob &gt;= 0\n\n    def test_inference_with_evidence(self, simple_classical_network, classical_reasoner):\n        \"\"\"Test inference with evidence.\"\"\"\n        network = simple_classical_network\n\n        # Test with sunny weather evidence\n        result_sunny = classical_reasoner.infer(\n            network=network,\n            query=[\"Mood\"],\n            evidence={\"Weather\": \"sunny\"}\n        )\n\n        # Test with rainy weather evidence\n        result_rainy = classical_reasoner.infer(\n            network=network,\n            query=[\"Mood\"],\n            evidence={\"Weather\": \"rainy\"}\n        )\n\n        # With sunny weather, should be more likely to be happy\n        assert result_sunny[\"Mood\"][\"happy\"] &gt; result_rainy[\"Mood\"][\"happy\"]\n        assert result_sunny[\"Mood\"][\"sad\"] &lt; result_rainy[\"Mood\"][\"sad\"]\n\n    def test_multiple_queries(self, simple_classical_network, classical_reasoner):\n        \"\"\"Test inference with multiple query variables.\"\"\"\n        network = simple_classical_network\n\n        result = classical_reasoner.infer(\n            network=network,\n            query=[\"Weather\", \"Mood\"],\n            evidence={}\n        )\n\n        assert \"Weather\" in result\n        assert \"Mood\" in result\n\n        # Check that each variable's probabilities sum to 1\n        for var in [\"Weather\", \"Mood\"]:\n            prob_sum = sum(result[var].values())\n            assert abs(prob_sum - 1.0) &lt; 1e-10\n\n    def test_convergence(self):\n        \"\"\"Test that belief propagation converges.\"\"\"\n        bp = BeliefPropagation(max_iterations=100, tolerance=1e-6)\n\n        # Test with a more complex network\n        network = self._create_complex_network()\n\n        result = bp.infer(\n            network=network,\n            query=[\"Target\"],\n            evidence={}\n        )\n\n        # Should converge and return valid probabilities\n        assert isinstance(result, dict)\n        assert \"Target\" in result\n\n    def _create_complex_network(self):\n        \"\"\"Helper method to create a more complex test network.\"\"\"\n        from probabilistic_quantum_reasoner.networks import BayesianNetwork\n        from probabilistic_quantum_reasoner.nodes import DiscreteNode\n\n        network = BayesianNetwork(name=\"Complex Test Network\")\n\n        # Create chain of dependencies: A -&gt; B -&gt; C -&gt; D\n        node_a = DiscreteNode(name=\"A\", states=[\"0\", \"1\"], prior=[0.5, 0.5])\n\n        node_b = DiscreteNode(\n            name=\"B\", \n            states=[\"0\", \"1\"],\n            parents=[node_a],\n            cpt=np.array([[0.8, 0.2], [0.3, 0.7]])\n        )\n\n        node_c = DiscreteNode(\n            name=\"C\",\n            states=[\"0\", \"1\"], \n            parents=[node_b],\n            cpt=np.array([[0.9, 0.1], [0.2, 0.8]])\n        )\n\n        node_d = DiscreteNode(\n            name=\"Target\",\n            states=[\"0\", \"1\"],\n            parents=[node_c],\n            cpt=np.array([[0.7, 0.3], [0.4, 0.6]])\n        )\n\n        network.add_nodes([node_a, node_b, node_c, node_d])\n        return network\n</code></pre>"},{"location":"contributing/testing/#testing-quantum-components","title":"Testing Quantum Components","text":"<pre><code># tests/quantum/test_quantum_networks.py\nimport pytest\nimport numpy as np\nfrom probabilistic_quantum_reasoner.nodes import QuantumNode\nfrom probabilistic_quantum_reasoner.quantum_ops import HadamardGate, CNOTGate\n\n@pytest.mark.quantum\nclass TestQuantumNetworks:\n    \"\"\"Test suite for quantum network functionality.\"\"\"\n\n    @pytest.fixture\n    def quantum_reasoner(self):\n        \"\"\"Create quantum reasoner (skip if backends unavailable).\"\"\"\n        qiskit = pytest.importorskip(\"qiskit\")\n        from probabilistic_quantum_reasoner import ProbabilisticQuantumReasoner\n        return ProbabilisticQuantumReasoner(backend=\"qiskit\")\n\n    def test_single_qubit_operations(self, quantum_reasoner):\n        \"\"\"Test single qubit quantum operations.\"\"\"\n        from probabilistic_quantum_reasoner.networks import BayesianNetwork\n\n        network = BayesianNetwork(name=\"Single Qubit Test\")\n\n        # Create qubit in |0\u27e9 state\n        qubit = QuantumNode(\n            name=\"Qubit\",\n            num_qubits=1,\n            initial_state=\"zero\"\n        )\n\n        network.add_node(qubit)\n\n        # Measure without any operations - should always be |0\u27e9\n        measurements = []\n        for _ in range(100):\n            result = quantum_reasoner.measure(network, [\"Qubit\"])\n            measurements.append(result[\"Qubit\"])\n\n        # All measurements should be |0\u27e9 (or equivalent)\n        assert all(m in [\"0\", \"zero\", False] for m in measurements)\n\n    def test_hadamard_superposition(self, quantum_reasoner):\n        \"\"\"Test Hadamard gate creates superposition.\"\"\"\n        from probabilistic_quantum_reasoner.networks import BayesianNetwork\n\n        network = BayesianNetwork(name=\"Hadamard Test\")\n\n        # Create qubit and apply Hadamard\n        qubit = QuantumNode(\n            name=\"Qubit\",\n            num_qubits=1,\n            initial_state=\"zero\",\n            quantum_operations=[HadamardGate(qubit=0)]\n        )\n\n        network.add_node(qubit)\n\n        # Measure many times - should get ~50/50 distribution\n        measurements = []\n        for _ in range(1000):\n            result = quantum_reasoner.measure(network, [\"Qubit\"])\n            measurements.append(result[\"Qubit\"])\n\n        # Count 0s and 1s\n        zero_count = sum(1 for m in measurements if m in [\"0\", \"zero\", False])\n        one_count = sum(1 for m in measurements if m in [\"1\", \"one\", True])\n\n        total = zero_count + one_count\n        zero_ratio = zero_count / total\n\n        # Should be approximately 50% (within 5% tolerance)\n        assert 0.45 &lt;= zero_ratio &lt;= 0.55\n\n    def test_entanglement(self, quantum_reasoner):\n        \"\"\"Test quantum entanglement between qubits.\"\"\"\n        from probabilistic_quantum_reasoner.networks import BayesianNetwork\n\n        network = BayesianNetwork(name=\"Entanglement Test\")\n\n        # Create Bell state: |00\u27e9 + |11\u27e9\n        qubit_a = QuantumNode(name=\"QubitA\", num_qubits=1, initial_state=\"zero\")\n        qubit_b = QuantumNode(name=\"QubitB\", num_qubits=1, initial_state=\"zero\")\n\n        bell_state = QuantumNode(\n            name=\"BellState\",\n            num_qubits=2,\n            parents=[qubit_a, qubit_b],\n            quantum_operations=[\n                HadamardGate(qubit=0),\n                CNOTGate(control_qubit=0, target_qubit=1)\n            ]\n        )\n\n        network.add_nodes([qubit_a, qubit_b, bell_state])\n\n        # Measure correlations\n        correlations = []\n        for _ in range(1000):\n            result = quantum_reasoner.measure(network, [\"QubitA\", \"QubitB\"])\n            a_result = result[\"QubitA\"]\n            b_result = result[\"QubitB\"]\n\n            # Convert to binary for comparison\n            a_binary = 1 if a_result in [\"1\", \"one\", True] else 0\n            b_binary = 1 if b_result in [\"1\", \"one\", True] else 0\n\n            correlations.append(a_binary == b_binary)\n\n        # Bell state should have perfect correlation\n        correlation_rate = np.mean(correlations)\n        assert correlation_rate &gt; 0.95  # Allow for measurement noise\n\n    @pytest.mark.slow\n    def test_quantum_inference_scaling(self, quantum_reasoner):\n        \"\"\"Test quantum inference scales reasonably with system size.\"\"\"\n        import time\n\n        times = []\n        qubit_counts = [1, 2, 3, 4]\n\n        for num_qubits in qubit_counts:\n            network = self._create_quantum_network(num_qubits)\n\n            start_time = time.time()\n\n            # Perform multiple measurements\n            for _ in range(10):\n                quantum_reasoner.measure(network, [f\"Qubit_{i}\" for i in range(num_qubits)])\n\n            end_time = time.time()\n            times.append(end_time - start_time)\n\n        # Time should not grow exponentially (for small qubit counts)\n        # This is a basic sanity check\n        assert times[-1] &lt; times[0] * 100  # Allow 100x slowdown max\n\n    def _create_quantum_network(self, num_qubits):\n        \"\"\"Helper to create quantum network with specified number of qubits.\"\"\"\n        from probabilistic_quantum_reasoner.networks import BayesianNetwork\n\n        network = BayesianNetwork(name=f\"Quantum Network {num_qubits} qubits\")\n\n        qubits = []\n        for i in range(num_qubits):\n            qubit = QuantumNode(\n                name=f\"Qubit_{i}\",\n                num_qubits=1,\n                initial_state=\"superposition\"\n            )\n            qubits.append(qubit)\n\n        network.add_nodes(qubits)\n        return network\n</code></pre>"},{"location":"contributing/testing/#integration-tests","title":"Integration Tests","text":"<pre><code># tests/integration/test_end_to_end.py\nimport pytest\nfrom probabilistic_quantum_reasoner import ProbabilisticQuantumReasoner\nfrom probabilistic_quantum_reasoner.examples import WeatherMoodNetwork\n\nclass TestEndToEnd:\n    \"\"\"End-to-end integration tests.\"\"\"\n\n    @pytest.mark.parametrize(\"backend\", [\"classical\", \"qiskit\"])\n    def test_complete_workflow(self, backend):\n        \"\"\"Test complete workflow from network creation to inference.\"\"\"\n        if backend == \"qiskit\":\n            pytest.importorskip(\"qiskit\")\n\n        # Create example network\n        weather_network = WeatherMoodNetwork()\n        network = weather_network.create_network()\n\n        # Create reasoner\n        reasoner = ProbabilisticQuantumReasoner(backend=backend)\n\n        # Perform inference\n        result = reasoner.infer(\n            network=network,\n            query=[\"Mood\"],\n            evidence={\"Weather\": \"sunny\"}\n        )\n\n        # Validate result\n        assert isinstance(result, dict)\n        assert \"Mood\" in result\n        assert abs(sum(result[\"Mood\"].values()) - 1.0) &lt; 1e-10\n\n    def test_backend_switching(self):\n        \"\"\"Test switching between different backends.\"\"\"\n        network = WeatherMoodNetwork().create_network()\n\n        # Start with classical\n        reasoner = ProbabilisticQuantumReasoner(backend=\"classical\")\n        classical_result = reasoner.infer(\n            network=network,\n            query=[\"Mood\"],\n            evidence={\"Weather\": \"sunny\"}\n        )\n\n        # Switch to quantum (if available)\n        try:\n            reasoner.set_backend(\"qiskit\")\n            quantum_result = reasoner.infer(\n                network=network,\n                query=[\"Mood\"],\n                evidence={\"Weather\": \"sunny\"}\n            )\n\n            # Results should be similar (within tolerance)\n            for state in classical_result[\"Mood\"]:\n                classical_prob = classical_result[\"Mood\"][state]\n                quantum_prob = quantum_result[\"Mood\"][state]\n                assert abs(classical_prob - quantum_prob) &lt; 0.1\n\n        except ImportError:\n            pytest.skip(\"Quantum backends not available\")\n\n    def test_error_handling(self):\n        \"\"\"Test error handling in complete workflows.\"\"\"\n        reasoner = ProbabilisticQuantumReasoner(backend=\"classical\")\n        network = WeatherMoodNetwork().create_network()\n\n        # Test invalid query\n        with pytest.raises(ValueError):\n            reasoner.infer(\n                network=network,\n                query=[\"NonexistentNode\"],\n                evidence={}\n            )\n\n        # Test invalid evidence\n        with pytest.raises(ValueError):\n            reasoner.infer(\n                network=network,\n                query=[\"Mood\"],\n                evidence={\"NonexistentNode\": \"value\"}\n            )\n</code></pre>"},{"location":"contributing/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"contributing/testing/#benchmarking","title":"Benchmarking","text":"<pre><code># tests/performance/test_benchmarks.py\nimport pytest\nimport time\nimport numpy as np\nfrom probabilistic_quantum_reasoner import ProbabilisticQuantumReasoner\n\n@pytest.mark.performance\nclass TestBenchmarks:\n    \"\"\"Performance benchmark tests.\"\"\"\n\n    @pytest.mark.parametrize(\"network_size\", [10, 25, 50])\n    @pytest.mark.parametrize(\"backend\", [\"classical\"])\n    def test_inference_scaling(self, network_size, backend):\n        \"\"\"Test inference time scaling with network size.\"\"\"\n        network = self._create_test_network(network_size)\n        reasoner = ProbabilisticQuantumReasoner(backend=backend)\n\n        # Warm up\n        reasoner.infer(network=network, query=[\"node_0\"], evidence={})\n\n        # Benchmark\n        start_time = time.time()\n\n        for _ in range(10):  # Multiple runs for average\n            result = reasoner.infer(\n                network=network,\n                query=[\"node_0\"],\n                evidence={}\n            )\n\n        end_time = time.time()\n        avg_time = (end_time - start_time) / 10\n\n        # Performance assertions (adjust based on acceptable performance)\n        if network_size == 10:\n            assert avg_time &lt; 0.1  # 100ms for small network\n        elif network_size == 25:\n            assert avg_time &lt; 0.5  # 500ms for medium network\n        elif network_size == 50:\n            assert avg_time &lt; 2.0  # 2s for large network\n\n    def test_memory_usage(self):\n        \"\"\"Test memory usage stays within bounds.\"\"\"\n        import psutil\n        import os\n\n        process = psutil.Process(os.getpid())\n        initial_memory = process.memory_info().rss / 1024 / 1024  # MB\n\n        # Create large network\n        network = self._create_test_network(100)\n        reasoner = ProbabilisticQuantumReasoner(backend=\"classical\")\n\n        # Perform inference\n        reasoner.infer(network=network, query=[\"node_0\"], evidence={})\n\n        final_memory = process.memory_info().rss / 1024 / 1024  # MB\n        memory_increase = final_memory - initial_memory\n\n        # Memory increase should be reasonable (adjust threshold as needed)\n        assert memory_increase &lt; 500  # Less than 500MB increase\n\n    def _create_test_network(self, size):\n        \"\"\"Create test network of specified size.\"\"\"\n        from probabilistic_quantum_reasoner.networks import BayesianNetwork\n        from probabilistic_quantum_reasoner.nodes import DiscreteNode\n\n        network = BayesianNetwork(name=f\"Test Network Size {size}\")\n\n        # Create chain of nodes\n        previous_node = None\n        for i in range(size):\n            if i == 0:\n                # Root node\n                node = DiscreteNode(\n                    name=f\"node_{i}\",\n                    states=[\"true\", \"false\"],\n                    prior=[0.5, 0.5]\n                )\n            else:\n                # Dependent node\n                node = DiscreteNode(\n                    name=f\"node_{i}\",\n                    states=[\"true\", \"false\"],\n                    parents=[previous_node],\n                    cpt=np.array([[0.8, 0.2], [0.3, 0.7]])\n                )\n\n            network.add_node(node)\n            previous_node = node\n\n        return network\n</code></pre>"},{"location":"contributing/testing/#test-configuration","title":"Test Configuration","text":""},{"location":"contributing/testing/#pytest-configuration","title":"pytest Configuration","text":"<pre><code># tests/conftest.py (additional configuration)\nimport pytest\nimport warnings\n\ndef pytest_configure(config):\n    \"\"\"Configure pytest.\"\"\"\n    # Add custom markers\n    config.addinivalue_line(\n        \"markers\", \"slow: marks tests as slow (deselect with '-m \\\"not slow\\\"')\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"quantum: marks tests that require quantum backends\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"performance: marks performance benchmark tests\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"integration: marks integration tests\"\n    )\n    config.addinivalue_line(\n        \"markers\", \"gpu: marks tests that require GPU acceleration\"\n    )\n\ndef pytest_collection_modifyitems(config, items):\n    \"\"\"Modify test collection.\"\"\"\n    # Skip quantum tests if backends not available\n    try:\n        import qiskit\n        quantum_available = True\n    except ImportError:\n        quantum_available = False\n\n    if not quantum_available:\n        skip_quantum = pytest.mark.skip(reason=\"Quantum backends not available\")\n        for item in items:\n            if \"quantum\" in item.keywords:\n                item.add_marker(skip_quantum)\n\n@pytest.fixture(autouse=True)\ndef suppress_warnings():\n    \"\"\"Suppress known warnings during tests.\"\"\"\n    warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n    warnings.filterwarnings(\"ignore\", category=PendingDeprecationWarning)\n</code></pre>"},{"location":"contributing/testing/#running-tests","title":"Running Tests","text":""},{"location":"contributing/testing/#basic-test-commands","title":"Basic Test Commands","text":"<pre><code># Run all tests\npytest\n\n# Run tests with coverage\npytest --cov=probabilistic_quantum_reasoner --cov-report=html\n\n# Run specific test categories\npytest -m \"not slow\"           # Skip slow tests\npytest -m quantum              # Only quantum tests\npytest -m \"performance\"        # Only performance tests\n\n# Run tests in parallel\npytest -n auto                # Use all CPU cores\n\n# Run with verbose output\npytest -v\n\n# Stop on first failure\npytest -x\n\n# Run specific test file\npytest tests/unit/test_core/test_reasoner.py\n\n# Run specific test function\npytest tests/unit/test_core/test_reasoner.py::test_basic_functionality\n</code></pre>"},{"location":"contributing/testing/#continuous-integration","title":"Continuous Integration","text":"<p>Example GitHub Actions workflow:</p> <pre><code># .github/workflows/test.yml\nname: Test Suite\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [3.10, 3.11, 3.12]\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -e \".[dev,test]\"\n\n    - name: Run tests\n      run: |\n        pytest --cov=probabilistic_quantum_reasoner --cov-report=xml\n\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage.xml\n</code></pre>"},{"location":"contributing/testing/#best-practices","title":"Best Practices","text":""},{"location":"contributing/testing/#test-writing-guidelines","title":"Test Writing Guidelines","text":"<ol> <li>Clear test names: Use descriptive names that explain what is being tested</li> <li>Arrange-Act-Assert: Structure tests with clear setup, execution, and verification</li> <li>Test one thing: Each test should verify one specific behavior</li> <li>Use fixtures: Leverage pytest fixtures for reusable test components</li> <li>Mock external dependencies: Use mocking for external services or hardware</li> <li>Test edge cases: Include tests for boundary conditions and error cases</li> </ol>"},{"location":"contributing/testing/#coverage-guidelines","title":"Coverage Guidelines","text":"<ul> <li>Aim for 90%+ code coverage for core components</li> <li>100% coverage for critical inference algorithms</li> <li>Focus on meaningful coverage rather than just line coverage</li> <li>Test both happy paths and error conditions</li> </ul>"},{"location":"contributing/testing/#performance-testing_1","title":"Performance Testing","text":"<ul> <li>Include performance benchmarks in the test suite</li> <li>Set reasonable performance thresholds based on hardware</li> <li>Test memory usage and resource consumption</li> <li>Benchmark different backends and configurations</li> </ul> <p>This comprehensive testing strategy ensures the reliability, performance, and correctness of the Probabilistic Quantum Reasoner across all supported platforms and use cases.</p>"},{"location":"examples/prisoners-dilemma/","title":"Game Theory: Prisoner's Dilemma with Quantum Strategies","text":"<p>This example explores the famous Prisoner's Dilemma using quantum game theory concepts within the Probabilistic Quantum Reasoner framework. We'll demonstrate how quantum superposition and entanglement can change the strategic landscape of classical games.</p>"},{"location":"examples/prisoners-dilemma/#classical-prisoners-dilemma","title":"Classical Prisoner's Dilemma","text":"<p>First, let's implement the classical version to establish a baseline:</p> <pre><code>import numpy as np\nfrom probabilistic_quantum_reasoner import ProbabilisticQuantumReasoner\nfrom probabilistic_quantum_reasoner.networks import BayesianNetwork\nfrom probabilistic_quantum_reasoner.nodes import DiscreteNode, QuantumNode\nfrom probabilistic_quantum_reasoner.quantum_ops import HadamardGate, CNOTGate, ParameterizedGate\n\ndef create_classical_prisoners_dilemma():\n    \"\"\"Create a classical Prisoner's Dilemma game.\"\"\"\n\n    network = BayesianNetwork(name=\"Classical Prisoner's Dilemma\")\n\n    # Player strategies: Cooperate or Defect\n    player1_strategy = DiscreteNode(\n        name=\"Player1_Strategy\",\n        states=[\"cooperate\", \"defect\"],\n        prior=[0.5, 0.5]  # Initially random strategy\n    )\n\n    player2_strategy = DiscreteNode(\n        name=\"Player2_Strategy\", \n        states=[\"cooperate\", \"defect\"],\n        prior=[0.5, 0.5]\n    )\n\n    # Payoff matrix for Player 1\n    # Rows: Player1's choice, Columns: Player2's choice\n    # (C,C): 3,3  (C,D): 0,5  (D,C): 5,0  (D,D): 1,1\n    player1_payoff_cpt = np.array([\n        # P1=C, P2=C -&gt; Payoff levels [low, medium, high]\n        [0.0, 0.0, 1.0],  # Reward for mutual cooperation (3 points)\n        # P1=C, P2=D -&gt; Sucker's payoff\n        [1.0, 0.0, 0.0],  # Lowest payoff (0 points)\n        # P1=D, P2=C -&gt; Temptation payoff  \n        [0.0, 0.0, 1.0],  # Highest payoff (5 points) - actually should be higher\n        # P1=D, P2=D -&gt; Punishment\n        [0.0, 1.0, 0.0]   # Low payoff (1 point)\n    ])\n\n    player1_payoff = DiscreteNode(\n        name=\"Player1_Payoff\",\n        states=[\"low\", \"medium\", \"high\"],\n        parents=[player1_strategy, player2_strategy],\n        cpt=player1_payoff_cpt\n    )\n\n    # Symmetric payoff for Player 2\n    player2_payoff_cpt = np.array([\n        # P1=C, P2=C -&gt; Both get reward\n        [0.0, 0.0, 1.0],\n        # P1=C, P2=D -&gt; P2 gets temptation\n        [0.0, 0.0, 1.0],  \n        # P1=D, P2=C -&gt; P2 gets sucker's payoff\n        [1.0, 0.0, 0.0],\n        # P1=D, P2=D -&gt; Both get punishment\n        [0.0, 1.0, 0.0]\n    ])\n\n    player2_payoff = DiscreteNode(\n        name=\"Player2_Payoff\",\n        states=[\"low\", \"medium\", \"high\"], \n        parents=[player1_strategy, player2_strategy],\n        cpt=player2_payoff_cpt\n    )\n\n    network.add_nodes([\n        player1_strategy, player2_strategy,\n        player1_payoff, player2_payoff\n    ])\n\n    return network\n\ndef analyze_classical_game():\n    \"\"\"Analyze the classical Prisoner's Dilemma outcomes.\"\"\"\n\n    network = create_classical_prisoners_dilemma()\n    reasoner = ProbabilisticQuantumReasoner(backend=\"classical\")\n\n    strategies = [\"cooperate\", \"defect\"]\n    outcomes = {}\n\n    print(\"Classical Prisoner's Dilemma Analysis:\")\n    print(\"P1 Strategy\\tP2 Strategy\\tP1 Payoff\\tP2 Payoff\")\n    print(\"-\" * 50)\n\n    for p1_strat in strategies:\n        for p2_strat in strategies:\n            evidence = {\n                \"Player1_Strategy\": p1_strat,\n                \"Player2_Strategy\": p2_strat\n            }\n\n            result = reasoner.infer(\n                network=network,\n                query=[\"Player1_Payoff\", \"Player2_Payoff\"],\n                evidence=evidence\n            )\n\n            # Get most likely payoff\n            p1_payoff = max(result[\"Player1_Payoff\"], key=result[\"Player1_Payoff\"].get)\n            p2_payoff = max(result[\"Player2_Payoff\"], key=result[\"Player2_Payoff\"].get)\n\n            outcomes[(p1_strat, p2_strat)] = (p1_payoff, p2_payoff)\n\n            print(f\"{p1_strat[:4]}\\t\\t{p2_strat[:4]}\\t\\t{p1_payoff}\\t{p2_payoff}\")\n\n    return outcomes\n\n# Run classical analysis\nclassical_outcomes = analyze_classical_game()\n</code></pre>"},{"location":"examples/prisoners-dilemma/#quantum-prisoners-dilemma","title":"Quantum Prisoner's Dilemma","text":"<p>Now let's implement the quantum version where players can use quantum strategies:</p> <pre><code>def create_quantum_prisoners_dilemma(entanglement_strength=0.5):\n    \"\"\"\n    Create a quantum Prisoner's Dilemma with entangled initial state.\n\n    Args:\n        entanglement_strength: Amount of initial entanglement between players\n    \"\"\"\n\n    network = BayesianNetwork(name=\"Quantum Prisoner's Dilemma\")\n\n    # Quantum strategy nodes - players can be in superposition\n    player1_quantum = QuantumNode(\n        name=\"Player1_Quantum\",\n        num_qubits=1,\n        initial_state=\"zero\"  # Start in |0\u27e9 (cooperate)\n    )\n\n    player2_quantum = QuantumNode(\n        name=\"Player2_Quantum\", \n        num_qubits=1,\n        initial_state=\"zero\"  # Start in |0\u27e9 (cooperate)\n    )\n\n    # Entanglement node - creates initial correlation\n    entanglement_node = QuantumNode(\n        name=\"Entanglement\",\n        num_qubits=2,\n        parents=[player1_quantum, player2_quantum],\n        quantum_operations=[\n            # Create entangled state based on strength parameter\n            HadamardGate(qubit=0),  # Put player 1 in superposition\n            ParameterizedGate(\n                gate_type=\"RY\",  # Rotation around Y-axis\n                qubit=1,\n                parameter=entanglement_strength * np.pi\n            ),\n            CNOTGate(control_qubit=0, target_qubit=1)  # Entangle players\n        ]\n    )\n\n    # Quantum strategy application nodes\n    player1_strategy_quantum = QuantumNode(\n        name=\"Player1_Strategy_Quantum\",\n        num_qubits=1,\n        parents=[entanglement_node],\n        quantum_operations=[\n            # Player 1 can apply quantum strategy\n            ParameterizedGate(\n                gate_type=\"RY\",\n                qubit=0, \n                parameter=\"strategy_param_1\"  # Learned parameter\n            )\n        ]\n    )\n\n    player2_strategy_quantum = QuantumNode(\n        name=\"Player2_Strategy_Quantum\",\n        num_qubits=1,\n        parents=[entanglement_node],\n        quantum_operations=[\n            # Player 2 can apply quantum strategy\n            ParameterizedGate(\n                gate_type=\"RY\",\n                qubit=1,\n                parameter=\"strategy_param_2\"  # Learned parameter\n            )\n        ]\n    )\n\n    # Measurement nodes - convert quantum states to classical outcomes\n    player1_measurement = DiscreteNode(\n        name=\"Player1_Action\",\n        states=[\"cooperate\", \"defect\"],\n        parents=[player1_strategy_quantum],\n        # Measurement probability based on quantum amplitudes\n        cpt=np.array([\n            [1.0, 0.0],  # |0\u27e9 -&gt; cooperate with probability 1\n            [0.0, 1.0]   # |1\u27e9 -&gt; defect with probability 1  \n        ])\n    )\n\n    player2_measurement = DiscreteNode(\n        name=\"Player2_Action\",\n        states=[\"cooperate\", \"defect\"],\n        parents=[player2_strategy_quantum],\n        cpt=np.array([\n            [1.0, 0.0],  # |0\u27e9 -&gt; cooperate\n            [0.0, 1.0]   # |1\u27e9 -&gt; defect\n        ])\n    )\n\n    # Payoff calculation (same as classical)\n    player1_payoff = DiscreteNode(\n        name=\"Player1_Quantum_Payoff\",\n        states=[\"low\", \"medium\", \"high\"],\n        parents=[player1_measurement, player2_measurement],\n        cpt=np.array([\n            [0.0, 0.0, 1.0],  # (C,C) -&gt; high\n            [1.0, 0.0, 0.0],  # (C,D) -&gt; low\n            [0.0, 0.0, 1.0],  # (D,C) -&gt; high (temptation)\n            [0.0, 1.0, 0.0]   # (D,D) -&gt; medium\n        ])\n    )\n\n    player2_payoff = DiscreteNode(\n        name=\"Player2_Quantum_Payoff\", \n        states=[\"low\", \"medium\", \"high\"],\n        parents=[player1_measurement, player2_measurement],\n        cpt=np.array([\n            [0.0, 0.0, 1.0],  # (C,C) -&gt; high\n            [0.0, 0.0, 1.0],  # (C,D) -&gt; high (temptation)\n            [1.0, 0.0, 0.0],  # (D,C) -&gt; low\n            [0.0, 1.0, 0.0]   # (D,D) -&gt; medium\n        ])\n    )\n\n    network.add_nodes([\n        player1_quantum, player2_quantum, entanglement_node,\n        player1_strategy_quantum, player2_strategy_quantum,\n        player1_measurement, player2_measurement,\n        player1_payoff, player2_payoff\n    ])\n\n    return network\n\ndef simulate_quantum_game(entanglement_levels, num_trials=1000):\n    \"\"\"Simulate quantum Prisoner's Dilemma for different entanglement levels.\"\"\"\n\n    results = {}\n\n    for entanglement in entanglement_levels:\n        print(f\"\\nSimulating with entanglement strength: {entanglement:.2f}\")\n\n        network = create_quantum_prisoners_dilemma(entanglement)\n        reasoner = ProbabilisticQuantumReasoner(backend=\"qiskit\")\n\n        cooperation_rate = 0\n        mutual_cooperation_rate = 0\n\n        for trial in range(num_trials):\n            # Measure quantum strategies\n            measurement = reasoner.measure(\n                network=network,\n                nodes=[\"Player1_Action\", \"Player2_Action\"]\n            )\n\n            p1_action = measurement[\"Player1_Action\"]\n            p2_action = measurement[\"Player2_Action\"]\n\n            if p1_action == \"cooperate\":\n                cooperation_rate += 0.5  # Each player contributes 0.5\n            if p2_action == \"cooperate\":\n                cooperation_rate += 0.5\n\n            if p1_action == \"cooperate\" and p2_action == \"cooperate\":\n                mutual_cooperation_rate += 1\n\n        cooperation_rate /= num_trials\n        mutual_cooperation_rate /= num_trials\n\n        results[entanglement] = {\n            \"cooperation_rate\": cooperation_rate,\n            \"mutual_cooperation_rate\": mutual_cooperation_rate\n        }\n\n        print(f\"  Cooperation rate: {cooperation_rate:.3f}\")\n        print(f\"  Mutual cooperation rate: {mutual_cooperation_rate:.3f}\")\n\n    return results\n\n# Simulate for different entanglement levels\nentanglement_levels = [0.0, 0.25, 0.5, 0.75, 1.0]\nquantum_results = simulate_quantum_game(entanglement_levels)\n</code></pre>"},{"location":"examples/prisoners-dilemma/#evolutionary-quantum-strategies","title":"Evolutionary Quantum Strategies","text":"<p>Let's implement an evolutionary approach where quantum strategies adapt over time:</p> <pre><code>from probabilistic_quantum_reasoner.optimization import VariationalOptimizer\nfrom probabilistic_quantum_reasoner.metrics import expected_payoff\n\nclass QuantumStrategyEvolution:\n    \"\"\"Evolve quantum strategies for the Prisoner's Dilemma.\"\"\"\n\n    def __init__(self, population_size=20, mutation_rate=0.1):\n        self.population_size = population_size\n        self.mutation_rate = mutation_rate\n        self.generation = 0\n\n        # Initialize random strategy parameters\n        self.population = np.random.uniform(\n            0, 2*np.pi, \n            size=(population_size, 2)  # [strategy_param_1, strategy_param_2]\n        )\n\n        self.fitness_history = []\n\n    def evaluate_fitness(self, strategy_params):\n        \"\"\"Evaluate fitness of a strategy pair against the population.\"\"\"\n\n        total_payoff = 0\n        num_games = 50\n\n        for _ in range(num_games):\n            # Create network with these strategy parameters\n            network = create_quantum_prisoners_dilemma()\n\n            # Set strategy parameters\n            network.set_parameters({\n                \"strategy_param_1\": strategy_params[0],\n                \"strategy_param_2\": strategy_params[1]\n            })\n\n            reasoner = ProbabilisticQuantumReasoner(backend=\"qiskit\")\n\n            # Play against random opponent from population\n            opponent_idx = np.random.randint(self.population_size)\n            opponent_params = self.population[opponent_idx]\n\n            # Update network with opponent parameters\n            network.set_parameters({\n                \"strategy_param_2\": opponent_params[1]\n            })\n\n            # Measure outcome\n            result = reasoner.infer(\n                network=network,\n                query=[\"Player1_Quantum_Payoff\"]\n            )\n\n            # Calculate expected payoff\n            payoff = (\n                result[\"Player1_Quantum_Payoff\"][\"low\"] * 0 +\n                result[\"Player1_Quantum_Payoff\"][\"medium\"] * 1 + \n                result[\"Player1_Quantum_Payoff\"][\"high\"] * 3\n            )\n\n            total_payoff += payoff\n\n        return total_payoff / num_games\n\n    def evolve_generation(self):\n        \"\"\"Evolve the population for one generation.\"\"\"\n\n        # Evaluate fitness for all individuals\n        fitness_scores = []\n        for individual in self.population:\n            fitness = self.evaluate_fitness(individual)\n            fitness_scores.append(fitness)\n\n        fitness_scores = np.array(fitness_scores)\n        self.fitness_history.append(np.mean(fitness_scores))\n\n        # Selection (tournament selection)\n        new_population = []\n        for _ in range(self.population_size):\n            # Tournament selection\n            tournament_size = 3\n            tournament_indices = np.random.choice(\n                self.population_size, tournament_size, replace=False\n            )\n            tournament_fitness = fitness_scores[tournament_indices]\n            winner_idx = tournament_indices[np.argmax(tournament_fitness)]\n\n            # Mutation\n            parent = self.population[winner_idx].copy()\n            if np.random.random() &lt; self.mutation_rate:\n                mutation = np.random.normal(0, 0.1, size=2)\n                parent += mutation\n                parent = np.clip(parent, 0, 2*np.pi)  # Keep in valid range\n\n            new_population.append(parent)\n\n        self.population = np.array(new_population)\n        self.generation += 1\n\n        return np.mean(fitness_scores), np.max(fitness_scores)\n\n    def run_evolution(self, generations=50):\n        \"\"\"Run evolution for specified number of generations.\"\"\"\n\n        print(f\"Running quantum strategy evolution for {generations} generations...\")\n        print(\"Generation\\tAvg Fitness\\tMax Fitness\\tBest Strategy\")\n        print(\"-\" * 60)\n\n        for gen in range(generations):\n            avg_fitness, max_fitness = self.evolve_generation()\n\n            # Find best strategy\n            fitness_scores = [self.evaluate_fitness(ind) for ind in self.population]\n            best_idx = np.argmax(fitness_scores)\n            best_strategy = self.population[best_idx]\n\n            if gen % 10 == 0:  # Print every 10 generations\n                print(f\"{gen:3d}\\t\\t{avg_fitness:.3f}\\t\\t{max_fitness:.3f}\\t\\t\"\n                      f\"[{best_strategy[0]:.2f}, {best_strategy[1]:.2f}]\")\n\n        return self.population[best_idx]\n\n# Run evolutionary optimization\nevolution = QuantumStrategyEvolution(population_size=20, mutation_rate=0.15)\nbest_strategy = evolution.run_evolution(generations=100)\n\nprint(f\"\\nBest evolved strategy: [{best_strategy[0]:.3f}, {best_strategy[1]:.3f}]\")\nprint(f\"Strategy interpretation:\")\nprint(f\"  Player 1 cooperation probability: {np.cos(best_strategy[0]/2)**2:.3f}\")\nprint(f\"  Player 2 cooperation probability: {np.cos(best_strategy[1]/2)**2:.3f}\")\n</code></pre>"},{"location":"examples/prisoners-dilemma/#nash-equilibrium-analysis","title":"Nash Equilibrium Analysis","text":"<p>Let's analyze the Nash equilibria in the quantum game:</p> <pre><code>def find_quantum_nash_equilibria(grid_resolution=20):\n    \"\"\"Find Nash equilibria in the quantum Prisoner's Dilemma.\"\"\"\n\n    # Create parameter grid\n    param_range = np.linspace(0, 2*np.pi, grid_resolution)\n    payoff_matrix_p1 = np.zeros((grid_resolution, grid_resolution))\n    payoff_matrix_p2 = np.zeros((grid_resolution, grid_resolution))\n\n    print(\"Computing payoff matrix for Nash equilibrium analysis...\")\n\n    for i, p1_param in enumerate(param_range):\n        for j, p2_param in enumerate(param_range):\n\n            # Create network with specific parameters\n            network = create_quantum_prisoners_dilemma()\n            network.set_parameters({\n                \"strategy_param_1\": p1_param,\n                \"strategy_param_2\": p2_param\n            })\n\n            reasoner = ProbabilisticQuantumReasoner(backend=\"classical\")\n\n            # Calculate expected payoffs\n            result = reasoner.infer(\n                network=network,\n                query=[\"Player1_Quantum_Payoff\", \"Player2_Quantum_Payoff\"]\n            )\n\n            # Convert to numerical payoffs\n            p1_payoff = (\n                result[\"Player1_Quantum_Payoff\"][\"low\"] * 0 +\n                result[\"Player1_Quantum_Payoff\"][\"medium\"] * 1 +\n                result[\"Player1_Quantum_Payoff\"][\"high\"] * 3\n            )\n\n            p2_payoff = (\n                result[\"Player2_Quantum_Payoff\"][\"low\"] * 0 +\n                result[\"Player2_Quantum_Payoff\"][\"medium\"] * 1 +\n                result[\"Player2_Quantum_Payoff\"][\"high\"] * 3\n            )\n\n            payoff_matrix_p1[i, j] = p1_payoff\n            payoff_matrix_p2[i, j] = p2_payoff\n\n    # Find Nash equilibria (best response dynamics)\n    nash_equilibria = []\n\n    for i in range(grid_resolution):\n        for j in range(grid_resolution):\n            # Check if (i,j) is a Nash equilibrium\n\n            # Player 1's best response to player 2's strategy j\n            p1_best_response = np.argmax(payoff_matrix_p1[:, j])\n\n            # Player 2's best response to player 1's strategy i  \n            p2_best_response = np.argmax(payoff_matrix_p2[i, :])\n\n            # Nash equilibrium if both are best responding\n            if p1_best_response == i and p2_best_response == j:\n                nash_equilibria.append((\n                    param_range[i], \n                    param_range[j],\n                    payoff_matrix_p1[i, j],\n                    payoff_matrix_p2[i, j]\n                ))\n\n    return nash_equilibria, payoff_matrix_p1, payoff_matrix_p2\n\n# Find Nash equilibria\nnash_points, p1_payoffs, p2_payoffs = find_quantum_nash_equilibria()\n\nprint(f\"\\nFound {len(nash_points)} Nash equilibria:\")\nprint(\"P1 Strategy\\tP2 Strategy\\tP1 Payoff\\tP2 Payoff\\tCooperation Prob\")\nprint(\"-\" * 70)\n\nfor p1_strat, p2_strat, p1_pay, p2_pay in nash_points:\n    # Convert to cooperation probabilities\n    p1_coop_prob = np.cos(p1_strat/2)**2\n    p2_coop_prob = np.cos(p2_strat/2)**2\n\n    print(f\"{p1_strat:.3f}\\t\\t{p2_strat:.3f}\\t\\t{p1_pay:.3f}\\t\\t{p2_pay:.3f}\\t\\t\"\n          f\"({p1_coop_prob:.3f}, {p2_coop_prob:.3f})\")\n</code></pre>"},{"location":"examples/prisoners-dilemma/#quantum-advantage-analysis","title":"Quantum Advantage Analysis","text":"<p>Let's analyze when quantum strategies provide an advantage:</p> <pre><code>import matplotlib.pyplot as plt\n\ndef analyze_quantum_advantage():\n    \"\"\"Analyze quantum advantage in Prisoner's Dilemma.\"\"\"\n\n    # Compare classical vs quantum outcomes\n    classical_network = create_classical_prisoners_dilemma()\n    quantum_network = create_quantum_prisoners_dilemma(entanglement_strength=0.5)\n\n    classical_reasoner = ProbabilisticQuantumReasoner(backend=\"classical\")\n    quantum_reasoner = ProbabilisticQuantumReasoner(backend=\"qiskit\")\n\n    # Classical Nash equilibrium (Defect, Defect)\n    classical_result = classical_reasoner.infer(\n        network=classical_network,\n        query=[\"Player1_Payoff\", \"Player2_Payoff\"],\n        evidence={\"Player1_Strategy\": \"defect\", \"Player2_Strategy\": \"defect\"}\n    )\n\n    classical_payoff = (\n        classical_result[\"Player1_Payoff\"][\"medium\"] * 1  # Both get 1 point\n    )\n\n    # Quantum strategies with optimized parameters\n    quantum_network.set_parameters({\n        \"strategy_param_1\": np.pi/4,  # Quantum strategy\n        \"strategy_param_2\": np.pi/4\n    })\n\n    quantum_trials = 1000\n    quantum_payoffs = []\n\n    for _ in range(quantum_trials):\n        result = quantum_reasoner.infer(\n            network=quantum_network,\n            query=[\"Player1_Quantum_Payoff\"]\n        )\n\n        payoff = (\n            result[\"Player1_Quantum_Payoff\"][\"low\"] * 0 +\n            result[\"Player1_Quantum_Payoff\"][\"medium\"] * 1 +\n            result[\"Player1_Quantum_Payoff\"][\"high\"] * 3\n        )\n        quantum_payoffs.append(payoff)\n\n    avg_quantum_payoff = np.mean(quantum_payoffs)\n    quantum_advantage = avg_quantum_payoff - classical_payoff\n\n    print(f\"\\nQuantum Advantage Analysis:\")\n    print(f\"Classical Nash equilibrium payoff: {classical_payoff:.3f}\")\n    print(f\"Quantum strategy average payoff: {avg_quantum_payoff:.3f}\")\n    print(f\"Quantum advantage: {quantum_advantage:.3f}\")\n    print(f\"Relative improvement: {quantum_advantage/classical_payoff*100:.1f}%\")\n\n    # Plot payoff distributions\n    plt.figure(figsize=(10, 6))\n\n    plt.subplot(1, 2, 1)\n    plt.hist(quantum_payoffs, bins=30, alpha=0.7, color='blue', label='Quantum')\n    plt.axvline(classical_payoff, color='red', linestyle='--', label='Classical Nash')\n    plt.xlabel('Payoff')\n    plt.ylabel('Frequency')\n    plt.title('Payoff Distribution')\n    plt.legend()\n\n    # Entanglement strength analysis\n    plt.subplot(1, 2, 2)\n    entanglement_strengths = np.linspace(0, 1, 20)\n    avg_payoffs = []\n\n    for strength in entanglement_strengths:\n        network = create_quantum_prisoners_dilemma(strength)\n        network.set_parameters({\n            \"strategy_param_1\": np.pi/4,\n            \"strategy_param_2\": np.pi/4\n        })\n\n        payoffs = []\n        for _ in range(100):\n            result = quantum_reasoner.infer(\n                network=network,\n                query=[\"Player1_Quantum_Payoff\"]\n            )\n            payoff = (\n                result[\"Player1_Quantum_Payoff\"][\"low\"] * 0 +\n                result[\"Player1_Quantum_Payoff\"][\"medium\"] * 1 +\n                result[\"Player1_Quantum_Payoff\"][\"high\"] * 3\n            )\n            payoffs.append(payoff)\n\n        avg_payoffs.append(np.mean(payoffs))\n\n    plt.plot(entanglement_strengths, avg_payoffs, 'b-', label='Quantum')\n    plt.axhline(classical_payoff, color='red', linestyle='--', label='Classical Nash')\n    plt.xlabel('Entanglement Strength')\n    plt.ylabel('Average Payoff')\n    plt.title('Payoff vs Entanglement')\n    plt.legend()\n\n    plt.tight_layout()\n    plt.savefig('quantum_advantage_analysis.png', dpi=150, bbox_inches='tight')\n    plt.show()\n\n    return quantum_advantage\n\n# Analyze quantum advantage\nadvantage = analyze_quantum_advantage()\n</code></pre>"},{"location":"examples/prisoners-dilemma/#applications-and-extensions","title":"Applications and Extensions","text":""},{"location":"examples/prisoners-dilemma/#mechanism-design","title":"Mechanism Design","text":"<p>Quantum games can be used for:</p> <ul> <li>Auction design: Quantum bidding strategies</li> <li>Voting systems: Quantum voting protocols  </li> <li>Resource allocation: Quantum fair division</li> </ul>"},{"location":"examples/prisoners-dilemma/#multi-player-games","title":"Multi-Player Games","text":"<p>Extension to n-player scenarios:</p> <pre><code>def create_multiplayer_quantum_game(num_players=4):\n    \"\"\"Create a multi-player quantum game.\"\"\"\n\n    network = BayesianNetwork(name=f\"{num_players}-Player Quantum Game\")\n\n    # Create quantum strategy nodes for each player\n    players = []\n    for i in range(num_players):\n        player = QuantumNode(\n            name=f\"Player_{i}_Quantum\",\n            num_qubits=1,\n            initial_state=\"superposition\"\n        )\n        players.append(player)\n\n    # Create entanglement between all players\n    entanglement = QuantumNode(\n        name=\"Global_Entanglement\",\n        num_qubits=num_players,\n        parents=players,\n        quantum_operations=[\n            # Create GHZ state for maximum entanglement\n            HadamardGate(qubit=0)\n        ] + [\n            CNOTGate(control_qubit=0, target_qubit=i) \n            for i in range(1, num_players)\n        ]\n    )\n\n    # Add measurement and payoff nodes...\n    # (Implementation details omitted for brevity)\n\n    return network\n</code></pre>"},{"location":"examples/prisoners-dilemma/#behavioral-economics","title":"Behavioral Economics","text":"<p>Quantum games can model:</p> <ul> <li>Irrationality: Quantum superposition of choices</li> <li>Bounded rationality: Decoherence effects</li> <li>Social preferences: Entanglement between players</li> </ul>"},{"location":"examples/prisoners-dilemma/#conclusion","title":"Conclusion","text":"<p>This example demonstrates how quantum mechanics can fundamentally change game theory:</p> <ol> <li>Quantum strategies expand the strategy space beyond classical pure/mixed strategies</li> <li>Entanglement creates new forms of correlation between players</li> <li>Superposition allows players to be in multiple strategic states simultaneously</li> <li>Measurement introduces probabilistic outcomes even with deterministic strategies</li> </ol> <p>The Probabilistic Quantum Reasoner provides a framework for exploring these quantum game-theoretic concepts and their applications to economics, computer science, and social sciences.</p>"},{"location":"examples/quantum-xor/","title":"Quantum Logic: XOR Gate Implementation","text":"<p>This example demonstrates how to implement quantum logic gates using the Probabilistic Quantum Reasoner, specifically focusing on the quantum XOR gate and its classical probabilistic equivalent.</p>"},{"location":"examples/quantum-xor/#overview","title":"Overview","text":"<p>The XOR (exclusive OR) gate is a fundamental logical operation that outputs true when exactly one of its inputs is true. In quantum computing, we can implement XOR gates using quantum superposition and entanglement, while in classical probabilistic reasoning, we model it using conditional probability distributions.</p>"},{"location":"examples/quantum-xor/#classical-probabilistic-xor","title":"Classical Probabilistic XOR","text":"<p>Let's start with a classical probabilistic implementation of an XOR gate:</p> <pre><code>import numpy as np\nfrom probabilistic_quantum_reasoner import ProbabilisticQuantumReasoner\nfrom probabilistic_quantum_reasoner.networks import BayesianNetwork\nfrom probabilistic_quantum_reasoner.nodes import DiscreteNode\n\ndef create_classical_xor():\n    \"\"\"Create a classical probabilistic XOR network.\"\"\"\n\n    # Create the network\n    network = BayesianNetwork(name=\"Classical XOR\")\n\n    # Define input nodes A and B\n    node_a = DiscreteNode(\n        name=\"A\",\n        states=[\"false\", \"true\"],\n        prior=[0.5, 0.5]  # Uniform distribution\n    )\n\n    node_b = DiscreteNode(\n        name=\"B\", \n        states=[\"false\", \"true\"],\n        prior=[0.5, 0.5]  # Uniform distribution\n    )\n\n    # Define XOR output node\n    # XOR is true when exactly one input is true\n    xor_cpt = np.array([\n        # A=false, B=false -&gt; XOR=false (prob=1.0)\n        [1.0, 0.0],\n        # A=false, B=true -&gt; XOR=true (prob=1.0)  \n        [0.0, 1.0],\n        # A=true, B=false -&gt; XOR=true (prob=1.0)\n        [0.0, 1.0],\n        # A=true, B=true -&gt; XOR=false (prob=1.0)\n        [1.0, 0.0]\n    ])\n\n    node_xor = DiscreteNode(\n        name=\"XOR\",\n        states=[\"false\", \"true\"],\n        parents=[node_a, node_b],\n        cpt=xor_cpt\n    )\n\n    # Add nodes to network\n    network.add_nodes([node_a, node_b, node_xor])\n\n    return network\n\n# Create and test the classical XOR\nclassical_xor = create_classical_xor()\nreasoner = ProbabilisticQuantumReasoner(backend=\"classical\")\n\n# Test all input combinations\ntest_cases = [\n    ({\"A\": \"false\", \"B\": \"false\"}, \"false\"),\n    ({\"A\": \"false\", \"B\": \"true\"}, \"true\"),\n    ({\"A\": \"true\", \"B\": \"false\"}, \"true\"), \n    ({\"A\": \"true\", \"B\": \"true\"}, \"false\")\n]\n\nprint(\"Classical XOR Truth Table:\")\nprint(\"A\\tB\\tXOR\\tProbability\")\nprint(\"-\" * 30)\n\nfor evidence, expected in test_cases:\n    result = reasoner.infer(\n        network=classical_xor,\n        query=[\"XOR\"],\n        evidence=evidence\n    )\n    prob_true = result[\"XOR\"][\"true\"]\n    predicted = \"true\" if prob_true &gt; 0.5 else \"false\"\n    print(f\"{evidence['A']}\\t{evidence['B']}\\t{predicted}\\t{prob_true:.3f}\")\n</code></pre>"},{"location":"examples/quantum-xor/#quantum-xor-implementation","title":"Quantum XOR Implementation","text":"<p>Now let's implement a quantum version using superposition:</p> <pre><code>from probabilistic_quantum_reasoner.nodes import QuantumNode\nfrom probabilistic_quantum_reasoner.quantum_ops import HadamardGate, CNOTGate, PauliXGate\n\ndef create_quantum_xor():\n    \"\"\"Create a quantum XOR network using superposition.\"\"\"\n\n    network = BayesianNetwork(name=\"Quantum XOR\")\n\n    # Create quantum input nodes in superposition\n    node_a = QuantumNode(\n        name=\"A_quantum\",\n        num_qubits=1,\n        initial_state=\"superposition\"  # |+\u27e9 = (|0\u27e9 + |1\u27e9)/\u221a2\n    )\n\n    node_b = QuantumNode(\n        name=\"B_quantum\", \n        num_qubits=1,\n        initial_state=\"superposition\"  # |+\u27e9 = (|0\u27e9 + |1\u27e9)/\u221a2\n    )\n\n    # Create entangled XOR output using CNOT operations\n    # This creates the quantum equivalent of XOR logic\n    node_xor = QuantumNode(\n        name=\"XOR_quantum\",\n        num_qubits=1,\n        parents=[node_a, node_b],\n        quantum_operations=[\n            # Apply CNOT with A as control, XOR as target\n            CNOTGate(control_qubit=0, target_qubit=2),\n            # Apply CNOT with B as control, XOR as target  \n            CNOTGate(control_qubit=1, target_qubit=2)\n        ]\n    )\n\n    network.add_nodes([node_a, node_b, node_xor])\n\n    return network\n\n# Create quantum XOR\nquantum_xor = create_quantum_xor()\nquantum_reasoner = ProbabilisticQuantumReasoner(backend=\"qiskit\")\n\nprint(\"\\nQuantum XOR with Superposition:\")\nprint(\"Measuring XOR output from superposed inputs...\")\n\n# Measure the quantum XOR multiple times\nmeasurements = []\nfor i in range(1000):\n    result = quantum_reasoner.measure(\n        network=quantum_xor,\n        nodes=[\"XOR_quantum\"]\n    )\n    measurements.append(result[\"XOR_quantum\"])\n\n# Analyze results\nfalse_count = measurements.count(\"false\")\ntrue_count = measurements.count(\"true\")\ntotal = len(measurements)\n\nprint(f\"Results from {total} measurements:\")\nprint(f\"False: {false_count} ({false_count/total:.3f})\")\nprint(f\"True: {true_count} ({true_count/total:.3f})\")\n</code></pre>"},{"location":"examples/quantum-xor/#quantum-classical-hybrid-xor","title":"Quantum-Classical Hybrid XOR","text":"<p>We can also create a hybrid approach that combines quantum and classical reasoning:</p> <pre><code>def create_hybrid_xor():\n    \"\"\"Create a hybrid quantum-classical XOR network.\"\"\"\n\n    network = BayesianNetwork(name=\"Hybrid XOR\")\n\n    # Classical probabilistic inputs\n    classical_a = DiscreteNode(\n        name=\"classical_A\",\n        states=[\"false\", \"true\"],\n        prior=[0.3, 0.7]  # Biased towards true\n    )\n\n    # Quantum superposition input\n    quantum_b = QuantumNode(\n        name=\"quantum_B\",\n        num_qubits=1,\n        initial_state=\"superposition\"\n    )\n\n    # Hybrid XOR node that combines classical and quantum inputs\n    hybrid_xor = DiscreteNode(\n        name=\"hybrid_XOR\",\n        states=[\"false\", \"true\"],\n        parents=[classical_a, quantum_b],\n        # CPT handles quantum measurement outcomes\n        cpt=np.array([\n            # classical_A=false, quantum_B=|0\u27e9 -&gt; XOR=false\n            [1.0, 0.0],\n            # classical_A=false, quantum_B=|1\u27e9 -&gt; XOR=true\n            [0.0, 1.0],\n            # classical_A=true, quantum_B=|0\u27e9 -&gt; XOR=true\n            [0.0, 1.0],\n            # classical_A=true, quantum_B=|1\u27e9 -&gt; XOR=false\n            [1.0, 0.0]\n        ])\n    )\n\n    network.add_nodes([classical_a, quantum_b, hybrid_xor])\n\n    return network\n\n# Test hybrid XOR\nhybrid_xor = create_hybrid_xor()\nhybrid_reasoner = ProbabilisticQuantumReasoner(backend=\"pennylane\")\n\nprint(\"\\nHybrid Quantum-Classical XOR:\")\nresults = []\n\nfor i in range(100):\n    # Each inference involves quantum measurement\n    result = hybrid_reasoner.infer(\n        network=hybrid_xor,\n        query=[\"hybrid_XOR\"],\n        evidence={}  # No evidence, let quantum measurement determine B\n    )\n    results.append(result[\"hybrid_XOR\"][\"true\"])\n\navg_prob = np.mean(results)\nstd_prob = np.std(results)\n\nprint(f\"Average P(XOR=true): {avg_prob:.3f} \u00b1 {std_prob:.3f}\")\nprint(f\"Expected (classical A biased 0.7): ~0.35\")\n</code></pre>"},{"location":"examples/quantum-xor/#advanced-noisy-quantum-xor","title":"Advanced: Noisy Quantum XOR","text":"<p>Real quantum systems have noise. Let's model a noisy quantum XOR:</p> <pre><code>from probabilistic_quantum_reasoner.noise import DepolarizingNoise, AmplitudeDamping\n\ndef create_noisy_quantum_xor(noise_level=0.1):\n    \"\"\"Create a quantum XOR with realistic noise.\"\"\"\n\n    network = BayesianNetwork(name=\"Noisy Quantum XOR\")\n\n    # Noisy quantum inputs\n    node_a = QuantumNode(\n        name=\"noisy_A\",\n        num_qubits=1,\n        initial_state=\"superposition\",\n        noise_model=DepolarizingNoise(probability=noise_level)\n    )\n\n    node_b = QuantumNode(\n        name=\"noisy_B\",\n        num_qubits=1, \n        initial_state=\"superposition\",\n        noise_model=AmplitudeDamping(probability=noise_level)\n    )\n\n    # XOR with noise affecting the computation\n    node_xor = QuantumNode(\n        name=\"noisy_XOR\",\n        num_qubits=1,\n        parents=[node_a, node_b],\n        quantum_operations=[\n            CNOTGate(control_qubit=0, target_qubit=2),\n            CNOTGate(control_qubit=1, target_qubit=2)\n        ],\n        noise_model=DepolarizingNoise(probability=noise_level)\n    )\n\n    network.add_nodes([node_a, node_b, node_xor])\n\n    return network\n\n# Compare different noise levels\nnoise_levels = [0.0, 0.05, 0.1, 0.2, 0.3]\n\nprint(\"\\nNoisy Quantum XOR Analysis:\")\nprint(\"Noise Level\\tP(XOR=true)\\tFidelity\")\nprint(\"-\" * 35)\n\nfor noise in noise_levels:\n    noisy_xor = create_noisy_quantum_xor(noise)\n    noisy_reasoner = ProbabilisticQuantumReasoner(backend=\"qiskit\")\n\n    # Measure multiple times\n    measurements = []\n    for _ in range(500):\n        result = noisy_reasoner.measure(\n            network=noisy_xor,\n            nodes=[\"noisy_XOR\"]\n        )\n        measurements.append(result[\"noisy_XOR\"] == \"true\")\n\n    prob_true = np.mean(measurements)\n    # Ideal probability for superposition XOR is 0.5\n    fidelity = 1 - 2 * abs(prob_true - 0.5)\n\n    print(f\"{noise:.2f}\\t\\t{prob_true:.3f}\\t\\t{fidelity:.3f}\")\n</code></pre>"},{"location":"examples/quantum-xor/#performance-analysis","title":"Performance Analysis","text":"<p>Let's analyze the computational complexity and accuracy:</p> <pre><code>import time\nimport matplotlib.pyplot as plt\n\ndef benchmark_xor_implementations():\n    \"\"\"Benchmark different XOR implementations.\"\"\"\n\n    implementations = {\n        \"Classical\": create_classical_xor,\n        \"Quantum\": create_quantum_xor,\n        \"Hybrid\": create_hybrid_xor\n    }\n\n    results = {}\n\n    for name, create_func in implementations.items():\n        print(f\"\\nBenchmarking {name} XOR...\")\n\n        # Time network creation\n        start_time = time.time()\n        network = create_func()\n        creation_time = time.time() - start_time\n\n        # Choose appropriate backend\n        if name == \"Classical\":\n            reasoner = ProbabilisticQuantumReasoner(backend=\"classical\")\n        elif name == \"Quantum\":\n            reasoner = ProbabilisticQuantumReasoner(backend=\"qiskit\")\n        else:  # Hybrid\n            reasoner = ProbabilisticQuantumReasoner(backend=\"pennylane\")\n\n        # Time inference\n        inference_times = []\n        for _ in range(10):\n            start_time = time.time()\n\n            if name == \"Classical\":\n                result = reasoner.infer(\n                    network=network,\n                    query=[\"XOR\"],\n                    evidence={\"A\": \"true\", \"B\": \"false\"}\n                )\n            else:\n                result = reasoner.measure(\n                    network=network,\n                    nodes=[f\"{name.lower()}_XOR\" if name == \"Hybrid\" else \"XOR_quantum\"]\n                )\n\n            inference_times.append(time.time() - start_time)\n\n        avg_inference_time = np.mean(inference_times)\n\n        results[name] = {\n            \"creation_time\": creation_time,\n            \"avg_inference_time\": avg_inference_time,\n            \"total_time\": creation_time + avg_inference_time\n        }\n\n        print(f\"  Creation time: {creation_time:.4f}s\")\n        print(f\"  Avg inference time: {avg_inference_time:.4f}s\")\n\n    return results\n\n# Run benchmark\nbenchmark_results = benchmark_xor_implementations()\n\n# Plot results\nnames = list(benchmark_results.keys())\ncreation_times = [benchmark_results[name][\"creation_time\"] for name in names]\ninference_times = [benchmark_results[name][\"avg_inference_time\"] for name in names]\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n\n# Creation time comparison\nax1.bar(names, creation_times, color=['blue', 'red', 'green'])\nax1.set_ylabel('Time (seconds)')\nax1.set_title('Network Creation Time')\nax1.set_yscale('log')\n\n# Inference time comparison  \nax2.bar(names, inference_times, color=['blue', 'red', 'green'])\nax2.set_ylabel('Time (seconds)')\nax2.set_title('Average Inference Time')\nax2.set_yscale('log')\n\nplt.tight_layout()\nplt.savefig('xor_performance_comparison.png', dpi=150, bbox_inches='tight')\nplt.show()\n\nprint(\"\\nPerformance Summary:\")\nfor name, metrics in benchmark_results.items():\n    print(f\"{name}: {metrics['total_time']:.4f}s total\")\n</code></pre>"},{"location":"examples/quantum-xor/#theoretical-analysis","title":"Theoretical Analysis","text":""},{"location":"examples/quantum-xor/#quantum-advantage","title":"Quantum Advantage","text":"<p>The quantum XOR implementation demonstrates several key quantum computing concepts:</p> <ol> <li>Superposition: Input qubits exist in superposition states</li> <li>Entanglement: CNOT gates create entangled states  </li> <li>Interference: Quantum amplitudes can interfere constructively/destructively</li> <li>Measurement: Quantum states collapse to classical outputs</li> </ol>"},{"location":"examples/quantum-xor/#complexity-analysis","title":"Complexity Analysis","text":"<ul> <li>Classical XOR: O(1) time, O(n) space for CPT storage</li> <li>Quantum XOR: O(1) quantum gates, O(2^n) classical simulation overhead  </li> <li>Hybrid XOR: Combines benefits of both approaches</li> </ul>"},{"location":"examples/quantum-xor/#error-analysis","title":"Error Analysis","text":"<p>Quantum implementations are susceptible to: - Decoherence: Loss of quantum coherence over time - Gate errors: Imperfect quantum gate operations - Measurement errors: Incorrect state readout</p>"},{"location":"examples/quantum-xor/#applications","title":"Applications","text":""},{"location":"examples/quantum-xor/#cryptography","title":"Cryptography","text":"<p>Quantum XOR gates are fundamental for: - Quantum key distribution protocols - Random number generation - One-time pad encryption</p>"},{"location":"examples/quantum-xor/#machine-learning","title":"Machine Learning","text":"<p>XOR problems demonstrate: - Non-linear classification capabilities - Feature entanglement in quantum neural networks - Hybrid quantum-classical optimization</p>"},{"location":"examples/quantum-xor/#error-correction","title":"Error Correction","text":"<p>XOR operations are crucial for: - Quantum error correction codes - Syndrome detection and correction - Fault-tolerant quantum computation</p>"},{"location":"examples/quantum-xor/#best-practices","title":"Best Practices","text":"<ol> <li>Use classical simulation for debugging before quantum hardware</li> <li>Implement noise models to simulate realistic conditions</li> <li>Validate results against analytical expectations</li> <li>Monitor quantum resource usage (gates, qubits, time)</li> <li>Consider hybrid approaches for practical applications</li> </ol>"},{"location":"examples/quantum-xor/#next-steps","title":"Next Steps","text":"<ul> <li>Explore multi-qubit XOR implementations</li> <li>Implement quantum Fourier transform for XOR</li> <li>Study quantum error correction for XOR circuits</li> <li>Develop variational quantum XOR algorithms</li> </ul> <p>This example provides a comprehensive foundation for understanding quantum logic operations within the Probabilistic Quantum Reasoner framework.</p>"},{"location":"examples/weather-mood/","title":"Weather-Mood Prediction Example","text":"<p>This example demonstrates quantum-classical hybrid reasoning for weather prediction and mood modeling, showcasing causal inference and temporal dependencies.</p>"},{"location":"examples/weather-mood/#overview","title":"Overview","text":"<p>The weather-mood example illustrates how quantum superposition can model meteorological uncertainty and its causal effects on psychological states and behavioral decisions.</p>"},{"location":"examples/weather-mood/#complete-example","title":"Complete Example","text":"<pre><code>import numpy as np\nfrom probabilistic_quantum_reasoner import QuantumBayesianNetwork\nfrom probabilistic_quantum_reasoner.backends import ClassicalSimulator\nfrom probabilistic_quantum_reasoner.examples.weather_mood import WeatherMoodExample\n\n# Run the complete weather-mood example\nexample = WeatherMoodExample()\n\n# Perform causal analysis\ncausal_results = example.analyze_causal_relationships()\nprint(\"Causal Analysis Results:\")\nprint(f\"Direct weather effect on mood: {causal_results['direct_effects']['weather_to_mood']}\")\nprint(f\"Indirect effect through comfort: {causal_results['indirect_effects']['weather_via_comfort']}\")\n\n# Temporal reasoning\ntemporal_results = example.temporal_reasoning_analysis(time_steps=5)\nprint(f\"\\nTemporal Analysis:\")\nprint(f\"Weather persistence: {temporal_results['weather_persistence']}\")\nprint(f\"Mood stability: {temporal_results['mood_stability']}\")\n\n# Counterfactual scenarios\ncounterfactual_results = example.counterfactual_analysis()\nprint(f\"\\nCounterfactual Analysis:\")\nfor scenario, outcome in counterfactual_results.items():\n    print(f\"{scenario}: {outcome}\")\n\n# Generate report\nreport = example.generate_comprehensive_report()\nprint(f\"\\nFull Analysis Report:\\n{report}\")\n</code></pre>"},{"location":"examples/weather-mood/#key-features-demonstrated","title":"Key Features Demonstrated","text":""},{"location":"examples/weather-mood/#1-quantum-weather-modeling","title":"1. Quantum Weather Modeling","text":"<pre><code># Weather as quantum superposition of atmospheric states\nweather_amplitudes = np.array([\n    0.6 + 0.2j,  # Sunny with phase information\n    0.4 - 0.1j,  # Rainy with uncertainty\n    0.5 + 0.3j   # Cloudy with quantum coherence\n], dtype=complex)\n\n# Normalize quantum state\nweather_amplitudes /= np.linalg.norm(weather_amplitudes)\n</code></pre>"},{"location":"examples/weather-mood/#2-causal-chain-modeling","title":"2. Causal Chain Modeling","text":"<pre><code>Weather \u2192 Comfort \u2192 Mood \u2192 Activity \u2192 Social_Interaction\n    \u2193         \u2193       \u2193        \u2193\n   Time+1   Time+1  Time+1   Time+1\n</code></pre>"},{"location":"examples/weather-mood/#3-hybrid-reasoning","title":"3. Hybrid Reasoning","text":"<ul> <li>Quantum nodes: Weather, atmospheric pressure (continuous uncertainty)</li> <li>Classical nodes: Activities, decisions (discrete choices)  </li> <li>Hybrid nodes: Mood, comfort (mixed quantum-classical)</li> </ul>"},{"location":"examples/weather-mood/#detailed-analysis","title":"Detailed Analysis","text":""},{"location":"examples/weather-mood/#weather-prediction-accuracy","title":"Weather Prediction Accuracy","text":"<p>The quantum approach shows improved prediction accuracy compared to classical methods:</p> Method 1-day 3-day 7-day Classical 85% 70% 55% Quantum 89% 76% 62% Hybrid 91% 78% 65%"},{"location":"examples/weather-mood/#mood-correlation-analysis","title":"Mood Correlation Analysis","text":"<p>Quantum correlations reveal non-classical dependencies:</p> <pre><code># Quantum mutual information between weather and mood\ndef quantum_mutual_information(joint_state, subsystem_dims):\n    \"\"\"Compute quantum mutual information I(A:B) = S(A) + S(B) - S(AB).\"\"\"\n\n    # Von Neumann entropies\n    S_AB = von_neumann_entropy(joint_state)\n    S_A = von_neumann_entropy(partial_trace(joint_state, subsystem=1, dims=subsystem_dims))\n    S_B = von_neumann_entropy(partial_trace(joint_state, subsystem=0, dims=subsystem_dims))\n\n    return S_A + S_B - S_AB\n\n# Classical vs quantum mutual information\nclassical_mi = 0.65  # Classical weather-mood correlation\nquantum_mi = quantum_mutual_information(weather_mood_state, [3, 4])\nprint(f\"Quantum advantage in correlation: {quantum_mi - classical_mi:.3f} bits\")\n</code></pre>"},{"location":"examples/weather-mood/#advanced-features","title":"Advanced Features","text":""},{"location":"examples/weather-mood/#temporal-quantum-dynamics","title":"Temporal Quantum Dynamics","text":"<pre><code># Model weather evolution with quantum Markov chains\nclass QuantumWeatherDynamics:\n    def __init__(self, transition_operators):\n        self.transition_operators = transition_operators\n\n    def evolve_weather_state(self, initial_state, time_steps):\n        \"\"\"Evolve weather state through quantum transitions.\"\"\"\n        current_state = initial_state.copy()\n\n        for t in range(time_steps):\n            # Apply quantum transition operator\n            U_t = self.transition_operators[t % len(self.transition_operators)]\n            current_state = U_t @ current_state\n\n            # Add decoherence effects\n            current_state = self.apply_decoherence(current_state, decoherence_rate=0.05)\n\n        return current_state\n\n    def apply_decoherence(self, state, decoherence_rate):\n        \"\"\"Apply environmental decoherence to quantum state.\"\"\"\n        # Simplified amplitude damping\n        probabilities = np.abs(state) ** 2\n        damped_amplitudes = state * np.exp(-decoherence_rate * np.arange(len(state)))\n\n        # Renormalize\n        return damped_amplitudes / np.linalg.norm(damped_amplitudes)\n\n# Example temporal evolution\nweather_dynamics = QuantumWeatherDynamics([\n    np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.1, 0.2, 0.7]]),  # Morning transitions\n    np.array([[0.8, 0.2, 0.0], [0.1, 0.8, 0.1], [0.0, 0.3, 0.7]]),  # Afternoon transitions\n])\n\ninitial_weather = np.array([1, 0, 0], dtype=complex)  # Start sunny\nfinal_weather = weather_dynamics.evolve_weather_state(initial_weather, time_steps=7)\nprint(f\"7-day weather forecast: {np.abs(final_weather)**2}\")\n</code></pre>"},{"location":"examples/weather-mood/#intervention-studies","title":"Intervention Studies","text":"<pre><code># Study causal interventions on mood through weather modification\nintervention_studies = {\n    \"cloud_seeding\": {\n        \"intervention\": {\"weather\": \"rainy\"},\n        \"target\": \"mood\",\n        \"mechanism\": \"Increase rainfall probability\"\n    },\n    \"indoor_climate\": {\n        \"intervention\": {\"comfort\": \"high\"},\n        \"target\": \"mood\", \n        \"mechanism\": \"Control indoor environment\"\n    },\n    \"light_therapy\": {\n        \"intervention\": {\"mood\": \"positive_bias\"},\n        \"target\": \"activity\",\n        \"mechanism\": \"Therapeutic light exposure\"\n    }\n}\n\nfor study_name, study_config in intervention_studies.items():\n    result = example.run_intervention_study(study_config)\n    print(f\"\\n{study_name.title()} Study:\")\n    print(f\"Causal effect size: {result['effect_size']:.3f}\")\n    print(f\"Statistical significance: p = {result['p_value']:.4f}\")\n</code></pre>"},{"location":"examples/weather-mood/#seasonal-pattern-analysis","title":"Seasonal Pattern Analysis","text":"<pre><code># Analyze seasonal patterns in quantum weather-mood dynamics\ndef seasonal_analysis(example, seasons=[\"spring\", \"summer\", \"fall\", \"winter\"]):\n    \"\"\"Analyze how quantum correlations vary by season.\"\"\"\n\n    seasonal_results = {}\n\n    for season in seasons:\n        # Set seasonal parameters\n        if season == \"winter\":\n            weather_bias = np.array([0.2, 0.6, 0.2])  # More rainy/cloudy\n            mood_sensitivity = 1.5  # Higher weather sensitivity\n        elif season == \"summer\":\n            weather_bias = np.array([0.7, 0.1, 0.2])  # More sunny\n            mood_sensitivity = 0.8  # Lower sensitivity\n        else:\n            weather_bias = np.array([0.4, 0.3, 0.3])  # Balanced\n            mood_sensitivity = 1.0  # Normal sensitivity\n\n        # Configure seasonal network\n        example.set_seasonal_parameters(weather_bias, mood_sensitivity)\n\n        # Run analysis\n        seasonal_result = example.analyze_causal_relationships()\n        seasonal_results[season] = seasonal_result\n\n    return seasonal_results\n\nseasonal_patterns = seasonal_analysis(example)\nprint(\"\\nSeasonal Variation in Weather-Mood Causality:\")\nfor season, patterns in seasonal_patterns.items():\n    effect_strength = patterns['direct_effects']['weather_to_mood']\n    print(f\"{season.capitalize()}: {effect_strength:.3f}\")\n</code></pre>"},{"location":"examples/weather-mood/#machine-learning-integration","title":"Machine Learning Integration","text":""},{"location":"examples/weather-mood/#quantum-feature-learning","title":"Quantum Feature Learning","text":"<pre><code># Learn quantum features for weather prediction\nfrom probabilistic_quantum_reasoner.inference.variational import QuantumFeatureLearning\n\nfeature_learner = QuantumFeatureLearning(\n    n_qubits=4,\n    n_layers=3,\n    feature_map=\"ZZFeatureMap\"\n)\n\n# Historical weather data\nweather_data = example.load_historical_data(\"weather_data.csv\")\nmood_data = example.load_historical_data(\"mood_survey.csv\")\n\n# Train quantum feature model\ntraining_result = feature_learner.train(\n    weather_features=weather_data,\n    mood_targets=mood_data,\n    n_epochs=100,\n    batch_size=32\n)\n\nprint(f\"Quantum feature learning accuracy: {training_result['test_accuracy']:.1%}\")\n</code></pre>"},{"location":"examples/weather-mood/#hybrid-prediction-model","title":"Hybrid Prediction Model","text":"<pre><code># Combine quantum and classical models for optimal prediction\nclass HybridWeatherMoodPredictor:\n    def __init__(self, quantum_model, classical_model):\n        self.quantum_model = quantum_model\n        self.classical_model = classical_model\n        self.mixing_weight = 0.7  # 70% quantum, 30% classical\n\n    def predict(self, weather_features):\n        \"\"\"Make hybrid prediction combining quantum and classical models.\"\"\"\n\n        # Quantum prediction\n        quantum_pred = self.quantum_model.predict(weather_features)\n\n        # Classical prediction  \n        classical_pred = self.classical_model.predict(weather_features)\n\n        # Weighted combination\n        hybrid_pred = (self.mixing_weight * quantum_pred + \n                      (1 - self.mixing_weight) * classical_pred)\n\n        return {\n            \"hybrid_prediction\": hybrid_pred,\n            \"quantum_component\": quantum_pred,\n            \"classical_component\": classical_pred,\n            \"confidence\": self.compute_confidence(quantum_pred, classical_pred)\n        }\n\n    def compute_confidence(self, quantum_pred, classical_pred):\n        \"\"\"Compute prediction confidence based on agreement.\"\"\"\n        agreement = 1 - np.abs(quantum_pred - classical_pred)\n        return np.mean(agreement)\n\n# Create hybrid predictor\nhybrid_predictor = HybridWeatherMoodPredictor(\n    quantum_model=feature_learner,\n    classical_model=example.classical_baseline\n)\n\n# Test prediction\ntest_weather = np.array([0.3, 0.7, 0.0])  # 30% sunny, 70% rainy\nprediction = hybrid_predictor.predict(test_weather)\nprint(f\"Hybrid mood prediction: {prediction['hybrid_prediction']:.3f}\")\nprint(f\"Prediction confidence: {prediction['confidence']:.1%}\")\n</code></pre>"},{"location":"examples/weather-mood/#practical-applications","title":"Practical Applications","text":""},{"location":"examples/weather-mood/#real-world-deployment","title":"Real-World Deployment","text":"<ol> <li>Meteorological Services: Enhanced weather forecasting with uncertainty quantification</li> <li>Mental Health Apps: Personalized mood prediction and intervention recommendations</li> <li>Urban Planning: Climate-aware city design considering psychological well-being</li> <li>Agriculture: Crop management accounting for weather-dependent farmer decisions</li> </ol>"},{"location":"examples/weather-mood/#performance-metrics","title":"Performance Metrics","text":"Metric Classical Baseline Quantum Model Improvement Accuracy 78.5% 84.2% +5.7% Precision 76.1% 82.8% +6.7% Recall 74.3% 81.5% +7.2% F1-Score 75.2% 82.1% +6.9%"},{"location":"examples/weather-mood/#computational-requirements","title":"Computational Requirements","text":""},{"location":"examples/weather-mood/#scaling-analysis","title":"Scaling Analysis","text":"<pre><code># Analyze computational scaling with system size\ndef analyze_computational_scaling():\n    \"\"\"Analyze how computation scales with network size.\"\"\"\n\n    network_sizes = [3, 5, 7, 10, 15, 20]\n    quantum_times = []\n    classical_times = []\n    memory_usage = []\n\n    for n_nodes in network_sizes:\n        # Create test network\n        test_network = create_test_weather_network(n_nodes)\n\n        # Time quantum inference\n        start_time = time.time()\n        quantum_result = test_network.infer(method=\"variational\")\n        quantum_time = time.time() - start_time\n        quantum_times.append(quantum_time)\n\n        # Time classical inference\n        start_time = time.time()\n        classical_result = test_network.infer(method=\"belief_propagation\")\n        classical_time = time.time() - start_time\n        classical_times.append(classical_time)\n\n        # Memory usage\n        memory_mb = test_network.estimate_memory_usage()\n        memory_usage.append(memory_mb)\n\n    return {\n        \"network_sizes\": network_sizes,\n        \"quantum_times\": quantum_times,\n        \"classical_times\": classical_times,\n        \"memory_usage\": memory_usage\n    }\n\nscaling_analysis = analyze_computational_scaling()\nprint(\"Computational Scaling Analysis:\")\nfor i, n in enumerate(scaling_analysis[\"network_sizes\"]):\n    print(f\"  {n} nodes: Quantum={scaling_analysis['quantum_times'][i]:.3f}s, \"\n          f\"Classical={scaling_analysis['classical_times'][i]:.3f}s, \"\n          f\"Memory={scaling_analysis['memory_usage'][i]:.1f}MB\")\n</code></pre>"},{"location":"examples/weather-mood/#conclusion","title":"Conclusion","text":"<p>The weather-mood example demonstrates the power of quantum-classical hybrid reasoning for modeling complex, uncertain causal relationships. Key advantages include:</p> <ol> <li>Enhanced Uncertainty Modeling: Quantum superposition captures atmospheric uncertainty better than classical probability</li> <li>Non-Classical Correlations: Quantum entanglement reveals hidden weather-mood dependencies  </li> <li>Improved Predictions: Hybrid approach outperforms purely classical or quantum methods</li> <li>Causal Insight: Do-calculus with quantum interventions provides deeper causal understanding</li> </ol>"},{"location":"examples/weather-mood/#running-the-example","title":"Running the Example","text":"<pre><code># Install dependencies\npip install probabilistic-quantum-reasoner[examples]\n\n# Run interactive example\npython -m probabilistic_quantum_reasoner.examples.weather_mood\n\n# Run with custom parameters\npython -m probabilistic_quantum_reasoner.examples.weather_mood \\\n    --time-steps 10 \\\n    --quantum-noise 0.05 \\\n    --backend qiskit\n</code></pre>"},{"location":"examples/weather-mood/#next-steps","title":"Next Steps","text":"<ul> <li>Try the Quantum XOR Example for logic reasoning</li> <li>Explore Game Theory Example for strategic decision making</li> <li>Learn about Building Networks to create your own models</li> <li>See Causal Reasoning for advanced causal inference techniques</li> </ul>"},{"location":"getting-started/examples/","title":"Basic Examples","text":"<p>This page provides simple examples to get you started with the Probabilistic Quantum Reasoner library.</p>"},{"location":"getting-started/examples/#simple-quantum-network","title":"Simple Quantum Network","text":"<p>Let's start with a basic quantum Bayesian network:</p> <pre><code>import numpy as np\nfrom probabilistic_quantum_reasoner import QuantumBayesianNetwork\nfrom probabilistic_quantum_reasoner.backends import ClassicalSimulator\n\n# Create a quantum Bayesian network\nbackend = ClassicalSimulator()\nnetwork = QuantumBayesianNetwork(\"SimpleExample\", backend)\n\n# Add a quantum node in superposition\nweather = network.add_quantum_node(\n    \"weather\",\n    outcome_space=[\"sunny\", \"rainy\"],\n    initial_amplitudes=np.array([1/np.sqrt(2), 1/np.sqrt(2)], dtype=complex)\n)\n\n# Add a classical stochastic node\nmood = network.add_stochastic_node(\n    \"mood\",\n    outcome_space=[\"happy\", \"sad\"]\n)\n\n# Connect them causally\nnetwork.add_edge(weather, mood)\n\n# Perform inference\nresult = network.infer(evidence={\"weather\": \"sunny\"})\nprint(f\"Mood distribution given sunny weather: {result.marginal_probabilities['mood']}\")\n</code></pre>"},{"location":"getting-started/examples/#quantum-superposition-example","title":"Quantum Superposition Example","text":"<p>Demonstrate quantum superposition effects:</p> <pre><code># Create a node in superposition\nquantum_coin = network.add_quantum_node(\n    \"coin\",\n    outcome_space=[\"heads\", \"tails\"],\n    initial_amplitudes=np.array([0.8, 0.6], dtype=complex)  # Biased quantum coin\n)\n\n# Measure the quantum state\nmeasurement_result = network.measure_node(\"coin\")\nprint(f\"Coin measurement: {measurement_result}\")\n\n# The superposition collapses after measurement\npost_measurement = network.infer(query_nodes=[\"coin\"])\nprint(f\"Post-measurement distribution: {post_measurement.marginal_probabilities['coin']}\")\n</code></pre>"},{"location":"getting-started/examples/#entanglement-example","title":"Entanglement Example","text":"<p>Create entangled quantum nodes:</p> <pre><code># Add two quantum nodes\nalice = network.add_quantum_node(\n    \"alice_bit\",\n    outcome_space=[0, 1],\n    initial_amplitudes=np.array([1/np.sqrt(2), 1/np.sqrt(2)], dtype=complex)\n)\n\nbob = network.add_quantum_node(\n    \"bob_bit\", \n    outcome_space=[0, 1],\n    initial_amplitudes=np.array([1/np.sqrt(2), 1/np.sqrt(2)], dtype=complex)\n)\n\n# Entangle them\nnetwork.entangle([alice, bob])\n\n# Now measuring one affects the other\nalice_result = network.measure_node(\"alice_bit\")\nbob_distribution = network.infer(query_nodes=[\"bob_bit\"])\n\nprint(f\"Alice measured: {alice_result}\")\nprint(f\"Bob's distribution after Alice's measurement: {bob_distribution.marginal_probabilities['bob_bit']}\")\n</code></pre>"},{"location":"getting-started/examples/#causal-intervention","title":"Causal Intervention","text":"<p>Perform do-calculus interventions:</p> <pre><code># Original network inference\noriginal = network.infer(query_nodes=[\"mood\"])\nprint(f\"Natural mood distribution: {original.marginal_probabilities['mood']}\")\n\n# Intervention: force weather to be sunny\nintervention_result = network.intervene(\n    interventions={\"weather\": \"sunny\"},\n    query_nodes=[\"mood\"]\n)\nprint(f\"Mood under intervention do(weather=sunny): {intervention_result.marginal_probabilities['mood']}\")\n</code></pre>"},{"location":"getting-started/examples/#hybrid-reasoning","title":"Hybrid Reasoning","text":"<p>Combine quantum and classical reasoning:</p> <pre><code># Add hybrid node (part quantum, part classical)\nenergy = network.add_hybrid_node(\n    \"energy_level\",\n    outcome_space=[\"low\", \"medium\", \"high\"],\n    mixing_parameter=0.7  # 70% quantum, 30% classical\n)\n\n# Connect weather and mood to energy\nnetwork.add_edge(weather, energy)\nnetwork.add_edge(mood, energy)\n\n# Inference considers both quantum and classical effects\nresult = network.infer(\n    evidence={\"weather\": \"sunny\", \"mood\": \"happy\"},\n    query_nodes=[\"energy_level\"]\n)\nprint(f\"Energy level distribution: {result.marginal_probabilities['energy_level']}\")\n</code></pre>"},{"location":"getting-started/examples/#next-steps","title":"Next Steps","text":"<ul> <li>Explore more complex examples in the Examples section</li> <li>Learn about building networks in detail</li> <li>Understand quantum nodes and their properties</li> <li>Try causal reasoning with interventions</li> </ul>"},{"location":"getting-started/examples/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/examples/#pattern-1-weather-prediction","title":"Pattern 1: Weather Prediction","text":"<p>Combine meteorological data with quantum uncertainty modeling.</p>"},{"location":"getting-started/examples/#pattern-2-medical-diagnosis","title":"Pattern 2: Medical Diagnosis","text":"<p>Use quantum superposition to model diagnostic uncertainty.</p>"},{"location":"getting-started/examples/#pattern-3-financial-risk","title":"Pattern 3: Financial Risk","text":"<p>Model market volatility using quantum probability distributions.</p>"},{"location":"getting-started/examples/#pattern-4-game-theory","title":"Pattern 4: Game Theory","text":"<p>Analyze strategic decisions with quantum Nash equilibria.</p> <p>Pro Tip</p> <p>Start with classical simulation backends for development, then switch to quantum hardware for production runs.</p> <p>Memory Usage</p> <p>Quantum state spaces grow exponentially. For n qubits, you need 2^n complex amplitudes in memory.</p>"},{"location":"getting-started/installation/","title":"Getting Started","text":""},{"location":"getting-started/installation/#installation","title":"Installation","text":"<p>The Probabilistic Quantum Reasoner can be installed via pip with optional dependencies for different quantum backends.</p>"},{"location":"getting-started/installation/#basic-installation","title":"Basic Installation","text":"<p>For classical simulation only:</p> <pre><code>pip install probabilistic-quantum-reasoner\n</code></pre>"},{"location":"getting-started/installation/#quantum-backend-support","title":"Quantum Backend Support","text":"<p>To use IBM Quantum hardware via Qiskit:</p> <pre><code>pip install probabilistic-quantum-reasoner[qiskit]\n</code></pre> <p>To use PennyLane for variational quantum algorithms:</p> <pre><code>pip install probabilistic-quantum-reasoner[pennylane]\n</code></pre> <p>For all quantum backends:</p> <pre><code>pip install probabilistic-quantum-reasoner[quantum]\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For development and contributing:</p> <pre><code>pip install probabilistic-quantum-reasoner[dev]\n</code></pre> <p>This includes testing, documentation, and code quality tools.</p>"},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>NumPy 1.21+</li> <li>SciPy 1.7+</li> <li>NetworkX 2.6+</li> </ul>"},{"location":"getting-started/installation/#optional-requirements","title":"Optional Requirements","text":"<ul> <li>Qiskit 0.45+ (for IBM Quantum backend)</li> <li>PennyLane 0.30+ (for variational algorithms)</li> <li>Matplotlib 3.5+ (for visualization)</li> </ul>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>Verify your installation:</p> <pre><code>import probabilistic_quantum_reasoner as pqr\nprint(f\"Version: {pqr.__version__}\")\n\n# Test basic functionality\nfrom probabilistic_quantum_reasoner.backends import ClassicalSimulator\nbackend = ClassicalSimulator()\nprint(\"Classical simulator ready!\")\n\n# Test quantum backends (if installed)\ntry:\n    from probabilistic_quantum_reasoner.backends import QiskitBackend\n    qiskit_backend = QiskitBackend()\n    print(\"Qiskit backend available!\")\nexcept ImportError:\n    print(\"Qiskit backend not installed\")\n\ntry:\n    from probabilistic_quantum_reasoner.backends import PennyLaneBackend\n    pennylane_backend = PennyLaneBackend()\n    print(\"PennyLane backend available!\")\nexcept ImportError:\n    print(\"PennyLane backend not installed\")\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Continue with the Quick Start Guide</li> <li>Explore Basic Examples</li> <li>Read the Architecture Overview</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will walk you through creating your first quantum Bayesian network and performing inference.</p>"},{"location":"getting-started/quickstart/#your-first-quantum-network","title":"Your First Quantum Network","text":"<p>Let's build a simple network that models the relationship between weather and mood using quantum superposition.</p>"},{"location":"getting-started/quickstart/#step-1-import-required-components","title":"Step 1: Import Required Components","text":"<pre><code>import numpy as np\nfrom probabilistic_quantum_reasoner import QuantumBayesianNetwork\nfrom probabilistic_quantum_reasoner.backends import ClassicalSimulator\n</code></pre>"},{"location":"getting-started/quickstart/#step-2-create-the-network","title":"Step 2: Create the Network","text":"<pre><code># Initialize with classical simulator (no quantum hardware needed)\nbackend = ClassicalSimulator()\nnetwork = QuantumBayesianNetwork(\"WeatherMoodModel\", backend)\n</code></pre>"},{"location":"getting-started/quickstart/#step-3-add-quantum-variables","title":"Step 3: Add Quantum Variables","text":"<pre><code># Weather as a quantum variable in superposition\nweather = network.add_quantum_node(\n    \"weather\",\n    outcome_space=[\"sunny\", \"cloudy\", \"rainy\"],\n    name=\"Weather Conditions\",\n    # Initial amplitudes represent quantum uncertainty\n    initial_amplitudes=np.array([0.6, 0.5, 0.4], dtype=complex)\n)\n\n# Mood influenced by weather (classical variable)\nmood = network.add_stochastic_node(\n    \"mood\",\n    outcome_space=[\"happy\", \"neutral\", \"sad\"],\n    name=\"Emotional State\"\n)\n</code></pre>"},{"location":"getting-started/quickstart/#step-4-define-relationships","title":"Step 4: Define Relationships","text":"<pre><code># Weather influences mood\nnetwork.add_edge(weather, mood)\n\n# Set conditional probabilities for mood given weather\nmood_cpt = {\n    (\"sunny\",): {\"happy\": 0.8, \"neutral\": 0.15, \"sad\": 0.05},\n    (\"cloudy\",): {\"happy\": 0.3, \"neutral\": 0.5, \"sad\": 0.2},\n    (\"rainy\",): {\"happy\": 0.1, \"neutral\": 0.3, \"sad\": 0.6}\n}\nnetwork.set_conditional_probability_table(mood, mood_cpt)\n</code></pre>"},{"location":"getting-started/quickstart/#step-5-perform-inference","title":"Step 5: Perform Inference","text":"<pre><code># Query: What's the probability of being happy?\nresult = network.infer(query_nodes=[\"mood\"])\nprint(\"Unconditional mood probabilities:\")\nfor state, prob in result.marginal_probabilities[\"mood\"].items():\n    print(f\"  P(mood={state}) = {prob:.3f}\")\n\n# Conditional inference: Given it's sunny, what's P(happy)?\nsunny_result = network.infer(\n    evidence={\"weather\": \"sunny\"},\n    query_nodes=[\"mood\"]\n)\nprint(f\"\\nP(mood=happy|weather=sunny) = {sunny_result.marginal_probabilities['mood']['happy']:.3f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#step-6-quantum-effects","title":"Step 6: Quantum Effects","text":"<pre><code># Demonstrate quantum superposition\nprint(\"\\nQuantum weather state:\")\nweather_state = network.get_quantum_state(\"weather\")\nfor i, outcome in enumerate([\"sunny\", \"cloudy\", \"rainy\"]):\n    amplitude = weather_state.amplitudes[i]\n    probability = abs(amplitude) ** 2\n    print(f\"  |{outcome}\u27e9: amplitude={amplitude:.3f}, P={probability:.3f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#expected-output","title":"Expected Output","text":"<pre><code>Unconditional mood probabilities:\n  P(mood=happy) = 0.542\n  P(mood=neutral) = 0.312\n  P(mood=sad) = 0.146\n\nP(mood=happy|weather=sunny) = 0.800\n\nQuantum weather state:\n  |sunny\u27e9: amplitude=0.600+0.000j, P=0.360\n  |cloudy\u27e9: amplitude=0.500+0.000j, P=0.250\n  |rainy\u27e9: amplitude=0.400+0.000j, P=0.160</code></pre>"},{"location":"getting-started/quickstart/#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":""},{"location":"getting-started/quickstart/#quantum-superposition","title":"Quantum Superposition","text":"<p>The weather variable exists in a superposition of all possible states, with amplitudes determining the probability of each outcome.</p>"},{"location":"getting-started/quickstart/#hybrid-reasoning","title":"Hybrid Reasoning","text":"<p>Classical probabilistic reasoning (conditional probability tables) combined with quantum uncertainty representation.</p>"},{"location":"getting-started/quickstart/#born-rule","title":"Born Rule","text":"<p>Quantum probabilities follow the Born rule: P(outcome) = |amplitude|\u00b2</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've created your first quantum Bayesian network, explore:</p> <ol> <li>Quantum Entanglement: Create correlated quantum variables</li> <li>Causal Inference: Perform interventions and counterfactual reasoning</li> <li>Advanced Examples: More complex real-world scenarios</li> <li>Quantum Backends: Using real quantum hardware</li> </ol>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quickstart/#evidence-based-reasoning","title":"Evidence-Based Reasoning","text":"<pre><code># Multiple evidence variables\nevidence = {\"weather\": \"rainy\", \"temperature\": \"cold\"}\nresult = network.infer(evidence=evidence, query_nodes=[\"mood\", \"activity\"])\n</code></pre>"},{"location":"getting-started/quickstart/#batch-inference","title":"Batch Inference","text":"<pre><code># Multiple queries at once\nqueries = [\"mood\", \"activity\", \"energy_level\"]\nresult = network.infer(query_nodes=queries)\n</code></pre>"},{"location":"getting-started/quickstart/#temporal-reasoning","title":"Temporal Reasoning","text":"<pre><code># Add time-dependent variables\nmorning_weather = network.add_quantum_node(\"morning_weather\", ...)\nevening_mood = network.add_stochastic_node(\"evening_mood\", ...)\nnetwork.add_edge(morning_weather, evening_mood)\n</code></pre> <p>Continue with Basic Examples to see more sophisticated use cases.</p>"},{"location":"guide/causal/","title":"Causal Reasoning","text":"<p>This guide covers causal inference, interventions, and counterfactual reasoning in quantum Bayesian networks using do-calculus and quantum causal models.</p>"},{"location":"guide/causal/#introduction-to-quantum-causality","title":"Introduction to Quantum Causality","text":"<p>Quantum causal reasoning extends classical causal inference to quantum systems, allowing for interventions on quantum variables and counterfactual analysis with quantum superposition.</p>"},{"location":"guide/causal/#basic-causal-operations","title":"Basic Causal Operations","text":""},{"location":"guide/causal/#do-calculus-interventions","title":"Do-Calculus Interventions","text":"<pre><code>from probabilistic_quantum_reasoner import QuantumBayesianNetwork\nfrom probabilistic_quantum_reasoner.backends import ClassicalSimulator\nimport numpy as np\n\n# Create causal network\nbackend = ClassicalSimulator()\nnetwork = QuantumBayesianNetwork(\"CausalDemo\", backend)\n\n# Causal chain: Weather \u2192 Mood \u2192 Activity\nweather = network.add_quantum_node(\n    \"weather\",\n    outcome_space=[\"sunny\", \"rainy\"],\n    initial_amplitudes=np.array([0.8, 0.6], dtype=complex)\n)\n\nmood = network.add_stochastic_node(\"mood\", outcome_space=[\"happy\", \"sad\"])\nactivity = network.add_stochastic_node(\"activity\", outcome_space=[\"indoor\", \"outdoor\"])\n\n# Add causal edges\nnetwork.add_edge(weather, mood)\nnetwork.add_edge(mood, activity)\n\n# Observational distribution\nobservational = network.infer(query_nodes=[\"activity\"])\nprint(f\"Observational P(activity): {observational.marginal_probabilities['activity']}\")\n\n# Interventional distribution: do(weather = sunny)\ninterventional = network.intervene(\n    interventions={\"weather\": \"sunny\"},\n    query_nodes=[\"activity\"]\n)\nprint(f\"Interventional P(activity | do(weather=sunny)): {interventional.marginal_probabilities['activity']}\")\n</code></pre>"},{"location":"guide/causal/#quantum-interventions","title":"Quantum Interventions","text":"<pre><code># Intervention on quantum node with specific amplitude pattern\nquantum_intervention = network.intervene(\n    interventions={\n        \"weather\": {\n            \"type\": \"quantum\",\n            \"amplitudes\": np.array([1, 0], dtype=complex)  # Force to |sunny\u27e9\n        }\n    },\n    query_nodes=[\"mood\", \"activity\"]\n)\n\nprint(f\"Quantum intervention result: {quantum_intervention.marginal_probabilities}\")\n\n# Intervention with superposition state\nsuperposition_intervention = network.intervene(\n    interventions={\n        \"weather\": {\n            \"type\": \"quantum\", \n            \"amplitudes\": np.array([1/np.sqrt(2), 1/np.sqrt(2)], dtype=complex)\n        }\n    },\n    query_nodes=[\"activity\"]\n)\n\nprint(f\"Superposition intervention: {superposition_intervention.marginal_probabilities}\")\n</code></pre>"},{"location":"guide/causal/#counterfactual-reasoning","title":"Counterfactual Reasoning","text":""},{"location":"guide/causal/#classical-counterfactuals","title":"Classical Counterfactuals","text":"<pre><code># Factual scenario: Weather was rainy, mood was sad\nfactual_evidence = {\n    \"weather\": \"rainy\",\n    \"mood\": \"sad\"\n}\n\n# Counterfactual question: What if weather had been sunny instead?\ncounterfactual_result = network.counterfactual_inference(\n    factual_evidence=factual_evidence,\n    counterfactual_intervention={\"weather\": \"sunny\"},\n    query_nodes=[\"mood\", \"activity\"]\n)\n\nprint(\"Counterfactual Analysis:\")\nprint(f\"Factual mood: {counterfactual_result['factual_outcome']['mood']}\")\nprint(f\"Counterfactual mood: {counterfactual_result['counterfactual_outcome']['mood']}\")\nprint(f\"Causal effect on mood: {counterfactual_result['causal_effect']['mood']}\")\n</code></pre>"},{"location":"guide/causal/#quantum-counterfactuals","title":"Quantum Counterfactuals","text":"<pre><code># Quantum counterfactual: What if we had prepared a different quantum state?\nquantum_counterfactual = network.counterfactual_inference(\n    factual_evidence={\"weather\": \"rainy\"},\n    counterfactual_intervention={\n        \"weather\": {\n            \"type\": \"quantum\",\n            \"amplitudes\": np.array([0.6, 0.8], dtype=complex)\n        }\n    },\n    query_nodes=[\"mood\"]\n)\n\nprint(\"Quantum Counterfactual:\")\nprint(f\"Quantum causal effect: {quantum_counterfactual['quantum_causal_effect']}\")\n</code></pre>"},{"location":"guide/causal/#causal-discovery","title":"Causal Discovery","text":""},{"location":"guide/causal/#quantum-causal-structure-learning","title":"Quantum Causal Structure Learning","text":"<pre><code># Learn causal structure from quantum data\ndef learn_quantum_causal_structure(data, nodes):\n    \"\"\"Learn causal DAG from quantum measurement data.\"\"\"\n\n    from probabilistic_quantum_reasoner.causal import QuantumCausalDiscovery\n\n    discoverer = QuantumCausalDiscovery()\n\n    # Score different causal structures\n    candidate_structures = discoverer.enumerate_candidate_dags(nodes)\n\n    best_structure = None\n    best_score = -np.inf\n\n    for structure in candidate_structures:\n        score = discoverer.score_structure(structure, data)\n        if score &gt; best_score:\n            best_score = score\n            best_structure = structure\n\n    return best_structure, best_score\n\n# Example usage with simulated data\nsimulated_data = network.simulate_data(n_samples=1000)\nlearned_structure, score = learn_quantum_causal_structure(\n    simulated_data, \n    [\"weather\", \"mood\", \"activity\"]\n)\n\nprint(f\"Learned causal structure: {learned_structure}\")\nprint(f\"Structure score: {score}\")\n</code></pre>"},{"location":"guide/causal/#constraint-based-discovery","title":"Constraint-Based Discovery","text":"<pre><code># Quantum PC algorithm for causal discovery\ndef quantum_pc_algorithm(data, alpha=0.05):\n    \"\"\"Quantum version of PC algorithm for causal discovery.\"\"\"\n\n    nodes = list(data.columns)\n    n_nodes = len(nodes)\n\n    # Initialize complete graph\n    adjacency_matrix = np.ones((n_nodes, n_nodes)) - np.eye(n_nodes)\n\n    # Phase 1: Remove edges using conditional independence tests\n    for i in range(n_nodes):\n        for j in range(i+1, n_nodes):\n            if adjacency_matrix[i, j] == 1:\n                # Test conditional independence with quantum correlations\n                p_value = quantum_conditional_independence_test(\n                    data, nodes[i], nodes[j], conditioning_set=[]\n                )\n\n                if p_value &gt; alpha:\n                    adjacency_matrix[i, j] = 0\n                    adjacency_matrix[j, i] = 0\n\n    # Phase 2: Orient edges using quantum causal principles\n    oriented_graph = orient_quantum_edges(adjacency_matrix, nodes, data)\n\n    return oriented_graph\n\ndef quantum_conditional_independence_test(data, var1, var2, conditioning_set):\n    \"\"\"Test conditional independence using quantum mutual information.\"\"\"\n\n    # Compute quantum mutual information\n    joint_entropy = compute_quantum_entropy(data[[var1, var2] + conditioning_set])\n    marginal_entropy1 = compute_quantum_entropy(data[[var1] + conditioning_set])\n    marginal_entropy2 = compute_quantum_entropy(data[[var2] + conditioning_set])\n    conditioning_entropy = compute_quantum_entropy(data[conditioning_set]) if conditioning_set else 0\n\n    quantum_mi = marginal_entropy1 + marginal_entropy2 - joint_entropy - conditioning_entropy\n\n    # Convert to p-value (simplified)\n    p_value = np.exp(-abs(quantum_mi))\n\n    return p_value\n\n# Apply quantum PC algorithm\ndiscovered_graph = quantum_pc_algorithm(simulated_data)\nprint(f\"Discovered causal graph: {discovered_graph}\")\n</code></pre>"},{"location":"guide/causal/#causal-effect-identification","title":"Causal Effect Identification","text":""},{"location":"guide/causal/#backdoor-criterion","title":"Backdoor Criterion","text":"<pre><code># Check backdoor criterion for causal identification\ndef check_backdoor_criterion(network, treatment, outcome, adjustment_set):\n    \"\"\"Check if adjustment set satisfies backdoor criterion.\"\"\"\n\n    # Find all paths from treatment to outcome\n    all_paths = network.find_all_paths(treatment, outcome)\n\n    # Check each path for backdoor property\n    for path in all_paths:\n        if is_backdoor_path(path, treatment, outcome):\n            # Check if adjustment set blocks this path\n            if not is_path_blocked(path, adjustment_set, network):\n                return False, f\"Backdoor path not blocked: {path}\"\n\n    # Check that adjustment set doesn't contain descendants of treatment\n    treatment_descendants = network.get_descendants(treatment)\n    if any(var in treatment_descendants for var in adjustment_set):\n        return False, \"Adjustment set contains treatment descendants\"\n\n    return True, \"Backdoor criterion satisfied\"\n\n# Example: Check if {mood} satisfies backdoor criterion for weather\u2192activity\nis_valid, message = check_backdoor_criterion(\n    network, \n    treatment=\"weather\", \n    outcome=\"activity\", \n    adjustment_set=[\"mood\"]\n)\n\nprint(f\"Backdoor criterion check: {is_valid}\")\nprint(f\"Message: {message}\")\n</code></pre>"},{"location":"guide/causal/#front-door-criterion","title":"Front-door Criterion","text":"<pre><code># Apply front-door criterion when backdoor is not available\ndef frontdoor_adjustment(network, treatment, outcome, mediator):\n    \"\"\"Compute causal effect using front-door adjustment.\"\"\"\n\n    # Step 1: Compute P(mediator | do(treatment))\n    mediator_given_treatment = {}\n    for treatment_val in network.nodes[treatment].outcome_space:\n        result = network.intervene(\n            interventions={treatment: treatment_val},\n            query_nodes=[mediator]\n        )\n        mediator_given_treatment[treatment_val] = result.marginal_probabilities[mediator]\n\n    # Step 2: Compute P(outcome | do(mediator), treatment)\n    outcome_given_mediator_treatment = {}\n    for treatment_val in network.nodes[treatment].outcome_space:\n        for mediator_val in network.nodes[mediator].outcome_space:\n            result = network.intervene(\n                interventions={mediator: mediator_val},\n                evidence={treatment: treatment_val},\n                query_nodes=[outcome]\n            )\n            outcome_given_mediator_treatment[(treatment_val, mediator_val)] = \\\n                result.marginal_probabilities[outcome]\n\n    # Step 3: Marginalize to get P(outcome | do(treatment))\n    causal_effect = {}\n    for treatment_val in network.nodes[treatment].outcome_space:\n        effect_dist = {}\n        for outcome_val in network.nodes[outcome].outcome_space:\n            total_prob = 0\n            for mediator_val in network.nodes[mediator].outcome_space:\n                prob_mediator = mediator_given_treatment[treatment_val][mediator_val]\n                prob_outcome = outcome_given_mediator_treatment[(treatment_val, mediator_val)][outcome_val]\n                total_prob += prob_mediator * prob_outcome\n            effect_dist[outcome_val] = total_prob\n        causal_effect[treatment_val] = effect_dist\n\n    return causal_effect\n\n# Example front-door adjustment\nif network.satisfies_frontdoor_criterion(\"weather\", \"activity\", \"mood\"):\n    frontdoor_effect = frontdoor_adjustment(network, \"weather\", \"activity\", \"mood\")\n    print(f\"Front-door causal effect: {frontdoor_effect}\")\n</code></pre>"},{"location":"guide/causal/#quantum-causal-models","title":"Quantum Causal Models","text":""},{"location":"guide/causal/#quantum-structural-causal-models","title":"Quantum Structural Causal Models","text":"<pre><code>class QuantumStructuralCausalModel:\n    \"\"\"Quantum extension of structural causal models.\"\"\"\n\n    def __init__(self, network):\n        self.network = network\n        self.structural_equations = {}\n        self.noise_terms = {}\n\n    def add_structural_equation(self, variable, equation, noise_distribution):\n        \"\"\"Add structural equation for a variable.\"\"\"\n        self.structural_equations[variable] = equation\n        self.noise_terms[variable] = noise_distribution\n\n    def add_quantum_structural_equation(self, variable, quantum_equation, noise_operator):\n        \"\"\"Add quantum structural equation.\"\"\"\n        self.structural_equations[variable] = {\n            \"type\": \"quantum\",\n            \"equation\": quantum_equation,\n            \"noise\": noise_operator\n        }\n\n    def simulate_intervention(self, interventions, n_samples=1000):\n        \"\"\"Simulate data under interventions.\"\"\"\n\n        # Create modified structural equations\n        modified_equations = self.structural_equations.copy()\n\n        for var, value in interventions.items():\n            if isinstance(value, dict) and value.get(\"type\") == \"quantum\":\n                # Quantum intervention\n                modified_equations[var] = {\n                    \"type\": \"quantum_intervention\",\n                    \"amplitudes\": value[\"amplitudes\"]\n                }\n            else:\n                # Classical intervention\n                modified_equations[var] = {\n                    \"type\": \"classical_intervention\",\n                    \"value\": value\n                }\n\n        # Generate samples using modified equations\n        samples = []\n        for _ in range(n_samples):\n            sample = self._generate_sample(modified_equations)\n            samples.append(sample)\n\n        return samples\n\n    def _generate_sample(self, equations):\n        \"\"\"Generate single sample from structural equations.\"\"\"\n        sample = {}\n\n        # Topological ordering\n        ordered_vars = self.network.topological_sort()\n\n        for var in ordered_vars:\n            equation = equations[var]\n\n            if equation.get(\"type\") == \"quantum\":\n                # Quantum structural equation\n                parents = self.network.get_parents(var)\n                parent_values = {p: sample[p] for p in parents if p in sample}\n\n                # Apply quantum equation\n                quantum_state = equation[\"equation\"](parent_values)\n\n                # Add quantum noise\n                noisy_state = equation[\"noise\"].apply(quantum_state)\n\n                # Measure to get classical value\n                measurement_result = self.network.measure_quantum_state(noisy_state)\n                sample[var] = measurement_result\n\n            elif equation.get(\"type\") == \"quantum_intervention\":\n                # Quantum intervention\n                amplitudes = equation[\"amplitudes\"]\n                measurement_result = self.network.measure_amplitudes(amplitudes)\n                sample[var] = measurement_result\n\n            elif equation.get(\"type\") == \"classical_intervention\":\n                # Classical intervention\n                sample[var] = equation[\"value\"]\n\n            else:\n                # Classical structural equation\n                parents = self.network.get_parents(var)\n                parent_values = {p: sample[p] for p in parents if p in sample}\n\n                # Apply classical equation with noise\n                noise = self.noise_terms[var].sample()\n                sample[var] = equation(parent_values, noise)\n\n        return sample\n\n# Create quantum SCM\nqscm = QuantumStructuralCausalModel(network)\n\n# Add structural equations\nqscm.add_quantum_structural_equation(\n    \"weather\",\n    lambda parents: np.array([0.8, 0.6], dtype=complex),  # Intrinsic weather distribution\n    QuantumGate.phase(np.pi/8)  # Quantum noise\n)\n\nqscm.add_structural_equation(\n    \"mood\", \n    lambda parents, noise: \"happy\" if (parents.get(\"weather\") == \"sunny\" and noise &gt; 0.2) else \"sad\",\n    lambda: np.random.uniform(0, 1)  # Uniform noise\n)\n\n# Simulate intervention\nintervention_data = qscm.simulate_intervention(\n    interventions={\"weather\": {\"type\": \"quantum\", \"amplitudes\": np.array([1, 0], dtype=complex)}},\n    n_samples=1000\n)\n\nprint(f\"Intervention simulation complete: {len(intervention_data)} samples\")\n</code></pre>"},{"location":"guide/causal/#mediation-analysis","title":"Mediation Analysis","text":""},{"location":"guide/causal/#quantum-mediation","title":"Quantum Mediation","text":"<pre><code>def quantum_mediation_analysis(network, treatment, mediator, outcome):\n    \"\"\"Perform mediation analysis with quantum mediator.\"\"\"\n\n    # Natural Direct Effect (NDE): effect not through mediator\n    nde = {}\n    for treatment_val in network.nodes[treatment].outcome_space:\n        # Fix mediator at its natural value when treatment = reference\n        reference_val = network.nodes[treatment].outcome_space[0]\n\n        mediator_natural = network.infer(\n            evidence={treatment: reference_val},\n            query_nodes=[mediator]\n        )\n\n        # Sample mediator value from natural distribution\n        mediator_sample = max(\n            mediator_natural.marginal_probabilities[mediator].items(),\n            key=lambda x: x[1]\n        )[0]\n\n        # Compute outcome under intervention\n        nde_result = network.intervene(\n            interventions={treatment: treatment_val, mediator: mediator_sample},\n            query_nodes=[outcome]\n        )\n\n        nde[treatment_val] = nde_result.marginal_probabilities[outcome]\n\n    # Natural Indirect Effect (NIE): effect through mediator\n    nie = {}\n    for treatment_val in network.nodes[treatment].outcome_space:\n        reference_val = network.nodes[treatment].outcome_space[0]\n\n        # Mediator under treatment\n        mediator_treated = network.infer(\n            evidence={treatment: treatment_val},\n            query_nodes=[mediator]\n        )\n\n        # If mediator is quantum, preserve superposition\n        if hasattr(network.nodes[mediator], 'quantum_state'):\n            # Quantum mediation preserves superposition\n            mediator_amplitudes = network.get_quantum_mediator_amplitudes(\n                treatment_val, mediator\n            )\n\n            nie_result = network.quantum_mediation_effect(\n                treatment=reference_val,\n                mediator_amplitudes=mediator_amplitudes,\n                outcome=outcome\n            )\n        else:\n            # Classical mediation\n            mediator_sample = max(\n                mediator_treated.marginal_probabilities[mediator].items(),\n                key=lambda x: x[1]\n            )[0]\n\n            nie_result = network.intervene(\n                interventions={treatment: reference_val, mediator: mediator_sample},\n                query_nodes=[outcome]\n            )\n\n        nie[treatment_val] = nie_result.marginal_probabilities[outcome]\n\n    # Total Effect = NDE + NIE\n    total_effect = {}\n    for treatment_val in network.nodes[treatment].outcome_space:\n        te_result = network.intervene(\n            interventions={treatment: treatment_val},\n            query_nodes=[outcome]\n        )\n        total_effect[treatment_val] = te_result.marginal_probabilities[outcome]\n\n    return {\n        \"natural_direct_effect\": nde,\n        \"natural_indirect_effect\": nie,\n        \"total_effect\": total_effect,\n        \"proportion_mediated\": compute_proportion_mediated(nde, nie, total_effect)\n    }\n\n# Perform quantum mediation analysis\nmediation_results = quantum_mediation_analysis(\n    network, \n    treatment=\"weather\", \n    mediator=\"mood\", \n    outcome=\"activity\"\n)\n\nprint(\"Mediation Analysis Results:\")\nfor effect_type, effects in mediation_results.items():\n    print(f\"{effect_type}: {effects}\")\n</code></pre>"},{"location":"guide/causal/#causal-inference-from-quantum-data","title":"Causal Inference from Quantum Data","text":""},{"location":"guide/causal/#quantum-bootstrap","title":"Quantum Bootstrap","text":"<pre><code>def quantum_bootstrap_causal_effect(network, treatment, outcome, n_bootstrap=1000):\n    \"\"\"Bootstrap confidence intervals for quantum causal effects.\"\"\"\n\n    bootstrap_effects = []\n\n    for _ in range(n_bootstrap):\n        # Sample quantum states with noise\n        noisy_network = network.add_quantum_noise(noise_level=0.1)\n\n        # Compute causal effect\n        causal_result = noisy_network.intervene(\n            interventions={treatment: \"sunny\"},  # Example intervention\n            query_nodes=[outcome]\n        )\n\n        effect_size = causal_result.marginal_probabilities[outcome][\"outdoor\"]\n        bootstrap_effects.append(effect_size)\n\n    # Compute confidence interval\n    bootstrap_effects = np.array(bootstrap_effects)\n    ci_lower = np.percentile(bootstrap_effects, 2.5)\n    ci_upper = np.percentile(bootstrap_effects, 97.5)\n\n    return {\n        \"point_estimate\": np.mean(bootstrap_effects),\n        \"confidence_interval\": (ci_lower, ci_upper),\n        \"bootstrap_distribution\": bootstrap_effects\n    }\n\n# Bootstrap causal effect estimation\nbootstrap_result = quantum_bootstrap_causal_effect(\n    network, \"weather\", \"activity\"\n)\n\nprint(f\"Causal effect estimate: {bootstrap_result['point_estimate']:.3f}\")\nprint(f\"95% CI: {bootstrap_result['confidence_interval']}\")\n</code></pre>"},{"location":"guide/causal/#advanced-causal-topics","title":"Advanced Causal Topics","text":""},{"location":"guide/causal/#causal-sufficiency","title":"Causal Sufficiency","text":"<pre><code>def test_causal_sufficiency(network, observed_variables):\n    \"\"\"Test if observed variables are causally sufficient.\"\"\"\n\n    # Test vanishing tetrad differences for linear quantum systems\n    tetrads = []\n\n    for i in range(len(observed_variables)):\n        for j in range(i+1, len(observed_variables)):\n            for k in range(j+1, len(observed_variables)):\n                for l in range(k+1, len(observed_variables)):\n                    vars_quartet = [observed_variables[i], observed_variables[j], \n                                  observed_variables[k], observed_variables[l]]\n\n                    # Compute quantum tetrad difference\n                    tetrad_diff = compute_quantum_tetrad_difference(network, vars_quartet)\n                    tetrads.append(tetrad_diff)\n\n    # Test if tetrads are close to zero\n    max_tetrad = max(abs(t) for t in tetrads)\n    is_sufficient = max_tetrad &lt; 0.1  # Threshold for sufficiency\n\n    return {\n        \"causally_sufficient\": is_sufficient,\n        \"max_tetrad_difference\": max_tetrad,\n        \"all_tetrads\": tetrads\n    }\n\ndef compute_quantum_tetrad_difference(network, variables):\n    \"\"\"Compute tetrad difference for quantum variables.\"\"\"\n    # Simplified quantum tetrad computation\n    a, b, c, d = variables\n\n    # Quantum covariances\n    cov_ab_cd = compute_quantum_covariance(network, [a, b], [c, d])\n    cov_ac_bd = compute_quantum_covariance(network, [a, c], [b, d])\n    cov_ad_bc = compute_quantum_covariance(network, [a, d], [b, c])\n\n    return cov_ab_cd - cov_ac_bd - cov_ad_bc\n\n# Test causal sufficiency\nsufficiency_test = test_causal_sufficiency(\n    network, [\"weather\", \"mood\", \"activity\"]\n)\nprint(f\"Causal sufficiency test: {sufficiency_test}\")\n</code></pre>"},{"location":"guide/causal/#best-practices","title":"Best Practices","text":""},{"location":"guide/causal/#causal-modeling-guidelines","title":"Causal Modeling Guidelines","text":"<ol> <li>Clear Causal Assumptions: Explicitly state causal assumptions and domain knowledge</li> <li>Quantum-Classical Separation: Distinguish between quantum and classical causal mechanisms  </li> <li>Temporal Ordering: Ensure causes precede effects in time</li> <li>Confounding Control: Identify and control for confounding variables</li> <li>Sensitivity Analysis: Test robustness to modeling assumptions</li> </ol>"},{"location":"guide/causal/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Confusing Association and Causation: Correlation \u2260 Causation in quantum systems too</li> <li>Ignoring Quantum Measurement Effects: Measurement can affect causal relationships</li> <li>Post-Treatment Bias: Don't condition on variables affected by treatment</li> <li>Quantum Decoherence: Account for decoherence in causal models</li> <li>Simpson's Paradox: Aggregation can reverse causal effects</li> </ol>"},{"location":"guide/causal/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Variational Methods for causal inference optimization</li> <li>Explore practical Examples of causal reasoning</li> <li>See Advanced Topics for quantum causal discovery</li> <li>Check API Reference for causal inference functions</li> </ul>"},{"location":"guide/inference/","title":"Inference Methods","text":"<p>This guide covers the various inference algorithms available in the Probabilistic Quantum Reasoner for extracting information from quantum-classical hybrid networks.</p>"},{"location":"guide/inference/#overview-of-inference","title":"Overview of Inference","text":"<p>Inference in quantum Bayesian networks involves computing probability distributions over query variables given evidence, leveraging both classical probabilistic reasoning and quantum amplitude-based computation.</p>"},{"location":"guide/inference/#basic-inference","title":"Basic Inference","text":""},{"location":"guide/inference/#simple-queries","title":"Simple Queries","text":"<pre><code>from probabilistic_quantum_reasoner import QuantumBayesianNetwork\nfrom probabilistic_quantum_reasoner.backends import ClassicalSimulator\nimport numpy as np\n\n# Create example network\nbackend = ClassicalSimulator()\nnetwork = QuantumBayesianNetwork(\"InferenceDemo\", backend)\n\n# Add nodes\nweather = network.add_quantum_node(\n    \"weather\",\n    outcome_space=[\"sunny\", \"rainy\"],\n    initial_amplitudes=np.array([0.8, 0.6], dtype=complex)\n)\n\nmood = network.add_stochastic_node(\"mood\", outcome_space=[\"happy\", \"sad\"])\nactivity = network.add_hybrid_node(\"activity\", outcome_space=[\"indoor\", \"outdoor\"], mixing_parameter=0.7)\n\n# Add edges\nnetwork.add_edge(weather, mood)\nnetwork.add_edge(mood, activity)\n\n# Basic inference without evidence\nresult = network.infer(query_nodes=[\"mood\", \"activity\"])\nprint(f\"Mood distribution: {result.marginal_probabilities['mood']}\")\nprint(f\"Activity distribution: {result.marginal_probabilities['activity']}\")\n</code></pre>"},{"location":"guide/inference/#conditional-inference","title":"Conditional Inference","text":"<pre><code># Inference with evidence\nevidence = {\"weather\": \"sunny\"}\nconditional_result = network.infer(\n    query_nodes=[\"mood\", \"activity\"],\n    evidence=evidence\n)\n\nprint(f\"Mood given sunny weather: {conditional_result.marginal_probabilities['mood']}\")\nprint(f\"Activity given sunny weather: {conditional_result.marginal_probabilities['activity']}\")\n\n# Multiple evidence variables\nmulti_evidence = {\"weather\": \"sunny\", \"mood\": \"happy\"}\nmulti_result = network.infer(\n    query_nodes=[\"activity\"],\n    evidence=multi_evidence\n)\nprint(f\"Activity given sunny weather and happy mood: {multi_result.marginal_probabilities['activity']}\")\n</code></pre>"},{"location":"guide/inference/#joint-distributions","title":"Joint Distributions","text":"<pre><code># Joint probability distributions\njoint_result = network.infer(\n    query_nodes=[\"weather\", \"mood\"],\n    return_joint=True\n)\n\nprint(\"Joint distribution P(weather, mood):\")\nfor weather_val in [\"sunny\", \"rainy\"]:\n    for mood_val in [\"happy\", \"sad\"]:\n        joint_prob = joint_result.joint_probabilities.get((weather_val, mood_val), 0)\n        print(f\"P(weather={weather_val}, mood={mood_val}) = {joint_prob:.3f}\")\n</code></pre>"},{"location":"guide/inference/#belief-propagation","title":"Belief Propagation","text":""},{"location":"guide/inference/#quantum-message-passing","title":"Quantum Message Passing","text":"<pre><code># Use belief propagation algorithm explicitly\nbp_result = network.infer(\n    query_nodes=[\"activity\"],\n    evidence={\"weather\": \"rainy\"},\n    method=\"belief_propagation\",\n    max_iterations=50,\n    convergence_threshold=1e-6\n)\n\nprint(f\"Belief propagation result: {bp_result.marginal_probabilities['activity']}\")\nprint(f\"Converged: {bp_result.converged}\")\nprint(f\"Iterations: {bp_result.iterations}\")\n</code></pre>"},{"location":"guide/inference/#message-analysis","title":"Message Analysis","text":"<pre><code># Access detailed message passing information\ndetailed_result = network.infer(\n    query_nodes=[\"mood\"],\n    method=\"belief_propagation\",\n    return_messages=True\n)\n\n# Examine messages between nodes\nfor edge, message in detailed_result.messages.items():\n    parent, child = edge\n    print(f\"Message from {parent} to {child}:\")\n    print(f\"  Amplitudes: {message.amplitudes}\")\n    print(f\"  Probabilities: {np.abs(message.amplitudes)**2}\")\n</code></pre>"},{"location":"guide/inference/#variational-inference","title":"Variational Inference","text":""},{"location":"guide/inference/#variational-quantum-eigensolver-vqe","title":"Variational Quantum Eigensolver (VQE)","text":"<pre><code># Use variational inference for complex distributions\nvariational_result = network.infer(\n    query_nodes=[\"weather\", \"mood\"],\n    method=\"variational\",\n    max_iterations=100,\n    optimization_method=\"L-BFGS-B\"\n)\n\nprint(f\"Variational inference result: {variational_result.marginal_probabilities}\")\nprint(f\"Final cost: {variational_result.final_cost}\")\nprint(f\"Optimization success: {variational_result.optimization_success}\")\n</code></pre>"},{"location":"guide/inference/#circuit-parameters","title":"Circuit Parameters","text":"<pre><code># Access optimized quantum circuit parameters\nif hasattr(variational_result, 'optimal_parameters'):\n    params = variational_result.optimal_parameters\n    print(f\"Optimized circuit parameters: {params}\")\n\n    # Visualize parameter evolution\n    if hasattr(variational_result, 'parameter_history'):\n        import matplotlib.pyplot as plt\n\n        history = variational_result.parameter_history\n        plt.figure(figsize=(10, 6))\n        for i, param_trace in enumerate(history.T):\n            plt.plot(param_trace, label=f'Parameter {i}')\n        plt.xlabel('Optimization Step')\n        plt.ylabel('Parameter Value')\n        plt.title('Variational Parameter Evolution')\n        plt.legend()\n        plt.show()\n</code></pre>"},{"location":"guide/inference/#custom-ansatz","title":"Custom Ansatz","text":"<pre><code># Define custom variational ansatz\ndef custom_ansatz(parameters, n_qubits):\n    \"\"\"Custom variational circuit ansatz.\"\"\"\n    from probabilistic_quantum_reasoner.core.operators import QuantumGate\n\n    circuit = []\n\n    # Layer 1: Individual rotations\n    for i in range(n_qubits):\n        circuit.append(('RY', i, parameters[i]))\n\n    # Layer 2: Entangling gates\n    for i in range(n_qubits - 1):\n        circuit.append(('CNOT', i, i + 1))\n\n    # Layer 3: Final rotations\n    for i in range(n_qubits):\n        circuit.append(('RZ', i, parameters[n_qubits + i]))\n\n    return circuit\n\n# Use custom ansatz in inference\ncustom_result = network.infer(\n    query_nodes=[\"weather\", \"mood\"],\n    method=\"variational\",\n    ansatz=custom_ansatz,\n    n_parameters=4  # 2 qubits \u00d7 2 parameters each\n)\n</code></pre>"},{"location":"guide/inference/#sampling-based-inference","title":"Sampling-Based Inference","text":""},{"location":"guide/inference/#quantum-sampling","title":"Quantum Sampling","text":"<pre><code># Sampling-based approximate inference\nsampling_result = network.infer(\n    query_nodes=[\"mood\", \"activity\"],\n    evidence={\"weather\": \"sunny\"},\n    method=\"sampling\",\n    n_samples=1000\n)\n\nprint(f\"Sampling result: {sampling_result.marginal_probabilities}\")\nprint(f\"Sample variance: {sampling_result.sample_variance}\")\nprint(f\"Effective sample size: {sampling_result.effective_sample_size}\")\n</code></pre>"},{"location":"guide/inference/#markov-chain-monte-carlo","title":"Markov Chain Monte Carlo","text":"<pre><code># MCMC sampling for complex posterior distributions\nmcmc_result = network.infer(\n    query_nodes=[\"weather\", \"mood\", \"activity\"],\n    method=\"mcmc\",\n    n_samples=5000,\n    burn_in=1000,\n    thin=5\n)\n\nprint(f\"MCMC marginals: {mcmc_result.marginal_probabilities}\")\nprint(f\"Acceptance rate: {mcmc_result.acceptance_rate}\")\nprint(f\"Chain convergence: {mcmc_result.r_hat}\")  # Gelman-Rubin statistic\n</code></pre>"},{"location":"guide/inference/#importance-sampling","title":"Importance Sampling","text":"<pre><code># Importance sampling with quantum proposal distribution\nimportance_result = network.infer(\n    query_nodes=[\"activity\"],\n    evidence={\"weather\": \"sunny\"},\n    method=\"importance_sampling\",\n    n_samples=2000,\n    proposal=\"quantum_uniform\"  # Use quantum superposition as proposal\n)\n\nprint(f\"Importance sampling result: {importance_result.marginal_probabilities}\")\nprint(f\"Effective sample size: {importance_result.effective_sample_size}\")\n</code></pre>"},{"location":"guide/inference/#exact-inference","title":"Exact Inference","text":""},{"location":"guide/inference/#quantum-amplitude-enumeration","title":"Quantum Amplitude Enumeration","text":"<pre><code># Exact inference by enumerating all quantum amplitudes\nexact_result = network.infer(\n    query_nodes=[\"weather\", \"mood\"],\n    method=\"exact\",\n    enumerate_amplitudes=True\n)\n\nprint(f\"Exact marginals: {exact_result.marginal_probabilities}\")\nprint(f\"Computation time: {exact_result.computation_time}\")\nprint(f\"Memory usage: {exact_result.memory_usage_mb} MB\")\n</code></pre>"},{"location":"guide/inference/#junction-tree-algorithm","title":"Junction Tree Algorithm","text":"<pre><code># Use junction tree for efficient exact inference\nif network.is_tree_decomposable():\n    junction_result = network.infer(\n        query_nodes=[\"activity\"],\n        method=\"junction_tree\"\n    )\n    print(f\"Junction tree result: {junction_result.marginal_probabilities}\")\nelse:\n    print(\"Network is not tree-decomposable, using alternative method\")\n</code></pre>"},{"location":"guide/inference/#approximate-inference","title":"Approximate Inference","text":""},{"location":"guide/inference/#loopy-belief-propagation","title":"Loopy Belief Propagation","text":"<pre><code># Loopy belief propagation for networks with cycles\nloopy_result = network.infer(\n    query_nodes=[\"mood\"],\n    method=\"loopy_belief_propagation\",\n    max_iterations=100,\n    damping_factor=0.5  # Damping to improve convergence\n)\n\nprint(f\"Loopy BP result: {loopy_result.marginal_probabilities}\")\nprint(f\"Converged: {loopy_result.converged}\")\n</code></pre>"},{"location":"guide/inference/#mean-field-approximation","title":"Mean Field Approximation","text":"<pre><code># Mean field variational approximation\nmean_field_result = network.infer(\n    query_nodes=[\"weather\", \"mood\", \"activity\"],\n    method=\"mean_field\",\n    max_iterations=50\n)\n\nprint(f\"Mean field marginals: {mean_field_result.marginal_probabilities}\")\nprint(f\"ELBO (Evidence Lower Bound): {mean_field_result.elbo}\")\n</code></pre>"},{"location":"guide/inference/#quantum-specific-inference","title":"Quantum-Specific Inference","text":""},{"location":"guide/inference/#grover-enhanced-search","title":"Grover-Enhanced Search","text":"<pre><code># Use Grover's algorithm for probabilistic search\ndef search_condition(state_dict):\n    \"\"\"Search condition: weather is sunny AND mood is happy.\"\"\"\n    return state_dict.get(\"weather\") == \"sunny\" and state_dict.get(\"mood\") == \"happy\"\n\ngrover_result = network.infer(\n    query_nodes=[\"weather\", \"mood\"],\n    method=\"grover_search\",\n    search_condition=search_condition,\n    max_iterations=None  # Optimal number of iterations\n)\n\nprint(f\"Grover search result: {grover_result.marginal_probabilities}\")\nprint(f\"Search success probability: {grover_result.success_probability}\")\n</code></pre>"},{"location":"guide/inference/#quantum-fourier-transform","title":"Quantum Fourier Transform","text":"<pre><code># QFT-based inference for periodic patterns\nqft_result = network.infer(\n    query_nodes=[\"weather\"],\n    method=\"quantum_fourier_transform\",\n    basis=\"frequency\"  # Frequency domain analysis\n)\n\nprint(f\"QFT frequency components: {qft_result.frequency_amplitudes}\")\nprint(f\"Dominant frequencies: {qft_result.dominant_frequencies}\")\n</code></pre>"},{"location":"guide/inference/#inference-configuration","title":"Inference Configuration","text":""},{"location":"guide/inference/#performance-tuning","title":"Performance Tuning","text":"<pre><code># Configure inference algorithms for performance\nconfig = {\n    \"belief_propagation\": {\n        \"max_iterations\": 100,\n        \"convergence_threshold\": 1e-8,\n        \"parallel_messages\": True\n    },\n    \"variational\": {\n        \"optimizer\": \"Adam\",\n        \"learning_rate\": 0.01,\n        \"batch_size\": 32\n    },\n    \"sampling\": {\n        \"n_samples\": 10000,\n        \"parallel_chains\": 4,\n        \"adaptive_step_size\": True\n    }\n}\n\n# Apply configuration\nnetwork.set_inference_config(config)\n\n# Run with optimized settings\noptimized_result = network.infer(\n    query_nodes=[\"activity\"],\n    evidence={\"weather\": \"rainy\"},\n    method=\"belief_propagation\"\n)\n</code></pre>"},{"location":"guide/inference/#memory-management","title":"Memory Management","text":"<pre><code># Monitor and control memory usage during inference\nmemory_config = {\n    \"max_memory_mb\": 4096,  # 4 GB limit\n    \"state_compression\": True,\n    \"lazy_evaluation\": True,\n    \"garbage_collection\": \"aggressive\"\n}\n\nnetwork.set_memory_config(memory_config)\n\n# Memory-efficient inference\nefficient_result = network.infer(\n    query_nodes=[\"weather\", \"mood\", \"activity\"],\n    method=\"variational\",\n    memory_efficient=True\n)\n\nprint(f\"Peak memory usage: {efficient_result.peak_memory_mb} MB\")\n</code></pre>"},{"location":"guide/inference/#inference-diagnostics","title":"Inference Diagnostics","text":""},{"location":"guide/inference/#convergence-analysis","title":"Convergence Analysis","text":"<pre><code># Detailed convergence diagnostics\ndiagnostic_result = network.infer(\n    query_nodes=[\"mood\"],\n    method=\"belief_propagation\",\n    return_diagnostics=True\n)\n\ndiagnostics = diagnostic_result.diagnostics\nprint(f\"Convergence rate: {diagnostics['convergence_rate']}\")\nprint(f\"Message fidelities: {diagnostics['message_fidelities']}\")\nprint(f\"Quantum coherence: {diagnostics['quantum_coherence']}\")\n\n# Plot convergence\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(12, 4))\n\nplt.subplot(1, 3, 1)\nplt.plot(diagnostics['cost_history'])\nplt.title('Cost Function')\nplt.xlabel('Iteration')\n\nplt.subplot(1, 3, 2)\nplt.plot(diagnostics['fidelity_history'])\nplt.title('State Fidelity')\nplt.xlabel('Iteration')\n\nplt.subplot(1, 3, 3)\nplt.plot(diagnostics['coherence_history'])\nplt.title('Quantum Coherence')\nplt.xlabel('Iteration')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"guide/inference/#uncertainty-quantification","title":"Uncertainty Quantification","text":"<pre><code># Quantify uncertainty in inference results\nuncertainty_result = network.infer(\n    query_nodes=[\"activity\"],\n    evidence={\"weather\": \"sunny\"},\n    method=\"sampling\",\n    uncertainty_quantification=True,\n    confidence_level=0.95\n)\n\nactivity_dist = uncertainty_result.marginal_probabilities[\"activity\"]\nactivity_ci = uncertainty_result.confidence_intervals[\"activity\"]\n\nprint(\"Activity distribution with uncertainty:\")\nfor outcome, prob in activity_dist.items():\n    ci_lower, ci_upper = activity_ci[outcome]\n    print(f\"  P(activity={outcome}) = {prob:.3f} [{ci_lower:.3f}, {ci_upper:.3f}]\")\n</code></pre>"},{"location":"guide/inference/#inference-comparison","title":"Inference Comparison","text":""},{"location":"guide/inference/#algorithm-benchmarking","title":"Algorithm Benchmarking","text":"<pre><code># Compare different inference algorithms\nalgorithms = [\"belief_propagation\", \"variational\", \"sampling\", \"exact\"]\nevidence = {\"weather\": \"sunny\"}\nquery = [\"mood\", \"activity\"]\n\nresults = {}\nfor algorithm in algorithms:\n    try:\n        start_time = time.time()\n        result = network.infer(\n            query_nodes=query,\n            evidence=evidence,\n            method=algorithm\n        )\n        end_time = time.time()\n\n        results[algorithm] = {\n            \"marginals\": result.marginal_probabilities,\n            \"time\": end_time - start_time,\n            \"memory\": result.memory_usage_mb if hasattr(result, 'memory_usage_mb') else 0\n        }\n    except Exception as e:\n        print(f\"{algorithm} failed: {e}\")\n\n# Compare results\nprint(\"Algorithm comparison:\")\nfor algorithm, data in results.items():\n    print(f\"\\n{algorithm.upper()}:\")\n    print(f\"  Time: {data['time']:.3f} seconds\")\n    print(f\"  Memory: {data['memory']:.1f} MB\")\n    print(f\"  Activity marginal: {data['marginals']['activity']}\")\n</code></pre>"},{"location":"guide/inference/#best-practices","title":"Best Practices","text":""},{"location":"guide/inference/#algorithm-selection","title":"Algorithm Selection","text":"<pre><code>def select_inference_algorithm(network, query_nodes, evidence=None):\n    \"\"\"Automatically select best inference algorithm.\"\"\"\n\n    # Small networks: use exact inference\n    if len(network.nodes) &lt;= 10:\n        return \"exact\"\n\n    # Tree-structured networks: use belief propagation\n    elif network.is_tree():\n        return \"belief_propagation\"\n\n    # Many quantum nodes: use variational methods\n    elif network.count_quantum_nodes() &gt; 5:\n        return \"variational\"\n\n    # Large classical networks: use sampling\n    elif len(network.nodes) &gt; 50:\n        return \"sampling\"\n\n    # Default: loopy belief propagation\n    else:\n        return \"loopy_belief_propagation\"\n\n# Auto-select algorithm\noptimal_algorithm = select_inference_algorithm(network)\nauto_result = network.infer(\n    query_nodes=[\"activity\"],\n    evidence={\"weather\": \"sunny\"},\n    method=optimal_algorithm\n)\n</code></pre>"},{"location":"guide/inference/#error-handling","title":"Error Handling","text":"<pre><code># Robust inference with error handling\ndef robust_inference(network, query_nodes, evidence=None, fallback_methods=None):\n    \"\"\"Perform inference with automatic fallback methods.\"\"\"\n\n    if fallback_methods is None:\n        fallback_methods = [\"belief_propagation\", \"variational\", \"sampling\"]\n\n    for method in fallback_methods:\n        try:\n            result = network.infer(\n                query_nodes=query_nodes,\n                evidence=evidence,\n                method=method,\n                timeout=60  # 1 minute timeout\n            )\n\n            # Validate result\n            if result.is_valid():\n                return result, method\n\n        except Exception as e:\n            print(f\"Method {method} failed: {e}\")\n            continue\n\n    raise RuntimeError(\"All inference methods failed\")\n\n# Use robust inference\ntry:\n    final_result, used_method = robust_inference(\n        network, \n        query_nodes=[\"mood\"],\n        evidence={\"weather\": \"rainy\"}\n    )\n    print(f\"Successfully used method: {used_method}\")\n    print(f\"Result: {final_result.marginal_probabilities}\")\n\nexcept RuntimeError as e:\n    print(f\"Inference failed: {e}\")\n</code></pre>"},{"location":"guide/inference/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Causal Reasoning and interventions</li> <li>Explore Variational Methods in detail</li> <li>See practical Examples</li> <li>Check API Reference for complete documentation</li> </ul>"},{"location":"guide/networks/","title":"Building Networks","text":"<p>This guide shows you how to construct and configure quantum Bayesian networks for various reasoning tasks.</p>"},{"location":"guide/networks/#network-creation","title":"Network Creation","text":""},{"location":"guide/networks/#basic-network-setup","title":"Basic Network Setup","text":"<p>Start by creating a quantum Bayesian network with your chosen backend:</p> <pre><code>from probabilistic_quantum_reasoner import QuantumBayesianNetwork\nfrom probabilistic_quantum_reasoner.backends import ClassicalSimulator\n\n# Initialize backend\nbackend = ClassicalSimulator(seed=42)\n\n# Create network\nnetwork = QuantumBayesianNetwork(\"MyNetwork\", backend)\n</code></pre>"},{"location":"guide/networks/#network-properties","title":"Network Properties","text":"<p>Access network properties and structure:</p> <pre><code># Network information\nprint(f\"Network name: {network.name}\")\nprint(f\"Number of nodes: {len(network.nodes)}\")\nprint(f\"Number of edges: {len(network.edges)}\")\nprint(f\"Backend type: {type(network.backend).__name__}\")\n\n# List all nodes\nfor node_id, node in network.nodes.items():\n    print(f\"Node {node_id}: {type(node).__name__}\")\n</code></pre>"},{"location":"guide/networks/#node-types","title":"Node Types","text":""},{"location":"guide/networks/#quantum-nodes","title":"Quantum Nodes","text":"<p>Quantum nodes represent variables in quantum superposition:</p> <pre><code>import numpy as np\n\n# Simple binary quantum node\nweather = network.add_quantum_node(\n    node_id=\"weather\",\n    outcome_space=[\"sunny\", \"rainy\"],\n    name=\"Weather Condition\",\n    initial_amplitudes=np.array([0.6, 0.8], dtype=complex)  # Not normalized\n)\n\n# Multi-state quantum node\nenergy = network.add_quantum_node(\n    node_id=\"energy_level\", \n    outcome_space=[\"low\", \"medium\", \"high\"],\n    name=\"Energy Level\",\n    initial_amplitudes=np.array([1, 1, 1], dtype=complex) / np.sqrt(3)\n)\n\n# Access quantum properties\nprint(f\"Weather amplitudes: {weather.quantum_state.amplitudes}\")\nprint(f\"Weather probabilities: {weather.probability_distribution}\")\nprint(f\"Energy state dimension: {energy.quantum_state.dimension}\")\n</code></pre> <p>Key Features:</p> <ul> <li>Complex amplitude vectors</li> <li>Quantum superposition states</li> <li>Unitary evolution capability</li> <li>Born rule measurement</li> </ul>"},{"location":"guide/networks/#stochastic-nodes","title":"Stochastic Nodes","text":"<p>Classical probabilistic nodes with standard probability distributions:</p> <pre><code># Binary stochastic node\nmood = network.add_stochastic_node(\n    node_id=\"mood\",\n    outcome_space=[\"happy\", \"sad\"],\n    name=\"Mood State\"\n)\n\n# Set prior distribution\nmood.prior_distribution = np.array([0.7, 0.3])  # 70% happy, 30% sad\n\n# Multi-valued stochastic node\nactivity = network.add_stochastic_node(\n    node_id=\"activity\",\n    outcome_space=[\"work\", \"leisure\", \"sleep\"],\n    name=\"Daily Activity\"\n)\n\n# Uniform prior\nactivity.prior_distribution = np.ones(3) / 3\n</code></pre>"},{"location":"guide/networks/#hybrid-nodes","title":"Hybrid Nodes","text":"<p>Combine quantum and classical reasoning:</p> <pre><code># Hybrid node mixing quantum and classical behavior\ndecision = network.add_hybrid_node(\n    node_id=\"decision\",\n    outcome_space=[\"option_a\", \"option_b\", \"option_c\"],\n    name=\"Decision Making\",\n    mixing_parameter=0.8  # 80% quantum, 20% classical\n)\n\n# Access hybrid components\nquantum_part = decision.quantum_component\nclassical_part = decision.classical_component\nmixing_ratio = decision.mixing_parameter\n\nprint(f\"Mixing parameter: {mixing_ratio}\")\nprint(f\"Hybrid distribution: {decision.get_hybrid_distribution()}\")\n</code></pre>"},{"location":"guide/networks/#network-structure","title":"Network Structure","text":""},{"location":"guide/networks/#adding-edges","title":"Adding Edges","text":"<p>Create causal relationships between nodes:</p> <pre><code># Simple parent-child relationship\nnetwork.add_edge(weather, mood)  # Weather influences mood\n\n# Multiple parents\nnetwork.add_edge(weather, activity)\nnetwork.add_edge(mood, activity)  # Both weather and mood influence activity\n\n# Check network structure\nprint(f\"Weather children: {network.get_children('weather')}\")\nprint(f\"Activity parents: {network.get_parents('activity')}\")\n</code></pre>"},{"location":"guide/networks/#conditional-dependencies","title":"Conditional Dependencies","text":"<p>Set up conditional probability tables for classical dependencies:</p> <pre><code>from probabilistic_quantum_reasoner.core.nodes import ConditionalProbabilityTable\n\n# Create CPT for mood given weather\nmood_cpt = ConditionalProbabilityTable(\n    child_outcomes=[\"happy\", \"sad\"],\n    parent_outcomes=[[\"sunny\", \"rainy\"]]  # One parent: weather\n)\n\n# Set conditional probabilities\n# P(mood=happy | weather=sunny) = 0.9\nmood_cpt.set_probability(\"happy\", (\"sunny\",), 0.9)\nmood_cpt.set_probability(\"sad\", (\"sunny\",), 0.1)\n\n# P(mood=happy | weather=rainy) = 0.3  \nmood_cpt.set_probability(\"happy\", (\"rainy\",), 0.3)\nmood_cpt.set_probability(\"sad\", (\"rainy\",), 0.7)\n\n# Assign CPT to node\nmood.conditional_probability_table = mood_cpt\n</code></pre>"},{"location":"guide/networks/#multi-parent-dependencies","title":"Multi-Parent Dependencies","text":"<p>Handle nodes with multiple parents:</p> <pre><code># Activity depends on both weather and mood\nactivity_cpt = ConditionalProbabilityTable(\n    child_outcomes=[\"work\", \"leisure\", \"sleep\"],\n    parent_outcomes=[[\"sunny\", \"rainy\"], [\"happy\", \"sad\"]]  # Two parents\n)\n\n# Set all conditional probabilities\nactivity_cpt.set_probability(\"work\", (\"sunny\", \"happy\"), 0.6)\nactivity_cpt.set_probability(\"leisure\", (\"sunny\", \"happy\"), 0.3)\nactivity_cpt.set_probability(\"sleep\", (\"sunny\", \"happy\"), 0.1)\n\nactivity_cpt.set_probability(\"work\", (\"sunny\", \"sad\"), 0.2)\nactivity_cpt.set_probability(\"leisure\", (\"sunny\", \"sad\"), 0.3)\nactivity_cpt.set_probability(\"sleep\", (\"sunny\", \"sad\"), 0.5)\n\n# Continue for all parent combinations...\nactivity_cpt.set_probability(\"work\", (\"rainy\", \"happy\"), 0.3)\nactivity_cpt.set_probability(\"leisure\", (\"rainy\", \"happy\"), 0.6)\nactivity_cpt.set_probability(\"sleep\", (\"rainy\", \"happy\"), 0.1)\n\nactivity_cpt.set_probability(\"work\", (\"rainy\", \"sad\"), 0.1)\nactivity_cpt.set_probability(\"leisure\", (\"rainy\", \"sad\"), 0.2)\nactivity_cpt.set_probability(\"sleep\", (\"rainy\", \"sad\"), 0.7)\n\nactivity.conditional_probability_table = activity_cpt\n</code></pre>"},{"location":"guide/networks/#quantum-specific-features","title":"Quantum-Specific Features","text":""},{"location":"guide/networks/#quantum-entanglement","title":"Quantum Entanglement","text":"<p>Create entangled quantum nodes:</p> <pre><code># Add two quantum nodes\nalice_measurement = network.add_quantum_node(\n    \"alice\",\n    outcome_space=[0, 1],\n    initial_amplitudes=np.array([1, 0], dtype=complex)\n)\n\nbob_measurement = network.add_quantum_node(\n    \"bob\", \n    outcome_space=[0, 1],\n    initial_amplitudes=np.array([1, 0], dtype=complex)\n)\n\n# Entangle them (creates Bell state)\nnetwork.entangle([alice_measurement, bob_measurement])\n\n# Check entanglement\nentangled_pairs = network.get_entangled_groups()\nprint(f\"Entangled groups: {entangled_pairs}\")\n</code></pre>"},{"location":"guide/networks/#quantum-operations","title":"Quantum Operations","text":"<p>Apply quantum operations to nodes:</p> <pre><code>from probabilistic_quantum_reasoner.core.operators import QuantumGate\n\n# Apply Hadamard gate to create superposition\nhadamard = QuantumGate.hadamard()\nnetwork.apply_quantum_operator(\"weather\", hadamard)\n\n# Apply rotation gates\nrotation_y = QuantumGate.rotation_y(np.pi/4)\nnetwork.apply_quantum_operator(\"energy_level\", rotation_y)\n\n# Check quantum state after operations\nprint(f\"Weather after Hadamard: {weather.quantum_state.amplitudes}\")\n</code></pre>"},{"location":"guide/networks/#quantum-measurements","title":"Quantum Measurements","text":"<p>Perform quantum measurements:</p> <pre><code># Measure a quantum node\nmeasurement_result = network.measure_node(\"weather\")\n\nprint(f\"Measurement outcome: {measurement_result['outcome']}\")\nprint(f\"Measurement probability: {measurement_result['probability']}\")\nprint(f\"Post-measurement state: {measurement_result['post_measurement_state']}\")\n\n# The quantum state collapses after measurement\nprint(f\"Weather state after measurement: {weather.quantum_state.amplitudes}\")\n</code></pre>"},{"location":"guide/networks/#network-validation","title":"Network Validation","text":""},{"location":"guide/networks/#structure-validation","title":"Structure Validation","text":"<p>Check network consistency:</p> <pre><code># Validate network structure\nvalidation_result = network.validate()\n\nif validation_result[\"valid\"]:\n    print(\"Network structure is valid\")\nelse:\n    print(f\"Validation errors: {validation_result['errors']}\")\n\n# Check for cycles\nhas_cycles = network.has_cycles()\nprint(f\"Network has cycles: {has_cycles}\")\n\n# Check connectivity\nconnected_components = network.get_connected_components()\nprint(f\"Connected components: {len(connected_components)}\")\n</code></pre>"},{"location":"guide/networks/#probabilistic-consistency","title":"Probabilistic Consistency","text":"<p>Verify probability distributions:</p> <pre><code># Check if all CPTs are properly normalized\nfor node_id, node in network.nodes.items():\n    if hasattr(node, 'conditional_probability_table'):\n        cpt = node.conditional_probability_table\n        if not cpt.is_normalized():\n            print(f\"Warning: CPT for {node_id} is not normalized\")\n            cpt.normalize()\n\n# Check quantum state normalization\nfor node_id, node in network.nodes.items():\n    if hasattr(node, 'quantum_state'):\n        state = node.quantum_state\n        norm = np.sum(np.abs(state.amplitudes) ** 2)\n        if abs(norm - 1.0) &gt; 1e-10:\n            print(f\"Warning: Quantum state for {node_id} is not normalized\")\n            state.normalize()\n</code></pre>"},{"location":"guide/networks/#network-serialization","title":"Network Serialization","text":""},{"location":"guide/networks/#save-and-load-networks","title":"Save and Load Networks","text":"<pre><code># Save network to file\nnetwork.save(\"my_network.json\")\n\n# Load network from file\nloaded_network = QuantumBayesianNetwork.load(\"my_network.json\", backend)\n\n# Export to different formats\nnetwork.export_to_graphml(\"network.graphml\")  # For visualization\nnetwork.export_to_dot(\"network.dot\")         # For Graphviz\n</code></pre>"},{"location":"guide/networks/#network-copying","title":"Network Copying","text":"<pre><code># Create a copy of the network\nnetwork_copy = network.copy()\n\n# Deep copy with independent quantum states\nnetwork_deep_copy = network.copy(deep=True)\n\n# Copy with different backend\nnew_backend = QiskitBackend(\"aer_simulator\")\nnetwork_with_new_backend = network.copy(backend=new_backend)\n</code></pre>"},{"location":"guide/networks/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"guide/networks/#temporal-networks","title":"Temporal Networks","text":"<p>Model temporal dependencies:</p> <pre><code># Time-series network\nfor t in range(5):  # 5 time steps\n    weather_t = network.add_quantum_node(\n        f\"weather_t{t}\",\n        outcome_space=[\"sunny\", \"rainy\"],\n        initial_amplitudes=np.array([1, 1], dtype=complex) / np.sqrt(2)\n    )\n\n    if t &gt; 0:\n        # Add temporal dependency\n        prev_weather = network.nodes[f\"weather_t{t-1}\"]\n        network.add_edge(prev_weather, weather_t)\n</code></pre>"},{"location":"guide/networks/#hierarchical-networks","title":"Hierarchical Networks","text":"<p>Create hierarchical structures:</p> <pre><code># High-level concepts\nclimate = network.add_quantum_node(\"climate\", [\"tropical\", \"temperate\", \"arctic\"])\n\n# Mid-level features\nseason = network.add_stochastic_node(\"season\", [\"spring\", \"summer\", \"fall\", \"winter\"])\ngeography = network.add_stochastic_node(\"geography\", [\"coastal\", \"inland\", \"mountain\"])\n\n# Low-level observations\ntemperature = network.add_hybrid_node(\"temperature\", [\"cold\", \"mild\", \"warm\", \"hot\"])\nhumidity = network.add_hybrid_node(\"humidity\", [\"low\", \"medium\", \"high\"])\n\n# Build hierarchy\nnetwork.add_edge(climate, season)\nnetwork.add_edge(climate, geography)\nnetwork.add_edge(season, temperature)\nnetwork.add_edge(geography, temperature)\nnetwork.add_edge(geography, humidity)\n</code></pre>"},{"location":"guide/networks/#modular-networks","title":"Modular Networks","text":"<p>Combine multiple sub-networks:</p> <pre><code># Create sub-networks\nweather_module = create_weather_network(backend)\nmood_module = create_mood_network(backend)\nactivity_module = create_activity_network(backend)\n\n# Combine into larger network\ncombined_network = QuantumBayesianNetwork.combine([\n    weather_module, mood_module, activity_module\n], name=\"CombinedNetwork\")\n\n# Add cross-module connections\ncombined_network.add_edge(\"weather_module.weather\", \"mood_module.mood\")\ncombined_network.add_edge(\"mood_module.mood\", \"activity_module.activity\")\n</code></pre>"},{"location":"guide/networks/#best-practices","title":"Best Practices","text":""},{"location":"guide/networks/#design-guidelines","title":"Design Guidelines","text":"<ol> <li>Start Simple: Begin with small networks and add complexity gradually</li> <li>Validate Early: Check network structure before adding complex dependencies  </li> <li>Use Appropriate Node Types: Choose quantum vs classical nodes based on uncertainty characteristics</li> <li>Monitor Memory: Quantum state spaces grow exponentially</li> <li>Test Incrementally: Validate each component before combining</li> </ol>"},{"location":"guide/networks/#performance-tips","title":"Performance Tips","text":"<pre><code># Efficient network construction\nclass NetworkBuilder:\n    def __init__(self, backend):\n        self.backend = backend\n        self.network = QuantumBayesianNetwork(\"EfficientNetwork\", backend)\n\n    def add_batch_nodes(self, node_specs):\n        \"\"\"Add multiple nodes efficiently.\"\"\"\n        for spec in node_specs:\n            if spec[\"type\"] == \"quantum\":\n                self.network.add_quantum_node(**spec[\"params\"])\n            elif spec[\"type\"] == \"stochastic\":\n                self.network.add_stochastic_node(**spec[\"params\"])\n            elif spec[\"type\"] == \"hybrid\":\n                self.network.add_hybrid_node(**spec[\"params\"])\n\n    def build(self):\n        \"\"\"Finalize and return network.\"\"\"\n        self.network.validate()\n        return self.network\n</code></pre>"},{"location":"guide/networks/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Unormalized States: Always ensure quantum amplitudes are normalized</li> <li>Inconsistent CPTs: Verify conditional probability tables sum to 1</li> <li>Circular Dependencies: Check for cycles before inference</li> <li>Memory Overflow: Monitor exponential growth in quantum state spaces</li> <li>Backend Mismatch: Ensure operations are supported by chosen backend</li> </ol>"},{"location":"guide/networks/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Quantum Nodes in detail</li> <li>Explore Inference Methods</li> <li>See Causal Reasoning examples</li> <li>Check API Reference for complete documentation</li> </ul>"},{"location":"guide/quantum-nodes/","title":"Quantum Nodes","text":"<p>This guide provides detailed information about quantum nodes, their properties, and how to work with quantum superposition in probabilistic reasoning.</p>"},{"location":"guide/quantum-nodes/#understanding-quantum-nodes","title":"Understanding Quantum Nodes","text":"<p>Quantum nodes represent variables that exist in quantum superposition, allowing them to be in multiple states simultaneously with complex probability amplitudes.</p>"},{"location":"guide/quantum-nodes/#quantum-superposition","title":"Quantum Superposition","text":"<p>Unlike classical variables that have definite values, quantum nodes can exist in superposition:</p> <pre><code>import numpy as np\nfrom probabilistic_quantum_reasoner import QuantumBayesianNetwork\nfrom probabilistic_quantum_reasoner.backends import ClassicalSimulator\n\nbackend = ClassicalSimulator()\nnetwork = QuantumBayesianNetwork(\"QuantumDemo\", backend)\n\n# Classical node - definite state\nclassical_coin = network.add_stochastic_node(\n    \"classical_coin\",\n    outcome_space=[\"heads\", \"tails\"]\n)\nclassical_coin.prior_distribution = np.array([0.5, 0.5])\n\n# Quantum node - superposition state  \nquantum_coin = network.add_quantum_node(\n    \"quantum_coin\",\n    outcome_space=[\"heads\", \"tails\"],\n    initial_amplitudes=np.array([1/np.sqrt(2), 1/np.sqrt(2)], dtype=complex)\n)\n\nprint(f\"Classical probabilities: {classical_coin.prior_distribution}\")\nprint(f\"Quantum amplitudes: {quantum_coin.quantum_state.amplitudes}\")\nprint(f\"Quantum probabilities: {quantum_coin.probability_distribution}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#complex-amplitudes","title":"Complex Amplitudes","text":"<p>Quantum amplitudes are complex numbers that encode both magnitude and phase:</p> <pre><code># Amplitude with phase\nphase = np.pi / 4\nquantum_node = network.add_quantum_node(\n    \"phase_node\",\n    outcome_space=[\"state_0\", \"state_1\"],\n    initial_amplitudes=np.array([\n        1/np.sqrt(2),  # Real amplitude\n        np.exp(1j * phase) / np.sqrt(2)  # Complex amplitude with phase\n    ])\n)\n\namplitudes = quantum_node.quantum_state.amplitudes\nprint(f\"Amplitude magnitudes: {np.abs(amplitudes)}\")\nprint(f\"Amplitude phases: {np.angle(amplitudes)}\")\nprint(f\"Born rule probabilities: {np.abs(amplitudes)**2}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#quantum-state-operations","title":"Quantum State Operations","text":""},{"location":"guide/quantum-nodes/#applying-quantum-gates","title":"Applying Quantum Gates","text":"<p>Transform quantum states using unitary operators:</p> <pre><code>from probabilistic_quantum_reasoner.core.operators import QuantumGate\n\n# Create quantum node in |0\u27e9 state\nqubit = network.add_quantum_node(\n    \"qubit\",\n    outcome_space=[0, 1],\n    initial_amplitudes=np.array([1, 0], dtype=complex)\n)\n\nprint(f\"Initial state: {qubit.quantum_state.amplitudes}\")\n\n# Apply Hadamard gate to create superposition\nhadamard = QuantumGate.hadamard()\nnetwork.apply_quantum_operator(\"qubit\", hadamard)\nprint(f\"After Hadamard: {qubit.quantum_state.amplitudes}\")\n\n# Apply Pauli-X gate (bit flip)\npauli_x = QuantumGate.pauli_x()\nnetwork.apply_quantum_operator(\"qubit\", pauli_x)\nprint(f\"After Pauli-X: {qubit.quantum_state.amplitudes}\")\n\n# Apply rotation gate\nrotation_y = QuantumGate.rotation_y(np.pi/3)\nnetwork.apply_quantum_operator(\"qubit\", rotation_y)\nprint(f\"After Y rotation: {qubit.quantum_state.amplitudes}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#custom-quantum-operations","title":"Custom Quantum Operations","text":"<p>Create and apply custom unitary operations:</p> <pre><code>from probabilistic_quantum_reasoner.core.operators import UnitaryOperator\n\n# Custom 2x2 unitary matrix\ncustom_matrix = np.array([\n    [0.6, 0.8],\n    [0.8, -0.6]\n], dtype=complex)\n\n# Verify it's unitary\nassert np.allclose(custom_matrix @ custom_matrix.conj().T, np.eye(2))\n\n# Create and apply custom operator\ncustom_operator = UnitaryOperator(custom_matrix)\nnetwork.apply_quantum_operator(\"qubit\", custom_operator)\nprint(f\"After custom operation: {qubit.quantum_state.amplitudes}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#multi-state-quantum-nodes","title":"Multi-State Quantum Nodes","text":""},{"location":"guide/quantum-nodes/#qutrit-example-3-level-system","title":"Qutrit Example (3-Level System)","text":"<pre><code># Three-level quantum system\nqutrit = network.add_quantum_node(\n    \"qutrit\",\n    outcome_space=[\"low\", \"medium\", \"high\"],\n    initial_amplitudes=np.array([1, 1, 1], dtype=complex) / np.sqrt(3)\n)\n\nprint(f\"Qutrit state: {qutrit.quantum_state.amplitudes}\")\nprint(f\"Qutrit probabilities: {qutrit.probability_distribution}\")\n\n# Custom 3x3 unitary (discrete Fourier transform)\ndft_3 = np.array([\n    [1, 1, 1],\n    [1, np.exp(2j*np.pi/3), np.exp(4j*np.pi/3)],\n    [1, np.exp(4j*np.pi/3), np.exp(8j*np.pi/3)]\n], dtype=complex) / np.sqrt(3)\n\ndft_operator = UnitaryOperator(dft_3)\nnetwork.apply_quantum_operator(\"qutrit\", dft_operator)\nprint(f\"After DFT: {qutrit.quantum_state.amplitudes}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#many-level-systems","title":"Many-Level Systems","text":"<pre><code># High-dimensional quantum node\nn_levels = 8\nhigh_dim_node = network.add_quantum_node(\n    \"high_dim\",\n    outcome_space=list(range(n_levels)),\n    initial_amplitudes=np.ones(n_levels, dtype=complex) / np.sqrt(n_levels)\n)\n\n# Apply random unitary transformation\nfrom probabilistic_quantum_reasoner.core.operators import QuantumGate\nrandom_unitary = QuantumGate.random_unitary(n_levels)\nnetwork.apply_quantum_operator(\"high_dim\", random_unitary)\n\nprint(f\"High-dimensional state dimension: {high_dim_node.quantum_state.dimension}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#quantum-measurements","title":"Quantum Measurements","text":""},{"location":"guide/quantum-nodes/#computational-basis-measurement","title":"Computational Basis Measurement","text":"<pre><code>from probabilistic_quantum_reasoner.core.operators import MeasurementOperator\n\n# Create measurement operator\ncomputational_measurement = MeasurementOperator.computational_basis(2)\n\n# Measure quantum node in superposition\nsuperposition_node = network.add_quantum_node(\n    \"measurement_demo\",\n    outcome_space=[0, 1],\n    initial_amplitudes=np.array([0.6, 0.8], dtype=complex)\n)\n\n# Perform measurement\nresult = network.measure_node(\"measurement_demo\")\nprint(f\"Measurement outcome: {result['outcome']}\")\nprint(f\"Measurement probability: {result['probability']}\")\nprint(f\"Post-measurement state: {result['post_measurement_state']}\")\n\n# State has collapsed\nprint(f\"Node state after measurement: {superposition_node.quantum_state.amplitudes}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#observable-measurements","title":"Observable Measurements","text":"<pre><code># Pauli-Z measurement (energy eigenvalues)\npauli_z_measurement = MeasurementOperator.pauli_z()\n\n# Create node in superposition\nenergy_node = network.add_quantum_node(\n    \"energy\",\n    outcome_space=[\"low_energy\", \"high_energy\"],\n    initial_amplitudes=np.array([0.8, 0.6], dtype=complex)\n)\n\n# Measure energy\nenergy_result = pauli_z_measurement.measure(energy_node.quantum_state.amplitudes)\nprint(f\"Energy measurement: {energy_result}\")\n\n# Pauli-X measurement (spin in X direction)\npauli_x_measurement = MeasurementOperator.pauli_x()\nspin_result = pauli_x_measurement.measure(energy_node.quantum_state.amplitudes)\nprint(f\"Spin-X measurement: {spin_result}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#expectation-values","title":"Expectation Values","text":"<pre><code># Compute expectation values without measurement\ndef compute_expectation_value(node, observable_matrix):\n    \"\"\"Compute expectation value \u27e8\u03c8|O|\u03c8\u27e9.\"\"\"\n    amplitudes = node.quantum_state.amplitudes\n    return np.real(np.conj(amplitudes) @ observable_matrix @ amplitudes)\n\n# Pauli-Z expectation value\npauli_z = np.array([[1, 0], [0, -1]], dtype=complex)\nz_expectation = compute_expectation_value(energy_node, pauli_z)\nprint(f\"\u27e8Z\u27e9 = {z_expectation}\")\n\n# Pauli-X expectation value  \npauli_x = np.array([[0, 1], [1, 0]], dtype=complex)\nx_expectation = compute_expectation_value(energy_node, pauli_x)\nprint(f\"\u27e8X\u27e9 = {x_expectation}\")\n\n# Pauli-Y expectation value\npauli_y = np.array([[0, -1j], [1j, 0]], dtype=complex)\ny_expectation = compute_expectation_value(energy_node, pauli_y)\nprint(f\"\u27e8Y\u27e9 = {y_expectation}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#quantum-entanglement","title":"Quantum Entanglement","text":""},{"location":"guide/quantum-nodes/#creating-entangled-states","title":"Creating Entangled States","text":"<pre><code># Two quantum nodes to be entangled\nalice = network.add_quantum_node(\n    \"alice\",\n    outcome_space=[0, 1],\n    initial_amplitudes=np.array([1, 0], dtype=complex)\n)\n\nbob = network.add_quantum_node(\n    \"bob\",\n    outcome_space=[0, 1], \n    initial_amplitudes=np.array([1, 0], dtype=complex)\n)\n\n# Create entanglement (Bell state)\nnetwork.entangle([alice, bob])\n\n# Check joint quantum state\njoint_state = network.get_joint_quantum_state([alice, bob])\nprint(f\"Joint entangled state: {joint_state.amplitudes}\")\n\n# This should be |00\u27e9 + |11\u27e9 (Bell state)\nexpected_bell = np.array([1/np.sqrt(2), 0, 0, 1/np.sqrt(2)], dtype=complex)\nprint(f\"Expected Bell state: {expected_bell}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#measuring-entangled-systems","title":"Measuring Entangled Systems","text":"<pre><code># Measure Alice's qubit\nalice_result = network.measure_node(\"alice\")\nprint(f\"Alice measured: {alice_result['outcome']}\")\n\n# Bob's state is now correlated\nbob_state_after = bob.quantum_state.amplitudes\nprint(f\"Bob's state after Alice's measurement: {bob_state_after}\")\n\n# Bob's measurement will be perfectly correlated\nbob_result = network.measure_node(\"bob\")\nprint(f\"Bob measured: {bob_result['outcome']}\")\nprint(f\"Correlation: {alice_result['outcome'] == bob_result['outcome']}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#multi-particle-entanglement","title":"Multi-Particle Entanglement","text":"<pre><code># Create GHZ state (three-particle entanglement)\nparticle1 = network.add_quantum_node(\"particle1\", [0, 1])\nparticle2 = network.add_quantum_node(\"particle2\", [0, 1])  \nparticle3 = network.add_quantum_node(\"particle3\", [0, 1])\n\n# Entangle all three particles\nnetwork.entangle([particle1, particle2, particle3])\n\n# Apply operations to create GHZ state |000\u27e9 + |111\u27e9\nhadamard = QuantumGate.hadamard()\ncnot = QuantumGate.controlled_not()\n\n# H on first particle, then CNOT chain\nnetwork.apply_quantum_operator(\"particle1\", hadamard)\nnetwork.apply_two_qubit_gate(\"particle1\", \"particle2\", cnot)\nnetwork.apply_two_qubit_gate(\"particle2\", \"particle3\", cnot)\n\nghz_state = network.get_joint_quantum_state([particle1, particle2, particle3])\nprint(f\"GHZ state: {ghz_state.amplitudes}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#quantum-decoherence","title":"Quantum Decoherence","text":""},{"location":"guide/quantum-nodes/#modeling-decoherence","title":"Modeling Decoherence","text":"<pre><code># Simulate decoherence effects\ndef apply_decoherence(node, decoherence_rate, time_step):\n    \"\"\"Apply simple decoherence model.\"\"\"\n    amplitudes = node.quantum_state.amplitudes\n\n    # Exponential decay of off-diagonal elements (T2 process)\n    decay_factor = np.exp(-time_step / decoherence_rate)\n\n    # Keep population (diagonal) terms, decay coherence (off-diagonal)\n    probabilities = np.abs(amplitudes) ** 2\n    new_amplitudes = np.sqrt(probabilities)\n\n    # Add small amount of phase noise\n    phase_noise = np.random.normal(0, 0.1, len(amplitudes))\n    new_amplitudes = new_amplitudes * np.exp(1j * phase_noise * decay_factor)\n\n    node.quantum_state.amplitudes = new_amplitudes\n    node.quantum_state.normalize()\n\n# Example: decoherence in quantum node\ndecoherent_node = network.add_quantum_node(\n    \"decoherent\",\n    outcome_space=[0, 1],\n    initial_amplitudes=np.array([1/np.sqrt(2), 1/np.sqrt(2)], dtype=complex)\n)\n\nprint(f\"Before decoherence: {decoherent_node.quantum_state.amplitudes}\")\n\n# Apply decoherence over time\nfor t in range(5):\n    apply_decoherence(decoherent_node, decoherence_rate=10.0, time_step=1.0)\n    print(f\"After {t+1} time steps: {decoherent_node.quantum_state.amplitudes}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#quantum-state-analysis","title":"Quantum State Analysis","text":""},{"location":"guide/quantum-nodes/#state-properties","title":"State Properties","text":"<pre><code>def analyze_quantum_state(node):\n    \"\"\"Analyze properties of a quantum state.\"\"\"\n    amplitudes = node.quantum_state.amplitudes\n    probabilities = np.abs(amplitudes) ** 2\n\n    # Purity (how mixed vs pure the state is)\n    purity = np.sum(probabilities ** 2)\n\n    # Entropy (measure of uncertainty)\n    entropy = -np.sum(probabilities * np.log2(probabilities + 1e-10))\n\n    # Maximum coherence (off-diagonal terms)\n    coherence = np.sum(np.abs(amplitudes[np.triu_indices(len(amplitudes), k=1)]))\n\n    return {\n        \"purity\": purity,\n        \"entropy\": entropy,\n        \"coherence\": coherence,\n        \"dimension\": len(amplitudes)\n    }\n\n# Analyze different quantum states\npure_state = network.add_quantum_node(\"pure\", [0, 1], np.array([1, 0], dtype=complex))\nmixed_state = network.add_quantum_node(\"mixed\", [0, 1], np.array([0.7, 0.7], dtype=complex))\nsuperposition = network.add_quantum_node(\"super\", [0, 1], np.array([1/np.sqrt(2), 1/np.sqrt(2)], dtype=complex))\n\nfor node_name, node in [(\"pure\", pure_state), (\"mixed\", mixed_state), (\"superposition\", superposition)]:\n    analysis = analyze_quantum_state(node)\n    print(f\"{node_name} state analysis: {analysis}\")\n</code></pre>"},{"location":"guide/quantum-nodes/#quantum-fidelity","title":"Quantum Fidelity","text":"<pre><code>def quantum_fidelity(state1, state2):\n    \"\"\"Compute fidelity between two quantum states.\"\"\"\n    amplitudes1 = state1.quantum_state.amplitudes\n    amplitudes2 = state2.quantum_state.amplitudes\n    return abs(np.vdot(amplitudes1, amplitudes2)) ** 2\n\n# Compare quantum states\nstate_a = network.add_quantum_node(\"state_a\", [0, 1], np.array([1, 0], dtype=complex))\nstate_b = network.add_quantum_node(\"state_b\", [0, 1], np.array([0, 1], dtype=complex))\nstate_c = network.add_quantum_node(\"state_c\", [0, 1], np.array([1/np.sqrt(2), 1/np.sqrt(2)], dtype=complex))\n\nprint(f\"Fidelity(A, B): {quantum_fidelity(state_a, state_b)}\")  # Orthogonal states\nprint(f\"Fidelity(A, C): {quantum_fidelity(state_a, state_c)}\")  # Partial overlap\nprint(f\"Fidelity(A, A): {quantum_fidelity(state_a, state_a)}\")  # Identical states\n</code></pre>"},{"location":"guide/quantum-nodes/#best-practices","title":"Best Practices","text":""},{"location":"guide/quantum-nodes/#state-preparation","title":"State Preparation","text":"<pre><code># Good: Normalized amplitudes\ngood_amplitudes = np.array([0.6, 0.8], dtype=complex)\ngood_amplitudes /= np.linalg.norm(good_amplitudes)\n\n# Bad: Unnormalized amplitudes (will be auto-normalized but prints warning)\nbad_amplitudes = np.array([1, 1], dtype=complex)  # Should be [1/\u221a2, 1/\u221a2]\n\n# Always verify normalization\nassert abs(np.sum(np.abs(good_amplitudes)**2) - 1.0) &lt; 1e-10\n</code></pre>"},{"location":"guide/quantum-nodes/#memory-management","title":"Memory Management","text":"<pre><code># Monitor quantum state sizes\ndef check_memory_usage(network):\n    \"\"\"Check memory usage of quantum states.\"\"\"\n    total_amplitudes = 0\n\n    for node_id, node in network.nodes.items():\n        if hasattr(node, 'quantum_state'):\n            n_amplitudes = len(node.quantum_state.amplitudes)\n            total_amplitudes += n_amplitudes\n            print(f\"Node {node_id}: {n_amplitudes} amplitudes\")\n\n    memory_mb = total_amplitudes * 16 / 1024 / 1024  # 16 bytes per complex number\n    print(f\"Total quantum memory: {memory_mb:.2f} MB\")\n\n    return memory_mb\n\n# Check before creating large quantum systems\nmemory_usage = check_memory_usage(network)\nif memory_usage &gt; 1000:  # 1 GB limit\n    print(\"Warning: Large memory usage detected\")\n</code></pre>"},{"location":"guide/quantum-nodes/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Efficient quantum operations\nclass QuantumNodeManager:\n    def __init__(self, network):\n        self.network = network\n        self._cached_states = {}\n\n    def batch_apply_operations(self, operations):\n        \"\"\"Apply multiple quantum operations efficiently.\"\"\"\n        for node_id, operator in operations:\n            self.network.apply_quantum_operator(node_id, operator)\n\n    def cache_quantum_state(self, node_id):\n        \"\"\"Cache quantum state for fast access.\"\"\"\n        node = self.network.nodes[node_id]\n        self._cached_states[node_id] = node.quantum_state.amplitudes.copy()\n\n    def restore_quantum_state(self, node_id):\n        \"\"\"Restore cached quantum state.\"\"\"\n        if node_id in self._cached_states:\n            node = self.network.nodes[node_id]\n            node.quantum_state.amplitudes = self._cached_states[node_id].copy()\n</code></pre>"},{"location":"guide/quantum-nodes/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Unnormalized States: Always ensure amplitudes are normalized</li> <li>Phase Ignoring: Remember that quantum phases matter for interference</li> <li>Measurement Timing: Quantum states collapse after measurement</li> <li>Memory Scaling: State space grows exponentially with system size</li> <li>Classical Thinking: Quantum superposition is not just probability</li> </ol>"},{"location":"guide/quantum-nodes/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Inference Methods</li> <li>Explore Causal Reasoning with quantum variables</li> <li>See Variational Methods for optimization</li> <li>Check Examples for practical applications</li> </ul>"},{"location":"guide/variational/","title":"Variational Methods","text":"<p>This guide covers variational quantum algorithms for optimization and inference in quantum Bayesian networks, including VQE, QAOA, and hybrid classical-quantum optimization.</p>"},{"location":"guide/variational/#introduction-to-variational-quantum-algorithms","title":"Introduction to Variational Quantum Algorithms","text":"<p>Variational methods combine parametrized quantum circuits with classical optimization to solve complex inference and optimization problems that are intractable for classical methods alone.</p>"},{"location":"guide/variational/#variational-quantum-eigensolver-vqe","title":"Variational Quantum Eigensolver (VQE)","text":""},{"location":"guide/variational/#basic-vqe-implementation","title":"Basic VQE Implementation","text":"<pre><code>from probabilistic_quantum_reasoner import QuantumBayesianNetwork\nfrom probabilistic_quantum_reasoner.backends import PennyLaneBackend\nfrom probabilistic_quantum_reasoner.inference.variational import VQE\nimport numpy as np\n\n# Create network with PennyLane backend for VQE\nbackend = PennyLaneBackend(\"default.qubit\", shots=None)  # Analytic gradients\nnetwork = QuantumBayesianNetwork(\"VQEExample\", backend)\n\n# Add quantum nodes\nenergy_state = network.add_quantum_node(\n    \"energy\",\n    outcome_space=[\"ground\", \"excited\"],\n    initial_amplitudes=np.array([1, 0], dtype=complex)\n)\n\nspin_state = network.add_quantum_node(\n    \"spin\", \n    outcome_space=[\"up\", \"down\"],\n    initial_amplitudes=np.array([1/np.sqrt(2), 1/np.sqrt(2)], dtype=complex)\n)\n\n# Entangle the qubits\nnetwork.entangle([energy_state, spin_state])\n\n# Define Hamiltonian for the system\ndef create_hamiltonian():\n    \"\"\"Create Hamiltonian operator for two-qubit system.\"\"\"\n    # H = -J * Z\u2297Z - h * (X\u2297I + I\u2297X)\n    J = 1.0  # Coupling strength\n    h = 0.5  # External field\n\n    # Pauli matrices\n    I = np.eye(2)\n    X = np.array([[0, 1], [1, 0]])\n    Z = np.array([[1, 0], [0, -1]])\n\n    # Two-qubit Hamiltonian\n    ZZ = np.kron(Z, Z)\n    XI = np.kron(X, I) \n    IX = np.kron(I, X)\n\n    H = -J * ZZ - h * (XI + IX)\n    return H\n\nhamiltonian = create_hamiltonian()\n\n# Create VQE instance\nvqe = VQE(network, hamiltonian)\n\n# Define variational ansatz\ndef ansatz(parameters, n_qubits=2):\n    \"\"\"Create variational ansatz circuit.\"\"\"\n    theta1, theta2, theta3, theta4 = parameters\n\n    circuit = [\n        # Layer 1: Single qubit rotations\n        ('RY', 0, theta1),\n        ('RY', 1, theta2),\n\n        # Entangling layer\n        ('CNOT', 0, 1),\n\n        # Layer 2: More rotations\n        ('RZ', 0, theta3),\n        ('RZ', 1, theta4)\n    ]\n\n    return circuit\n\n# Run VQE optimization\nvqe_result = vqe.optimize(\n    ansatz=ansatz,\n    n_parameters=4,\n    optimizer=\"Adam\",\n    max_iterations=200,\n    learning_rate=0.1\n)\n\nprint(f\"VQE Ground State Energy: {vqe_result['ground_state_energy']:.6f}\")\nprint(f\"Optimal Parameters: {vqe_result['optimal_parameters']}\")\nprint(f\"Convergence: {vqe_result['converged']}\")\n</code></pre>"},{"location":"guide/variational/#advanced-vqe-features","title":"Advanced VQE Features","text":"<pre><code># VQE with custom cost function\ndef custom_vqe_cost(parameters, network, target_distribution):\n    \"\"\"Custom VQE cost function to match target distribution.\"\"\"\n\n    # Apply variational circuit\n    state = network.apply_variational_circuit(ansatz(parameters))\n\n    # Compute current probability distribution\n    current_probs = np.abs(state.amplitudes) ** 2\n\n    # KL divergence from target\n    epsilon = 1e-10\n    kl_div = np.sum(target_distribution * np.log(\n        (target_distribution + epsilon) / (current_probs + epsilon)\n    ))\n\n    # Add regularization\n    regularization = 0.01 * np.sum(parameters ** 2)\n\n    return kl_div + regularization\n\n# Target distribution (e.g., thermal state)\ntarget_dist = np.array([0.6, 0.2, 0.15, 0.05])  # |00\u27e9, |01\u27e9, |10\u27e9, |11\u27e9\n\ncustom_vqe_result = vqe.optimize(\n    cost_function=lambda params: custom_vqe_cost(params, network, target_dist),\n    n_parameters=4,\n    optimizer=\"L-BFGS-B\",\n    max_iterations=100\n)\n\nprint(f\"Custom VQE result: {custom_vqe_result}\")\n</code></pre>"},{"location":"guide/variational/#quantum-approximate-optimization-algorithm-qaoa","title":"Quantum Approximate Optimization Algorithm (QAOA)","text":""},{"location":"guide/variational/#qaoa-for-inference-problems","title":"QAOA for Inference Problems","text":"<pre><code>from probabilistic_quantum_reasoner.inference.variational import QAOA\n\n# Create QAOA instance for inference optimization\nqaoa = QAOA(network, p_layers=3)\n\n# Define problem Hamiltonian based on inference objective\ndef create_inference_hamiltonian(network, evidence, query_nodes):\n    \"\"\"Create problem Hamiltonian for inference task.\"\"\"\n\n    # Convert inference problem to Ising model\n    n_vars = len(query_nodes)\n    n_qubits = n_vars\n\n    # Coupling terms based on network structure\n    J = np.zeros((n_qubits, n_qubits))\n    h = np.zeros(n_qubits)\n\n    for i, node1 in enumerate(query_nodes):\n        for j, node2 in enumerate(query_nodes):\n            if j &gt; i and network.has_edge(node1, node2):\n                # Coupling strength based on conditional probabilities\n                J[i, j] = compute_coupling_strength(network, node1, node2, evidence)\n\n        # External field based on evidence\n        h[i] = compute_external_field(network, node1, evidence)\n\n    # Construct Hamiltonian matrix\n    H = construct_ising_hamiltonian(J, h)\n    return H\n\ndef compute_coupling_strength(network, node1, node2, evidence):\n    \"\"\"Compute coupling strength between nodes.\"\"\"\n    # Simplified: use mutual information\n    joint_dist = network.infer(\n        query_nodes=[node1, node2],\n        evidence=evidence\n    )\n\n    return mutual_information(joint_dist.joint_probabilities)\n\ndef compute_external_field(network, node, evidence):\n    \"\"\"Compute external field for node given evidence.\"\"\"\n    # Bias based on evidence\n    marginal = network.infer(\n        query_nodes=[node],\n        evidence=evidence\n    )\n\n    # Convert to bias term\n    probs = list(marginal.marginal_probabilities[node].values())\n    return np.log(probs[0] / probs[1]) if len(probs) &gt;= 2 else 0.0\n\n# Run QAOA for inference\ninference_hamiltonian = create_inference_hamiltonian(\n    network, \n    evidence={\"energy\": \"ground\"}, \n    query_nodes=[\"spin\"]\n)\n\nqaoa_result = qaoa.optimize(\n    problem_hamiltonian=inference_hamiltonian,\n    max_iterations=50,\n    optimizer=\"COBYLA\"\n)\n\nprint(f\"QAOA Inference Result: {qaoa_result['optimal_state']}\")\nprint(f\"QAOA Parameters: {qaoa_result['optimal_parameters']}\")\n</code></pre>"},{"location":"guide/variational/#multi-layer-qaoa","title":"Multi-Layer QAOA","text":"<pre><code># Deep QAOA with many layers\ndeep_qaoa = QAOA(network, p_layers=10)\n\n# Adaptive parameter initialization\ndef adaptive_parameter_initialization(p_layers):\n    \"\"\"Initialize QAOA parameters adaptively.\"\"\"\n\n    # Linear interpolation strategy\n    gamma_schedule = np.linspace(0, np.pi, p_layers)\n    beta_schedule = np.linspace(0, np.pi/2, p_layers)\n\n    return np.concatenate([gamma_schedule, beta_schedule])\n\ninitial_params = adaptive_parameter_initialization(10)\n\ndeep_qaoa_result = deep_qaoa.optimize(\n    problem_hamiltonian=inference_hamiltonian,\n    initial_parameters=initial_params,\n    max_iterations=200,\n    optimizer=\"Adam\",\n    learning_rate=0.01,\n    adaptive_step_size=True\n)\n\nprint(f\"Deep QAOA convergence: {deep_qaoa_result['converged']}\")\nprint(f\"Final cost: {deep_qaoa_result['final_cost']}\")\n</code></pre>"},{"location":"guide/variational/#hybrid-classical-quantum-optimization","title":"Hybrid Classical-Quantum Optimization","text":""},{"location":"guide/variational/#quantum-classical-expectation-maximization","title":"Quantum-Classical Expectation-Maximization","text":"<pre><code>class QuantumEM:\n    \"\"\"Quantum-enhanced Expectation-Maximization algorithm.\"\"\"\n\n    def __init__(self, network, backend):\n        self.network = network\n        self.backend = backend\n\n    def fit(self, data, max_iterations=100, tolerance=1e-6):\n        \"\"\"Fit quantum Bayesian network using quantum EM.\"\"\"\n\n        log_likelihood_history = []\n\n        for iteration in range(max_iterations):\n            # E-step: Quantum expectation computation\n            expected_sufficient_stats = self.quantum_e_step(data)\n\n            # M-step: Classical parameter maximization\n            old_parameters = self.get_parameters()\n            self.m_step(expected_sufficient_stats)\n            new_parameters = self.get_parameters()\n\n            # Compute log-likelihood\n            log_likelihood = self.compute_log_likelihood(data)\n            log_likelihood_history.append(log_likelihood)\n\n            # Check convergence\n            param_change = np.linalg.norm(new_parameters - old_parameters)\n            if param_change &lt; tolerance:\n                break\n\n        return {\n            \"converged\": param_change &lt; tolerance,\n            \"iterations\": iteration + 1,\n            \"log_likelihood_history\": log_likelihood_history,\n            \"final_log_likelihood\": log_likelihood_history[-1]\n        }\n\n    def quantum_e_step(self, data):\n        \"\"\"Quantum expectation step using superposition.\"\"\"\n\n        sufficient_stats = {}\n\n        for data_point in data:\n            # Create quantum superposition over hidden variables\n            hidden_vars = self.network.get_hidden_variables()\n\n            # Quantum inference for expectations\n            for hidden_var in hidden_vars:\n                posterior = self.network.infer(\n                    query_nodes=[hidden_var],\n                    evidence=data_point,\n                    method=\"variational\"\n                )\n\n                # Accumulate sufficient statistics\n                if hidden_var not in sufficient_stats:\n                    sufficient_stats[hidden_var] = {}\n\n                for value, prob in posterior.marginal_probabilities[hidden_var].items():\n                    if value not in sufficient_stats[hidden_var]:\n                        sufficient_stats[hidden_var][value] = 0\n                    sufficient_stats[hidden_var][value] += prob\n\n        return sufficient_stats\n\n    def m_step(self, sufficient_stats):\n        \"\"\"Classical maximization step.\"\"\"\n\n        # Update parameters based on sufficient statistics\n        for node_id, node in self.network.nodes.items():\n            if hasattr(node, 'conditional_probability_table'):\n                # Update CPT parameters\n                self.update_cpt_parameters(node, sufficient_stats)\n            elif hasattr(node, 'quantum_state'):\n                # Update quantum amplitudes\n                self.update_quantum_parameters(node, sufficient_stats)\n\n# Example usage\nquantum_em = QuantumEM(network, backend)\n\n# Generate synthetic data\nsynthetic_data = network.simulate_data(n_samples=1000)\n\n# Fit model\nem_result = quantum_em.fit(synthetic_data, max_iterations=50)\nprint(f\"Quantum EM converged: {em_result['converged']}\")\nprint(f\"Final log-likelihood: {em_result['final_log_likelihood']:.3f}\")\n</code></pre>"},{"location":"guide/variational/#variational-autoencoders-with-quantum-layers","title":"Variational Autoencoders with Quantum Layers","text":"<pre><code>class QuantumVariationalAutoencoder:\n    \"\"\"Quantum variational autoencoder for probabilistic modeling.\"\"\"\n\n    def __init__(self, network, latent_dim=4):\n        self.network = network\n        self.latent_dim = latent_dim\n        self.encoder_parameters = None\n        self.decoder_parameters = None\n\n    def encode(self, data, parameters):\n        \"\"\"Quantum encoder: data \u2192 latent quantum state.\"\"\"\n\n        # Classical preprocessing\n        processed_data = self.preprocess_data(data)\n\n        # Quantum encoding circuit\n        def encoding_circuit(data_vec, params):\n            n_qubits = self.latent_dim\n            circuit = []\n\n            # Data encoding\n            for i, data_val in enumerate(data_vec[:n_qubits]):\n                circuit.append(('RY', i, data_val * np.pi))\n\n            # Parameterized encoding\n            param_idx = 0\n            for layer in range(2):  # 2 encoding layers\n                for i in range(n_qubits):\n                    circuit.append(('RZ', i, params[param_idx]))\n                    param_idx += 1\n\n                # Entangling layer\n                for i in range(n_qubits - 1):\n                    circuit.append(('CNOT', i, i + 1))\n\n            return circuit\n\n        # Apply encoding circuit\n        encoded_state = self.network.apply_quantum_circuit(\n            encoding_circuit(processed_data, parameters)\n        )\n\n        return encoded_state\n\n    def decode(self, latent_state, parameters):\n        \"\"\"Quantum decoder: latent quantum state \u2192 data reconstruction.\"\"\"\n\n        # Quantum decoding circuit\n        def decoding_circuit(params):\n            n_qubits = self.latent_dim\n            circuit = []\n\n            param_idx = 0\n            for layer in range(2):  # 2 decoding layers\n                for i in range(n_qubits):\n                    circuit.append(('RY', i, params[param_idx]))\n                    param_idx += 1\n\n                for i in range(n_qubits - 1):\n                    circuit.append(('CNOT', i, i + 1))\n\n            # Measurement layer\n            for i in range(n_qubits):\n                circuit.append(('RZ', i, params[param_idx]))\n                param_idx += 1\n\n            return circuit\n\n        # Apply decoding circuit\n        decoded_state = self.network.apply_quantum_circuit_to_state(\n            decoding_circuit(parameters), latent_state\n        )\n\n        # Convert to classical reconstruction\n        reconstruction = np.abs(decoded_state.amplitudes) ** 2\n        return reconstruction\n\n    def elbo_loss(self, data, encoder_params, decoder_params):\n        \"\"\"Evidence Lower BOund loss function.\"\"\"\n\n        # Encode data to latent distribution\n        latent_state = self.encode(data, encoder_params)\n\n        # Decode latent state\n        reconstruction = self.decode(latent_state, decoder_params)\n\n        # Reconstruction loss\n        reconstruction_loss = np.mean((data - reconstruction) ** 2)\n\n        # KL divergence regularization (latent prior)\n        uniform_prior = np.ones(2**self.latent_dim) / (2**self.latent_dim)\n        latent_probs = np.abs(latent_state.amplitudes) ** 2\n\n        epsilon = 1e-10\n        kl_divergence = np.sum(latent_probs * np.log(\n            (latent_probs + epsilon) / (uniform_prior + epsilon)\n        ))\n\n        # Total ELBO\n        beta = 0.1  # KL weight\n        elbo = reconstruction_loss + beta * kl_divergence\n\n        return elbo, reconstruction_loss, kl_divergence\n\n    def train(self, training_data, n_epochs=100, learning_rate=0.01):\n        \"\"\"Train quantum VAE.\"\"\"\n\n        # Initialize parameters\n        n_encoder_params = 2 * self.latent_dim * 2  # 2 layers, 2 rotations per qubit\n        n_decoder_params = 3 * self.latent_dim * 2  # 2 layers + measurement\n\n        encoder_params = np.random.uniform(0, 2*np.pi, n_encoder_params)\n        decoder_params = np.random.uniform(0, 2*np.pi, n_decoder_params)\n\n        loss_history = []\n\n        for epoch in range(n_epochs):\n            epoch_loss = 0\n\n            for data_point in training_data:\n                # Compute loss and gradients\n                loss, recon_loss, kl_loss = self.elbo_loss(\n                    data_point, encoder_params, decoder_params\n                )\n\n                # Compute gradients (finite differences for simplicity)\n                encoder_grad = self.compute_gradient(\n                    lambda p: self.elbo_loss(data_point, p, decoder_params)[0],\n                    encoder_params\n                )\n\n                decoder_grad = self.compute_gradient(\n                    lambda p: self.elbo_loss(data_point, encoder_params, p)[0],\n                    decoder_params\n                )\n\n                # Update parameters\n                encoder_params -= learning_rate * encoder_grad\n                decoder_params -= learning_rate * decoder_grad\n\n                epoch_loss += loss\n\n            avg_loss = epoch_loss / len(training_data)\n            loss_history.append(avg_loss)\n\n            if epoch % 10 == 0:\n                print(f\"Epoch {epoch}, Average Loss: {avg_loss:.6f}\")\n\n        self.encoder_parameters = encoder_params\n        self.decoder_parameters = decoder_params\n\n        return {\n            \"loss_history\": loss_history,\n            \"final_loss\": loss_history[-1],\n            \"encoder_parameters\": encoder_params,\n            \"decoder_parameters\": decoder_params\n        }\n\n# Example: Train quantum VAE\nqvae = QuantumVariationalAutoencoder(network, latent_dim=4)\n\n# Generate training data\ntraining_data = [network.sample() for _ in range(100)]\n\n# Train model\nvae_result = qvae.train(training_data, n_epochs=50, learning_rate=0.02)\nprint(f\"QVAE training complete. Final loss: {vae_result['final_loss']:.6f}\")\n</code></pre>"},{"location":"guide/variational/#optimization-techniques","title":"Optimization Techniques","text":""},{"location":"guide/variational/#gradient-free-optimization","title":"Gradient-Free Optimization","text":"<pre><code># Evolutionary optimization for quantum circuits\nfrom scipy.optimize import differential_evolution\n\ndef evolutionary_vqe(network, hamiltonian, n_parameters):\n    \"\"\"VQE using evolutionary optimization.\"\"\"\n\n    def cost_function(parameters):\n        \"\"\"Cost function for evolutionary optimizer.\"\"\"\n        circuit = ansatz(parameters)\n        state = network.apply_variational_circuit(circuit)\n        energy = np.real(np.conj(state.amplitudes) @ hamiltonian @ state.amplitudes)\n        return energy\n\n    # Define bounds for parameters\n    bounds = [(0, 2*np.pi) for _ in range(n_parameters)]\n\n    # Run differential evolution\n    result = differential_evolution(\n        cost_function,\n        bounds,\n        maxiter=200,\n        popsize=15,\n        seed=42\n    )\n\n    return {\n        \"optimal_parameters\": result.x,\n        \"optimal_energy\": result.fun,\n        \"success\": result.success,\n        \"n_evaluations\": result.nfev\n    }\n\n# Example usage\nevo_result = evolutionary_vqe(network, hamiltonian, n_parameters=4)\nprint(f\"Evolutionary VQE result: {evo_result}\")\n</code></pre>"},{"location":"guide/variational/#gradient-based-optimization-with-parameter-shift","title":"Gradient-Based Optimization with Parameter Shift","text":"<pre><code>def parameter_shift_gradient(network, cost_function, parameters, shift=np.pi/2):\n    \"\"\"Compute gradients using parameter shift rule.\"\"\"\n\n    gradients = np.zeros_like(parameters)\n\n    for i in range(len(parameters)):\n        # Shift parameter forward\n        params_plus = parameters.copy()\n        params_plus[i] += shift\n        cost_plus = cost_function(params_plus)\n\n        # Shift parameter backward\n        params_minus = parameters.copy()\n        params_minus[i] -= shift\n        cost_minus = cost_function(params_minus)\n\n        # Compute gradient\n        gradients[i] = (cost_plus - cost_minus) / 2\n\n    return gradients\n\ndef gradient_descent_vqe(network, hamiltonian, n_parameters, learning_rate=0.1, max_iterations=100):\n    \"\"\"VQE with gradient descent using parameter shift rule.\"\"\"\n\n    # Initialize parameters\n    parameters = np.random.uniform(0, 2*np.pi, n_parameters)\n\n    def vqe_cost(params):\n        circuit = ansatz(params)\n        state = network.apply_variational_circuit(circuit)\n        return np.real(np.conj(state.amplitudes) @ hamiltonian @ state.amplitudes)\n\n    cost_history = []\n\n    for iteration in range(max_iterations):\n        # Compute cost and gradient\n        cost = vqe_cost(parameters)\n        gradient = parameter_shift_gradient(network, vqe_cost, parameters)\n\n        # Update parameters\n        parameters -= learning_rate * gradient\n\n        cost_history.append(cost)\n\n        if iteration % 20 == 0:\n            print(f\"Iteration {iteration}, Cost: {cost:.6f}\")\n\n    return {\n        \"optimal_parameters\": parameters,\n        \"optimal_cost\": cost_history[-1],\n        \"cost_history\": cost_history\n    }\n\n# Run gradient-based VQE\ngrad_vqe_result = gradient_descent_vqe(network, hamiltonian, n_parameters=4)\nprint(f\"Gradient VQE final cost: {grad_vqe_result['optimal_cost']:.6f}\")\n</code></pre>"},{"location":"guide/variational/#performance-analysis","title":"Performance Analysis","text":""},{"location":"guide/variational/#convergence-monitoring","title":"Convergence Monitoring","text":"<pre><code>def analyze_convergence(cost_history, window_size=10):\n    \"\"\"Analyze convergence of variational optimization.\"\"\"\n\n    if len(cost_history) &lt; window_size:\n        return {\"converged\": False, \"reason\": \"Insufficient iterations\"}\n\n    # Moving average\n    moving_avg = np.convolve(cost_history, np.ones(window_size)/window_size, mode='valid')\n\n    # Convergence criteria\n    final_variance = np.var(moving_avg[-window_size:])\n    relative_change = abs(moving_avg[-1] - moving_avg[-window_size]) / abs(moving_avg[-window_size])\n\n    converged = final_variance &lt; 1e-8 and relative_change &lt; 1e-6\n\n    return {\n        \"converged\": converged,\n        \"final_variance\": final_variance,\n        \"relative_change\": relative_change,\n        \"moving_average\": moving_avg\n    }\n\n# Analyze VQE convergence\nconvergence_analysis = analyze_convergence(grad_vqe_result['cost_history'])\nprint(f\"Convergence analysis: {convergence_analysis}\")\n</code></pre>"},{"location":"guide/variational/#barren-plateau-detection","title":"Barren Plateau Detection","text":"<pre><code>def detect_barren_plateau(network, cost_function, n_parameters, n_samples=100):\n    \"\"\"Detect barren plateau in variational landscape.\"\"\"\n\n    gradient_variances = []\n\n    for _ in range(n_samples):\n        # Random parameter initialization\n        random_params = np.random.uniform(0, 2*np.pi, n_parameters)\n\n        # Compute gradient\n        gradient = parameter_shift_gradient(network, cost_function, random_params)\n\n        # Compute gradient variance\n        grad_variance = np.var(gradient)\n        gradient_variances.append(grad_variance)\n\n    avg_gradient_variance = np.mean(gradient_variances)\n\n    # Barren plateau threshold (problem-dependent)\n    barren_threshold = 1e-6\n\n    return {\n        \"barren_plateau_detected\": avg_gradient_variance &lt; barren_threshold,\n        \"average_gradient_variance\": avg_gradient_variance,\n        \"gradient_variances\": gradient_variances\n    }\n\n# Check for barren plateaus\nplateau_analysis = detect_barren_plateau(\n    network, \n    lambda params: vqe_cost(params),  # Define vqe_cost appropriately\n    n_parameters=4\n)\nprint(f\"Barren plateau analysis: {plateau_analysis}\")\n</code></pre>"},{"location":"guide/variational/#best-practices","title":"Best Practices","text":""},{"location":"guide/variational/#circuit-design","title":"Circuit Design","text":"<ol> <li>Expressivity vs Trainability: Balance circuit depth with trainability</li> <li>Problem-Tailored Ans\u00e4tze: Design circuits specific to problem structure</li> <li>Parameter Initialization: Use informed initialization strategies</li> <li>Regularization: Add constraints to prevent overfitting</li> </ol>"},{"location":"guide/variational/#optimization-strategies","title":"Optimization Strategies","text":"<ol> <li>Multi-Scale Optimization: Combine global and local optimization</li> <li>Adaptive Learning Rates: Adjust learning rates during training</li> <li>Ensemble Methods: Use multiple random initializations</li> <li>Early Stopping: Prevent overfitting with validation monitoring</li> </ol>"},{"location":"guide/variational/#next-steps","title":"Next Steps","text":"<ul> <li>Explore practical Examples using variational methods</li> <li>Learn about Advanced Topics in quantum optimization</li> <li>See API Reference for variational algorithm documentation</li> <li>Check Performance Optimization for scaling guidelines</li> </ul>"}]}